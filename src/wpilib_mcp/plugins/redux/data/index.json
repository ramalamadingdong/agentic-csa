{
  "vendor": "redux",
  "version": "latest",
  "built_at": "2025-12-04T21:08:39.643665",
  "pages": [
    {
      "url": "https://docs.reduxrobotics.com/canandgyro/",
      "title": "Boron Canandgyro Overview",
      "section": "Canandgyro",
      "language": "All",
      "content": "Boron Canandgyro Overview # Getting Started Overview Gyro Axes Mounting Wiring Calibration Configuring Vendordep Soldering Specifications Specifications CAN Bus requirements Competitor Performance Comparison Units tested Setup Results Yaw No-Motion Stability Yaw Motion Stability Shock Stability Yaw Sensitivity LED Codes Known Issues Long Settling Time for Pitch and Roll Solution Pitch and Roll Sensitivity Solution Programming Your Canandgyro Programming Overview Constructor Calibration Check Heading Party Mode Presence Detection Temperature Reset To Factory Default Calibration Overview Canandgyro Settings Creation Writing Settings To The Canandgyro Fetching Settings From Device Yaw Frame Period Angular Position Frame Period Angular Velocity Frame Period Acceleration Frame Period Status Frame Period Boron Canandgyro Faults Fetching Faults Types Of Faults Power Cycle CAN ID Conflict CAN General Error Out Of Temperature Range Hardware Fault Calibrating Angular Velocity Saturation Acceleration Saturation Usage in FTC Case considerations Wiring Mounting Robot configuration Programming the Analog Canandgyro Field-centric teleop",
      "content_preview": "Boron Canandgyro Overview # Getting Started Overview Gyro Axes Mounting Wiring Calibration Configuring Vendordep Soldering Specifications Specifications CAN Bus requirements Competitor Performance Comparison Units tested Setup Results Yaw No-Motion Stability Yaw Motion Stability Shock Stability Yaw..."
    },
    {
      "url": "https://docs.reduxrobotics.com/canandcolor/getting-started.html",
      "title": "Getting Started",
      "section": "Canandcolor",
      "language": "All",
      "content": "Getting Started # The Redux Canandcolor is a versatile solution for measuring the proximity and color of a sensed object. It’s the perfect all-in-one solution for sensing objects in an intake, zeroing mechanisms, and indexing objects. The Canandcolor can also be configured down to 0% CAN bus utilization, sending data packets only when specified color or proximity conditions are met. The sensor integrates a IR proximity sensor and RGBW color sensor, as well as a bright on-board LED for low light conditions. The Canandcolor also contains two flexible digital ports, which can output signals based on proximity and color thresholds. This means you can run the Canandcolor completely headlessly, even outputting a PWM signal to your robot controller for more information in this mode. Overview # Low profile and compact design Secure, locking JST-PA connector for easy power, CAN connections, and digital connections Wide input voltage range (4.5v ~ 18v) Onboard ultra-bright LED for low light conditions Low CAN bus utilization by default (1.0%) Special “Near-Zero” CAN Utilization configurations with ultra-low latency Ultra-fast 5ms latency proximity sensing 25ms latency color sensing up to 4” away HSV color readings for much easier tuning than RGB Digital outputs for headless operation and controller DIO interrupts Mounting # The Canandcolor can be mounted using two #10 or M5 screws on a 1” (25.4mm) hole pattern. A drawing of the Canandcolor is shown below. The Canandcolor measures 1.024” long, 1.496” wide, and 0.510” tall. One of the holes can be used to locate a printable “photogate” attachment to allow the precise contactless zeroing of mechanisms (such as arms or elevators) without fear of foreign debris tripping the sensor accidentally. Below is a picture of this setup. With the photogate attachment, you will need to use a longer #10 or M5 screw to mount the Canandcolor to your robot. Wiring # The Canandcolor can be powered from any source between 4.5-18V, meaning that it can be powered directly from 12V battery power. The Canandcolor also has reverse-polarity protection. Configuring # The Canandcolor can be configured from the Alchemist Configuration Tool . See the Canandcolor Alchemist Guide for more information on how to use it with this sensor. Vendordep # Note ReduxLib Canandcolor support releases soon. CAN usage and configuring the device requires ReduxLib to be installed. API Docs are coming soon.",
      "content_preview": "Getting Started # The Redux Canandcolor is a versatile solution for measuring the proximity and color of a sensed object. It’s the perfect all-in-one solution for sensing objects in an intake, zeroing mechanisms, and indexing objects."
    },
    {
      "url": "https://docs.reduxrobotics.com/canandcolor/index.html",
      "title": "Canandcolor Overview",
      "section": "Canandcolor",
      "language": "All",
      "content": "Canandcolor Overview # Getting Started Overview Mounting Wiring Configuring Vendordep How does Canandcolor work? IR Proximity Color Sensor Performance Specifications General Specifications LED Codes Canandcolor Alchemist Guide Overview Sensor Card Setting Card Frames Digital Output Sensor Settings Programming Your Canandcolor Programming Overview Constructor Reading Proximity Reading Color Presence Detection Temperature Reset To Factory Default General Canandcolor Settings Creation Writing Settings To The Canandcolor Fetching Settings From Device Settings Status Frame Period Proximity Frame Period Color Frame Period Digout Frame Period Set Lamp LED Set Lamp LED Brightness Proximity Sensor Config Color Sensor Config Digital Output Config Proximity Sensor Settings Integration Period Color Sensor Settings Integration Period Canandcolor Digital Ports PWM Mode Digital Logic Mode Low-Latency and Near-Zero Utilization Usage",
      "content_preview": "Canandcolor Overview # Getting Started Overview Mounting Wiring Configuring Vendordep How does Canandcolor work? IR Proximity Color Sensor Performance Specifications General Specifications LED Codes Canandcolor Alchemist Guide Overview Sensor Card Setting Card Frames Digital Output Sensor Settings..."
    },
    {
      "url": "https://docs.reduxrobotics.com/canandgyro/programming/faults.html",
      "title": "Boron Canandgyro Faults",
      "section": "Canandgyro",
      "language": "All",
      "content": "Boron Canandgyro Faults # CanandgyroFaults are a series of flags sent with the Boron’s status frame that indicate if the device is experiencing an issue. This API presents faults in two formats: active and sticky faults. Active faults are updated every time a status frame is sent, and thus if an issue is resolved it will update the fault flag accordingly. This is useful for issues that can be transient, such as undervoltage faults (which occurs during a brownout) Sticky faults do not automatically clear when set to true. For example, if a Boron briefly undervolts, due to a brownout, but normal power is later restored, the undervoltage fault will still be set to true. Sticky faults must be cleared by the user. Fetching Faults # Java // Get a Canandgyro object with CAN ID 0 Canandgyro canandgyro = new Canandgyro ( 0 ); // Fetch this Canandgyro's active faults CanandgyroFaults faults = canandgyro . getActiveFaults (); // Fetch this Canandgyro's sticky faults CanandgyroFaults sticky = canandgyro . getStickyFaults (); C++ //Get a Canandgyro object with CAN ID 0 Canandgyro canandgyro { 0 }; //Fetch this Canandgyro's active faults CanandgyroFaults faults = canandgyro . GetActiveFaults (); //Fetch this Canandgyro's sticky faults CanandgyroFaults sticky = canandgyro . GetStickyFaults (); How to clear sticky faults Java canandgyro . clearStickyFaults (); C++ canandgyro . ClearStickyFaults (); Types Of Faults # Power Cycle # The Power Cycle fault is set to true when the gyro powers on. By clearing sticky faults on initialization, this flag can be used to determine if the encoder has rebooted. CAN ID Conflict # The CAN ID Conflict flag is set to true when the device detects another device with the same CAN ID. While available in the API, you should check the physical device for the LED flashing blue (which indicates a detected CAN ID conflict). Alchemist should be used to configure the different devices to avoid CAN ID conflicts. CAN General Error # The CAN General Error flag is set to true if the encoder detects a problem with its ability to recieve CAN packets, or other issues with the CAN bus. Generally, this indicates an issue with the CAN wiring. Out Of Temperature Range # The Out Of Temperature Range flag is set to true if the encoder detects its temperature is outside the safe operating range. Hardware Fault # A Hardware Fault indicates the device has detected a problem during operation. For the Boron, this generally will indicate that the device is unable to communicate with the on board magnetic field sensors. Calibrating # The Calibrating flag is set to true if the device is currently calibrating. Angular Velocity Saturation # This fault is flagged if the rotation of the gyro exceeded the measurable rotation rate of the sensor. Acceleration Saturation # This fault is flagged if the acceleration experienced exceeds the measurable acceleration of the sensor.",
      "content_preview": "Boron Canandgyro Faults # CanandgyroFaults are a series of flags sent with the Boron’s status frame that indicate if the device is experiencing an issue. This API presents faults in two formats: active and sticky faults."
    },
    {
      "url": "https://docs.reduxrobotics.com/canandgyro/electrical-specs.html",
      "title": "Specifications",
      "section": "Canandgyro",
      "language": "All",
      "content": "Specifications # Specifications # Parameter Min Typ. Max Units Input Voltage 4.3 – 16 V Input Surge Voltage (5s) – – 20 V Current Draw – 40 – mA Ambient Temperature -30 – 70 °C Drift, no motion, cal’d, t=3hr – 0.2 – °/hour Drift, in motion, cal’d, t=2.5min – 0.25 – °/min Pitch/Roll Accuracy, no motion – 0.2 – ° Yaw Sensitivity – – 0.03 % Pitch and Roll Sensitivity – 0.5 – % Max Speed -2000 – 2000 °/s Max Acceleration -16 – 16 g Weight – 17 – grams CAN 2.0B Speed – 1 – Mbps CAN Bus Utilization (default) – 2.2 – % The Boron Canandgyro is protected from reverse polarity and can be powered from the USB port or the terminal block. The terminal block is connected to the solderpads internally. CAN Bus requirements # The Boron Canandgyro uses CAN 2.0B 1Mbps to communicate. The bus should be terminated with 120ohm resistors at both ends, such as those built into the PDP/PDH and RoboRIO. It does not support CAN-FD communication. The Yaw frame is set to 10ms (100Hz) by default and uses 1.0% of the bus on its own. Overriding the frame period to 5ms (200Hz) increases CAN utilization linearly to 2.0%.",
      "content_preview": "Specifications # Specifications # Parameter Min Typ. Max Units Input Voltage 4.3 – 16 V Input Surge Voltage (5s) – – 20 V Current Draw – 40 – mA Ambient Temperature -30 – 70 °C Drift, no motion, cal’d, t=3hr – 0.2 – °/hour Drift, in motion, cal’d, t=2.5min – 0.25 – °/min Pitch/Roll Accuracy, no..."
    },
    {
      "url": "https://docs.reduxrobotics.com/canandcolor/programming/settings.html",
      "title": "General Canandcolor Settings",
      "section": "Canandcolor",
      "language": "C++",
      "content": "General Canandcolor Settings # The CanandcolorSettings object is used to reconfigure the Canandcolor. Creation # Java // Create a blank object with no values. // Only values that are changed will be updated on the device. CanandcolorSettings settings = new CanandcolorSettings (); // Copy the values to a new settings object. CanandcolorSettings copiedSettings = new CanandcolorSettings ( settings ); C++ using namespace redux :: sensors :: canandcolor ; // Create with no values // Only values that are changed will be updated on the device. CanandcolorSettings settings ; // Copy the values to a new settings object via the copy constructor. CanandcolorSettings copiedSettings { settings }; Values are fetched and updated using the getter and setter functions in CanandcolorSettings. Important Only values updated by the user are changed on the device. Values that are not changed will remain the same Writing Settings To The Canandcolor # When you are ready to send and save the settings to the device, you can use Canandcolor.setSettings to transmit the contents of a CanandcolorSettings object to the Canandcolor. Java // A canandcolor object with CAN ID 0 Canandcolor canandcolor = new Canandcolor ( 0 ); // Create a new settings object CanandcolorSettings settings = new CanandcolorSettings (); // Setup some settings to write: // set lamp LED brightness to 40% settings . setLampLEDBrightness ( 0.4 ); // Write the settings to the Canandcolor with a timeout of 50 milliseconds per setting. // By default the settings will be written to flash -- they will persist on reboots. // If this is not desired, one can use // // settings.setEphemeral(true); // // to flag the settings as ephemeral (and not persist in flash on reboot). canandcolor . setSettings ( settings ); C++ using namespace redux :: sensors :: canandcolor ; // A canandcolor object with CAN ID 0 Canandcolor canandcolor { 0 }; // Create a new settings object CanandcolorSettings settings {}; // Setup some settings to write: // set lamp LED brightness to 40% settings . SetLampLEDBrightness ( 0.4 ); // Write the settings to the Canandcolor with a timeout of 50 milliseconds per setting. // By default the settings will be written to flash -- they will persist on reboots. // If this is not desired, one can use // // settings.SetEphemeral(true); // // to flag the settings as ephemeral (and not persist in flash on reboot). canandcolor . SetSettings ( settings ); Fetching Settings From Device # Settings can be fetched from the end device in both a synchronous and asynchronous manner. Due to the synchronous method blocking for 0.15-0.25 seconds, it is recommended to use it only in robot initialization or on a separate thread. The blocking method, Canandcolor.getSettings will always return a CanandcolorSettings object. The object returned will hold all the settings that were able to be successfully received. To check if all settings were successfully received, use the CanandcolorSettings.allSettingsReceived() method. The async method, Cannadcolor.getSettingsAsync will return the most recent set of settings that have been sent by the device since a preceding Canandcolor.startFetchSettings() . Similarly to getSettings , one can use the CanandcolorSettings.allSettingsReceived() method to check for the receipt of all settings. The getters on CanandcolorSettings objects either return a value if one was received, or null (Java)/std::nullopt (C++) if one was not. Synchronous (blocking) Java // A Canandcolor object with CAN ID 0 Canandcolor canandcolor = new Canandcolor ( 0 ); // Fetch this Canandcolor's settings. // This runs with a default timeout of 0.35 seconds. CanandcolorSettings settings = canandcolor . getSettings (); // Fetch this Canandcolor's settings. // This runs with a timeout of 0.5 seconds CanandcolorSettings settings = canandcolor . getSettings ( 0.5 ); // Fetch the status frame period from the received settings // This will be either a double (seconds) or null if the status frame period // was not successully received. if ( settings . getStatusFramePeriod () != null ) { System . out . printf ( \"Status frame period: %d\\n\" , settings . getStatusFramePeriod ()); } else { System . out . println ( \"getStatusFramePeriod returned null :/\" ); } C++ using namespace redux :: sensors :: canandcolor ; // A Canandcolor object with CAN ID 0 Canandcolor canandcolor { 0 }; // Fetch this Canandcolor's settings // This runs with a default timeout of 0.35 seconds CanandcolorSettings = canandcolor . GetSettings (); // Fetch this canandcolor's settings // This runs with a timeout of 0.5 seconds CanandcolorSettings = canandcolor . GetSettings ( 0.5 _s ); // Fetch the status frame period from the received settings // This will be either a double (seconds) or null if the status frame period // was not successully received. if ( settings . GetStatusFramePeriod ()) { fmt :: print ( \"Status frame period: {} \\n \" , settings . GetStatusFramePeriod ()); } else { fmt :: print ( \"GetStatusFramePeriod returned std::nullopt :/\" ); } Asynchronous (non-blocking) Java // A Canandcolor object with CAN ID 0 Canandcolor canandcolor = new Canandcolor ( 0 ); // Start the settings fetch canandcolor . startFetchSettings (); // ...spend some period of time waiting for settings... CanandcolorSettings settings = canandcolor . getSettingsAsync (); if ( settings . allSettingsReceived ()) { // We now know all settings have been received // ...do things with the settings object here... } C++ using namespace redux :: sensors :: canandcolor ; // A Canandcolor object with CAN ID 0 Canandcolor canandcolor { 0 }; // Start the settings fetch canandcolor . StartFetchSettings (); //...spend some period of time waiting for settings... CanandcolorSettings settings = canandcolor . GetSettingsAsync (); if ( settings . AllSettingsReceived ()) { // We now know all settings have been received // ...do things with the settings object here... } Settings # Status Frame Period # The status frame period is the time between status pockets being sent by the Phosphorus Canandcolor over the CAN Bus. By default, this value is 1 second, meaning a status packet is sent every 1000 milliseconds. Lower values will mean packets get sent more frequently, but will correspondingly increase CAN bus utilization. This value cannot be set to zero or disabled. The maximum value of this value is 16.383 seconds (16383 milliseconds). This value is set with a resolution of 0.001 seconds (1 millisecond). Default value : 1 second Minimum value : 1 second Maximum value : 16.383 seconds Note So what does the status frame actually do? The status frame carries information about the active faults (problems) with the device, its internal temperature reading, and some other general status information. This packet cannot be disabled as it is used for diagnostics and other critical functions. FIRST® Robotics Competition The CAN 2.0B bus in the FIRST® Robotics Competition operates at a rate of 1 Mbit/s, or 125000 bytes per second. To estimate CAN usage, you can multiply the size of the CAN packet by its send frequency in hertz, and divide that by 125000. CAN packets have 8 bytes of overhead. For example, a status packet is 6 bytes of data, so the full packet is 14 bytes. At 0.020 seconds, or 50 times a second, this takes up 700 / 125000 or 0.56% of the CAN bus. Java // Sets the status frame period to 1 second settings . setStatusFramePeriod ( 1 ); C++ // Sets the status frame period to 1 second settings . SetStatusFramePeriod ( 1 _s ); Proximity Frame Period # The proximity frame period is the time between proximity pockets being sent by the Phosphorus Canandcolor over the CAN Bus. By default, this value is 0.010 seconds, meaning a proximity packet is sent every 10 milliseconds (for a total of 100 times a second). This frame period supports aligning the frame to the integration period, which will automatically transmit early when new sensor data is available. In this mode, the frame period is the maximum allowed latency between packets. Lower values will mean packets get sent more frequently, but will correspondingly increase CAN bus utilization. This value can be set to 0, which disables the proximity output. The maximum value of this value is 65.535 seconds (65535 milliseconds). This value is set with a resolution of 0.001 seconds (1 millisecond). Default value : 0.010 seconds Minimum value : 0 seconds (disables proximity output) Maximum value : 65.535 seconds Java // Sets the proximity frame period to 10 milliseconds settings . setProximityFramePeriod ( 0.010 ); //Optional, aligns the proximity sensor frames to the integration period //This will cause the sensor to immediately transmit new data when available. settings . setAlignProximityFramesToIntegrationPeriod ( true ); C++ // Sets the proximity frame period to 10 milliseconds settings . SetProximityFramePeriod ( 10 _ms ); //Optional, aligns the proximity sensor frames to the integration period //This will cause the sensor to immediately transmit new data when available. settings . SetAlignProximityFramesToIntegrationPeriod ( true ); Color Frame Period # The color frame period is the time between color pockets being sent by the Phosphorus Canandcolor over the CAN Bus. By default, this value is 0.040 seconds, meaning a color packet is sent every 40 milliseconds (for a total of 25 times a second). This frame period supports aligning the frame to the integration period, which will automatically transmit early when new sensor data is available. In this mode, the frame period is the maximum allowed latency between packets. Lower values will mean packets get sent more frequently, but will correspondingly increase CAN bus utilization. This value can be set to 0, which disables the color output. The maximum value of this value is 65.535 seconds (65535 milliseconds). This value is set with a resolution of 0.001 seconds (1 millisecond). Default value : 0.040 seconds Minimum value : 0 seconds (disables color output) Maximum value : 65.535 seconds Java // Sets the color frame period to 40 milliseconds settings . setColorFramePeriod ( 0.040 ); //Optional, aligns the color sensor frames to the integration period //This will cause the sensor to immediately transmit new data when available. settings . setAlignColorFramesToIntegrationPeriod ( true ); C++ // Sets the color frame period to 40 milliseconds settings . SetColorFramePeriod ( 40 _ms ); //Optional, aligns the color sensor frames to the integration period //This will cause the sensor to immediately transmit new data when available. settings . SetAlignColorFramesToIntegrationPeriod ( true ); Digout Frame Period # The digout frame period is the time between digital output status pockets being sent by the Phosphorus Canandcolor over the CAN Bus. The digout packets contain the status of the two digital output lines. This frame supports emitting packets early on state change. This allows the user code to immediately react to changes in the digital output state instead of needing to wait for the next frames. By default, this value is 0.100 seconds, meaning a digout packet is sent every 100 milliseconds (for a total of 10 times a second). Lower values will mean packets get sent more frequently, but will correspondingly increase CAN bus utilization. This value can be set to 0, which disables the digout packet. The maximum value of this value is 65.535 seconds (65535 milliseconds). This value is set with a resolution of 0.001 seconds (1 millisecond). Note Disabling the digout packet does NOT disable the digital pins, and adjusting the period of this packet does not change the rate at which the digital pads update. Default value : 0.100 seconds Minimum value : 0 seconds (disables digout output) Maximum value : 65.535 seconds Java // Sets the digout frame period to 40 milliseconds settings . setDigoutFramePeriod ( 0.040 ); //Optional: Tells the device to early transmit a digital output packet if the status changes at all //This example shows setting it for digital output 1 settings . setDigoutFrameTrigger ( DigoutChannel . Index . kDigout1 , DigoutFrameTrigger . kRisingAndFalling ); C++ // Sets the digout frame period to 40 milliseconds settings . SetDigoutFramePeriod ( 40 _ms ); //Optional: Tells the device to early transmit a digital output packet if the status changes at all //This example shows setting it for digital output 1 settings . setDigoutFrameTrigger ( DigoutChannel :: Index :: kDigout1 , DigoutFrameTrigger :: kRisingAndFalling ); Set Lamp LED # Turns the onboard lamp LED on or off. Note The onboard LED switch must be in the ENABLE position for this to turn the lamp on and off. Default value : false Java // Turn on lamp settings . setLampLED ( true ); C++ // Turn on lamp settings . SetLampLED ( true ); Set Lamp LED Brightness # Sets the brightness of the onboard lamp LED. The lamp can still be turned on and off via setLampLED and the onboard switch. A value of 1.0 is full brightness, and a value of 0.0 is minimum brightness (off). For example, a value of 0.5 will be half of max brightness. Default value : 1.0 Java // Set lamp to full brightness settings . setLampLEDBrightness ( 1.0 ); C++ // Turn on lamp settings . SetLampLEDBrightness ( 1.0 ); Proximity Sensor Config # See: Canandcolor Proximity Settings Color Sensor Config # See: Canandcolor Color Settings Digital Output Config # See: Canandcolor Digital Ports",
      "content_preview": "General Canandcolor Settings # The CanandcolorSettings object is used to reconfigure the Canandcolor. Creation # Java // Create a blank object with no values. // Only values that are changed will be updated on the device."
    },
    {
      "url": "https://docs.reduxrobotics.com/canandgyro/soldering.html",
      "title": "Soldering",
      "section": "Canandgyro",
      "language": "All",
      "content": "Soldering # Soldering wires onto solderpads can look intimidating, so the Boron Canandgyro has been designed to make this as easy as possible. Please refer to the tutorial on the Helium page ( Soldering ) for instructions on soldering. The pads are the same size, though please note the order of the pads is different. The case screw on the underside of the gyro will need to be removed before accessing the solderpads. A Phillips #1 bit should be used to remove this screw. Be careful not to overtighten it when replacing it, as it is a plastic-tapping screw.",
      "content_preview": "Soldering # Soldering wires onto solderpads can look intimidating, so the Boron Canandgyro has been designed to make this as easy as possible. Please refer to the tutorial on the Helium page ( Soldering ) for instructions on soldering."
    },
    {
      "url": "https://docs.reduxrobotics.com/canandgyro/programming/normal-operation.html",
      "title": "Programming Overview",
      "section": "Canandgyro",
      "language": "C++",
      "content": "Programming Overview # The central point of the Boron Canandgyro in ReduxLib is the Canandgyro object. The Canandgyro object lets you read and write the device’s position, read and write settings, and read faults. Constructor # Creating a Canandgyro object is simple. The one parameter you need is the CAN ID assigned to the gyro, generally set in Alchemist. Danger Note that the Canandgyro only uses CAN 2.0B and will not work with CAN-FD. Java // Creates a Canandgyro object referencing a Canandgyro with CAN ID 0 Canandgyro canandgyro = new Canandgyro ( 0 ); C++ //Put the following in the header file #include <redux/sensors/Canandgyro.h> using namespace redux :: sensors :: canandgyro ; // Creates a canandgyro object referencing a canandgyro with CAN ID 0 Canandgyro canandgyro { 0 }; Calibration Check # The IsCalibrating function can be used to check if the gyro is in calibration. This is useful if you want to re-zero your gyro after it finishes its calibration. This matches onboard LED - returning True with a yellow LED, and False as the LED turns green. Java canandgyro . isCalibrating (); C++ canandgyro . IsCalibrating (); Heading # Java double heading = canandgyro . getYaw (); // gets the yaw (heading) in rotations Rotation3d rotation = canandgyro . getRotation3d (); // gets yaw, pitch, and roll in one Rotation3d object canandgyro . setYaw ( 0 ); // sets the yaw to 0 rotations. This does not affect pitch or roll. C++ units :: angle :: turn_t heading = canandgyro . GetYaw (); // gets the yaw in rotations frc :: Rotation3d rotation = canandgyro . GetRotation3d (); // gets yaw, pitch, and roll in one Rotation3d object canandgyro . SetYaw ( 0 _deg ); // sets the yaw to 0 degrees. This does not affect pitch or roll Party Mode # Party Mode is an identification tool that blinks the onboard LED different colors. Setting this to 0 will turn off party mode. Java // Starts party mode canandgyro . setPartyMode ( 1 ); // Stops party mode canandgyro . setPartyMode ( 0 ); C++ // Starts party mode canandgyro . SetPartyMode ( 1 ); // Stops party mode canandgyro . SetPartyMode ( 0 ); Presence Detection # Presence Detection checks if the gyro has sent a message in the last 2 seconds. This is a useful tool to ensure that the gyro has not been disconnected from the CAN bus. Java canandgyro . isConnected (); C++ canandgyro . IsConnected (); Temperature # The temperature function reports the onboard temperature reading of the device. This should be kept within 0 and 70 degrees Celsius for normal operation. Java canandgyro . getTemperature (); C++ canandgyro . GetTemperature (); Reset To Factory Default # Danger Resetting the gyro to factory default will wipe all settings except for the CAN ID. There is no way to undo this other then manually re-inputting all of your settings. In general, it is better practice to set the settings you want to be ensured to set a specific value than factory-resetting on every program start, as this reduces wear on the internal non-volatile flash memory. Resets the gyro to factory zero, keeping its current CAN ID. This is a blocking operation. Java canandgyro . resetFactoryDefaults (); C++ canandgyro . ResetFactoryDefaults ();",
      "content_preview": "Programming Overview # The central point of the Boron Canandgyro in ReduxLib is the Canandgyro object. The Canandgyro object lets you read and write the device’s position, read and write settings, and read faults. Constructor # Creating a Canandgyro object is simple."
    },
    {
      "url": "https://docs.reduxrobotics.com/canandcolor/programming/color-settings.html",
      "title": "Color Sensor Settings",
      "section": "Canandcolor",
      "language": "All",
      "content": "Color Sensor Settings # Integration Period # The integration period of the sensor is how long it reads light for. The sensor operates similarly to a camera, detecting light that hits the sensor over a given period of time. Therefore, the integration period is similar to exposure time. Longer integration times will be slightly more stable and have slightly longer range, at the tradeoff of slower reads. The default of 25ms is generally a good tradeoff between stability and speed. Important Although there is an integration period option of 3ms, the sensor itself will still only update at 25ms when this option is set. This lower exposure time is useful if the sensor is being used in an environment with a high amount of light. Java //Sets the integration period to 20 ms settings . setColorIntegrationPeriod ( ColorPeriod . k25ms ); C++ //Sets the integration period to 20 ms settings . SetColorIntegrationPeriod ( ColorPeriod :: k25ms );",
      "content_preview": "Color Sensor Settings # Integration Period # The integration period of the sensor is how long it reads light for. The sensor operates similarly to a camera, detecting light that hits the sensor over a given period of time. Therefore, the integration period is similar to exposure time."
    },
    {
      "url": "https://docs.reduxrobotics.com/canandgyro/performance.html",
      "title": "Competitor Performance Comparison",
      "section": "Canandgyro",
      "language": "All",
      "content": "Competitor Performance Comparison # The Boron Canandgyro is rated for some level of in-motion and and no-motion drift. But how does it stack up to the competition? Below, we have performed some performance comparisons between the Boron and a couple other gyros common in FRC. Units tested # Boron CanandGyro Competitor “Avian” CAN Gyro #1 Competitor “Avian” CAN Gyro #2 Setup # The three gyros were stacked on top of each other and secured to a fixture with screws. The fixture was mounted to a motorized jig to automate testing. Results # Yaw No-Motion Stability # No-Motion Stability is the error in Yaw when the gyro is left unmoving for long periods of time. The gyro fixture is calibrated, zeroed, and then left sitting still for eight hours. Yaw error is logged. The highest slope in any one-hour period and the average slope over eight hours is recorded. Parameter Boron CAN Gyro 2 CAN Gyro 1 Average Drift in 8 Hours (°/hr) 0.009 0.034 15.9 Max Drift in 1 Hour (°/hr) 0.098 0.125 15.9 The Boron has significantly lower no-motion drift than the competition. In the context of an FRC application, both the Boron and CAN Gyro 2 perform admirably. CAN Gyro 1 has enough drift to cause issues if a robot were to be left sitting for a few minutes before a match. Yaw Motion Stability # Yaw Motion Stability is the accuracy of a gyro while rotating about the Z axis. This test runs the gyro through a 150-second simulated FRC match. The fixture is vibrated while a stepper motor rotates the gyro to angles recorded by a real FRC robot during a logged match. The motor is returned to an angle of 0 after the test and the error of the gyro is recorded. This test is repeated 10 times without zeroing, allowing for 30 seconds of rest between trials. The total test time is 38 minutes. The drift per minute was calculated by dividing the drift for a single “match” by 2.5 minutes. The first match is discarded to allow the test fixture to settle repeatably. Parameter Boron CAN Gyro 2 CAN Gyro 1 Average Drift (°/min) 0.18 0.50 1.76 Max Drift (°/min) 0.32 0.80 2.14 The Boron has much lower in-motion drift than the competition. The fixture has more random vibration than a typical FRC robot would have. This increases the drift to closer to what would be seen in an FRC match. Non-FRC applications may see varying vibration as well, such as engine vibration in cars. If your application has heavy vibration or very frequent collisions, you may experience more in-motion yaw drift. Many factors go into a good in-motion drift test, and it’s impossible to capture all of those in a single test. In repeated runs of this test, the Boron averaged anywhere from 0.11 to 0.40 deg/min of drift, and CAN Gyro 2 averaged 0.30 to 0.97 deg/min of drift. Running different match profiles also affected the drift. This test should be viewed as a point of comparison between products, and not necessarily an example of the exact performance you will get with a Boron. Shock Stability # The gyro fixture is rapidly rotated to 2 degrees, the back to 0 degrees, with acceleration between 1-8g, to simulate a mechanical shock. 6 shocks are performed in one cycle, and the fixture is allowed to rest for 15 seconds to settle to a final yaw after a full cycle before each measurement is taken. 50 cycles were performed (300 total shocks) Parameter Boron CAN Gyro 2 CAN Gyro 1 RMS Drift (°/impact) 0.005 0.019 0.095 Worst Drift (°/impact) 0.010 0.040 0.257 The Boron has the best shock resistance of the gyros tested. The settling time is included as part of the yaw drift because sudden shocks can sometimes throw off a gyro calibration, resulting in drift for a few seconds after a shock as the gyro corrects itself. The Boron has been designed to be highly resistant to sudden shocks, which is why its drift during and after impact is so low. The RMS drift is shown instead of the average drift to weight greater heading failures more strongly. Yaw Sensitivity # Gyro sensitivity is how much error a gyro accumulates when rotating in a single direction for multiple revolutions. Rotating the gyro the other way until the original zero is reached will cancel out sensitivity errors. This test spins the gyro 10 rotations counter-clockwise and reads the angle. Then, it spins it 20 rotations clockwise and reads the new angle. The gyro is then returned to zero. The gyro has the yaw zeroed before repeating the test. The sensitivity error is equal to the average yaw error per rotation. Sensitivity is a constant for each gyro, so we do not need to test the maximum. Parameter Boron CAN Gyro 2 CAN Gyro 1 Average Sensitivity Error (°/rev) 0.04 0.34 0.13 The results of this test rely highly on the quality of the calibration performed on each unit. Small differences in the mounting or fixture repeatability create sensitivity error, and it’s easy to tune a “golden sample” to have almost zero sensitivity error. At Redux, we strive to make sure every gyro has a yaw sensitivity error of less than 0.1 degrees per revolution. Note that the Boron is not tuned for sensitivity in the pitch (x) and roll (y) axes. Typical pitch and roll sensitivity error is better than 1%, meaning that a dynamic roll of 10 degrees would have up to 0.1 degrees of error. For applications that do not undergo multiple full rotations, this should not be perceptible. Accelerometer correction of pitch and roll will correct any errors after a few seconds of no-motion.",
      "content_preview": "Competitor Performance Comparison # The Boron Canandgyro is rated for some level of in-motion and and no-motion drift. But how does it stack up to the competition? Below, we have performed some performance comparisons between the Boron and a couple other gyros common in FRC."
    },
    {
      "url": "https://docs.reduxrobotics.com/canandcolor/programming/digital-ports.html",
      "title": "Canandcolor Digital Ports",
      "section": "Canandcolor",
      "language": "C++",
      "content": "Canandcolor Digital Ports # The canandcolor’s digital ports are very flexible outputs that can be used in multiple modes. Primarily, they are grouped into two categories: PWM output mode and digital logic mode. In PWM mode, selected values (such as proximity, red channel, HSV hue, etc) are transmitted via a PWM signal. In digital logic mode, a custom digital logic system can be used to trigger the port on and off. PWM Mode # The digital output ports can be configured to output the Red, Blue, Green, White, Hue, Saturation, Value, or Proximity values over PWM. Disabling a value’s CAN packet rate will not disable its PWM output, so this can be used without the CAN output. Important This can only be done on Digital Output 2! Java // A Canandcolor object with CAN ID 0 Canandcolor canandcolor = new Canandcolor ( 0 ); // Instantiate an empty settings object CanandcolorSettings settings = canandcolor . getSettings (); // Sets DIG2 to output proximity over PWM settings . setDigoutPinConfig ( DigoutChannel . Index . kDigout2 , DataSource . kProximity ); // Apply the configuration to the device. if ( canandcolor . setSettings ( settings )) { System . out . println ( \"digout configuration success\" ); } else { System . out . println ( \"digout configuration failure\" ); } C++ using namespace redux :: sensors :: canandcolor ; using namespace redux :: sensors :: canandcolor :: digout ; // Get a canandcolor object with CAN ID 0 Canandcolor canandcolor { 0 }; // Instantiate an empty settings object. CanandcolorSettings settings {}; // Sets DIG2 to output proximity over PWM settings . SetDigoutOutputConfig ( DigoutChannel :: Index :: kDigout2 , DataSource :: kProximity ); if ( canandcolor . SetSettings ( settings ). IsEmpty ()) { fmt :: println ( \"Settings set correctly!\" ); } else { fmt :: println ( \"Settings did not set correctly\" ); } Digital Logic Mode # The canandcolor digital outputs can also be configured based off of programmable thresholds. Two versions, RGB and HSV configs are provided, and both can be programmed with distance thresholds as well. Here is an example of creating an RGB threshold. Java // a Canandcolor object with CAN ID 0 Canandcolor canandcolor = new Canandcolor ( 0 ); //Fetch this canandcolor's settings //This runs with a default timeout of 0.35 seconds CanandcolorSettings settings = canandcolor . getSettings (); //Tells the device to emit a CAN packet immediately when the digout state changes settings . setDigoutFrameTrigger ( DigoutChannel . Index . kDigout1 , DigoutFrameTrigger . kRisingAndFalling ); //Configures the output pin to be active high. This means the pin will be ON when the digital output is TRUE canandcolor . digout1 (). configureOutputPin ( DigoutPinConfig . kDigoutLogicActiveHigh ); //Create an HSV threshold on digital output 1 //This will trigger if the following conditions are met: //Proximity is less then 0.15 for more then 0.01 seconds //Hue is between 0.5 and 0.7 for 0.01 //This detects light blue items color . digout1 (). configureSlots ( new HSVDigoutConfig () . setMaxProximity ( 0.15 ) . setProximityInRangeFor ( 0.01 ) . setMinHue ( 0.5 ) . setMaxHue ( 0.7 ) . setColorInRangeFor ( 0.01 ) ); //Save settings to device canandcolor . setSettings ( settings , 0.050 ); C++ //Coming soon",
      "content_preview": "Canandcolor Digital Ports # The canandcolor’s digital ports are very flexible outputs that can be used in multiple modes. Primarily, they are grouped into two categories: PWM output mode and digital logic mode."
    },
    {
      "url": "https://docs.reduxrobotics.com/canandcolor/programming/index.html",
      "title": "Programming Your Canandcolor",
      "section": "Canandcolor",
      "language": "All",
      "content": "Programming Your Canandcolor # Programming Overview Constructor Reading Proximity Reading Color Presence Detection Temperature Reset To Factory Default General Canandcolor Settings Creation Writing Settings To The Canandcolor Fetching Settings From Device Settings Status Frame Period Proximity Frame Period Color Frame Period Digout Frame Period Set Lamp LED Set Lamp LED Brightness Proximity Sensor Config Color Sensor Config Digital Output Config Proximity Sensor Settings Integration Period Color Sensor Settings Integration Period Canandcolor Digital Ports PWM Mode Digital Logic Mode Low-Latency and Near-Zero Utilization Usage",
      "content_preview": "Programming Your Canandcolor # Programming Overview Constructor Reading Proximity Reading Color Presence Detection Temperature Reset To Factory Default General Canandcolor Settings Creation Writing Settings To The Canandcolor Fetching Settings From Device Settings Status Frame Period Proximity..."
    },
    {
      "url": "https://docs.reduxrobotics.com/canandcolor/programming/zero-latency.html",
      "title": "Low",
      "section": "Canandcolor",
      "language": "All",
      "content": "Low-Latency and Near-Zero Utilization # One of the greatest strengths of the Canandcolor is that you can program it to have near-zero CAN utilization, without sacrificing the ability to detect objects and colors at the full speed of the sensor (200Hz for proximity, 40Hz for color). This is accomplished by linking the digital output CAN frame to the state of the digital output in the sensor. When the digital output trips, a frame is sent, allowing only infrequent updates when the digital logic is not being tripped. Running the Canandcolor in a near-zero utilization mode enables users to put many Canandcolors on a robot, such as for game piece indexing, without loading up the CANbus with unecessary traffic. Canandcolors can be configured to automatically send out frames when certain conditions are met, such when an object has been detected. Note Note that achieving “true” 0% utilization is not recommended, as the device may show up as disconnected from CANbus due to low traffic. It can also make debugging difficult, as CAN data will not update without any frames. However, getting under 0.1% utilization is easy, as we will see below. Usage # Setting up near-zero utilization operation is accomplished by setting CAN frame periods very high, setting up a digital output, and aligning the edges of the digital output to the CAN frame transmission trigger. Java //Create a Canandcolor object with CAN ID 0 Canandcolor canandcolor = new Canandcolor ( 0 ); //Instantiate an empty settings object. CanandcolorSettings settings = canandcolor . getSettings (); //Sets all frame periods to 0.5 seconds to achieve less than 0.1% total CANbus utilization settings . setColorFramePeriod ( 0.5 ); settings . setProximityFramePeriod ( 0.5 ); settings . setDigoutFramePeriod ( 0.5 ); settings . setStatusFramePeriod ( 0.5 ); //As an example, we are going to update the proximity and color data very quickly //In your application, you should set these appropriately depending on environmental conditions //This is to show how we can detect at the full bandwidth of the sensor without high latency or can utilization settings . setProximityIntegrationPeriod ( ProximityPeriod . k5ms ); settings . setColorIntegrationPeriod ( ColorPeriod . k25ms ); //Ensure that proximity and color frames are not sent out automatically when the sensor data updates settings . setAlignProximityFramesToIntegrationPeriod ( false ); settings . setAlignColorFramesToIntegrationPeriod ( false ); //Sets digital output port 1 to use the digital logic system, setting it to normally closed settings . setDigoutPinConfig ( canandcolor . digout1 (). channelIndex (), DigoutPinConfig . kDigoutLogicNormallyClosed ); //Sets the digout frame trigger to send when the digout goes high or low settings . setDigoutFrameTrigger ( canandcolor . digout1 (). channelIndex (), DigoutFrameTrigger . kRisingAndFalling ); //Save settings to device canandcolor . setSettings ( settings ); //Configure the digout slot to trigger when proximity is between 0 and 0.5 canandcolor . digout1 (). configureSlots ( new HSVDigoutConfig () . setMaxProximity ( 0.5 ) . setMinProximity ( 0 ) ); //canandcolor.digout1().getValue() will be updated every time the sensor enters or exit a digout trigger state. C++ //Create a Canandcolor object with CAN ID 0 Canandcolor canandcolor { 0 }; //Instantiate an empty settings object. CanandcolorSettings settings {}; //Sets all frame periods to 0.5 seconds to achieve less than 0.1% total CANbus utilization settings . SetColorFramePeriod ( 0.5 ); settings . SetProximityFramePeriod ( 0.5 ); settings . SetDigoutFramePeriod ( 0.5 ); settings . SetStatusFramePeriod ( 0.5 ); //As an example, we are going to update the proximity and color data very quickly //In your application, you should set these appropriately depending on environmental conditions //This is to show how we can detect at the full bandwidth of the sensor without high latency or can utilization settings . SetProximityIntegrationPeriod ( ProximityPeriod :: k5ms ); settings . SetColorIntegrationPeriod ( ColorPeriod :: k25ms ); //Ensure that proximity and color frames are not sent out automatically when the sensor updates settings . SetAlignProximityFramesToIntegrationPeriod ( false ); settings . SetAlignColorFramesToIntegrationPeriod ( false ); //Sets digital output port 1 to use the digital logic system, setting it to normally closed settings . SetDigoutPinConfig ( canandcolor :: Digout1 () :: ChannelIndex (), DigoutPinConfig :: kDigoutLogicNormallyClosed ); //Sets the digout frame trigger to send when the digout goes high or low settings . SetDigoutFrameTrigger ( canandcolor :: Digout1 () :: ChannelIndex (), DigoutFrameTrigger :: kRisingAndFalling ); //Save settings to device canandcolor . SetSettings ( settings ); //Configure the digout slot to trigger when the proximity is between 0 and 0.5 canandcolor :: Digout1 () :: ConfigureSlots ( new HSVDigoutConfig () :: SetMaxProximity ( 0.5 ) :: SetMinProximity ( 0 ) ); //canandcolor::Digout1()::GetValue() will be updated every time the sensor enters or exit a digout trigger state. Don’t forget to set the integration periods for the proximity and color sensors! Higher integration time will yield more accuracy and range at the cost of speed and latency.",
      "content_preview": "Low-Latency and Near-Zero Utilization # One of the greatest strengths of the Canandcolor is that you can program it to have near-zero CAN utilization, without sacrificing the ability to detect objects and colors at the full speed of the sensor (200Hz for proximity, 40Hz for color)."
    },
    {
      "url": "https://docs.reduxrobotics.com/canandcolor/programming/proximity-settings.html",
      "title": "Proximity Sensor Settings",
      "section": "Canandcolor",
      "language": "All",
      "content": "Proximity Sensor Settings # Integration Period # The integration period of the sensor is how long it reads IR light for. The sensor operates by emitting a pulse of IR light and recording the reflected light. The integration period is similar to the exposure time for a camera. Longer integration times will be slightly more stable and have slightly longer range, at the tradeoff of slower reads. The default of 20ms is generally a good tradeoff between stability and speed. Java //Sets the integration period to 20 ms settings . setProximityIntegrationPeriod ( ProximityPeriod . k20ms ); C++ //Sets the integration period to 20 ms settings . SetProximityIntegrationPeriod ( ProximityPeriod :: k20ms );",
      "content_preview": "Proximity Sensor Settings # Integration Period # The integration period of the sensor is how long it reads IR light for. The sensor operates by emitting a pulse of IR light and recording the reflected light. The integration period is similar to the exposure time for a camera."
    },
    {
      "url": "https://docs.reduxrobotics.com/canandgyro/index.html",
      "title": "Boron Canandgyro Overview",
      "section": "Canandgyro",
      "language": "All",
      "content": "Boron Canandgyro Overview # Getting Started Overview Gyro Axes Mounting Wiring Calibration Configuring Vendordep Soldering Specifications Specifications CAN Bus requirements Competitor Performance Comparison Units tested Setup Results Yaw No-Motion Stability Yaw Motion Stability Shock Stability Yaw Sensitivity LED Codes Known Issues Long Settling Time for Pitch and Roll Solution Pitch and Roll Sensitivity Solution Programming Your Canandgyro Programming Overview Constructor Calibration Check Heading Party Mode Presence Detection Temperature Reset To Factory Default Calibration Overview Canandgyro Settings Creation Writing Settings To The Canandgyro Fetching Settings From Device Yaw Frame Period Angular Position Frame Period Angular Velocity Frame Period Acceleration Frame Period Status Frame Period Boron Canandgyro Faults Fetching Faults Types Of Faults Power Cycle CAN ID Conflict CAN General Error Out Of Temperature Range Hardware Fault Calibrating Angular Velocity Saturation Acceleration Saturation Usage in FTC Case considerations Wiring Mounting Robot configuration Programming the Analog Canandgyro Field-centric teleop",
      "content_preview": "Boron Canandgyro Overview # Getting Started Overview Gyro Axes Mounting Wiring Calibration Configuring Vendordep Soldering Specifications Specifications CAN Bus requirements Competitor Performance Comparison Units tested Setup Results Yaw No-Motion Stability Yaw Motion Stability Shock Stability Yaw..."
    },
    {
      "url": "https://docs.reduxrobotics.com/canandgyro/getting-started.html",
      "title": "Getting Started",
      "section": "Canandgyro",
      "language": "All",
      "content": "Getting Started # The Boron Canandgyro is a powerful, precise Inertial Measurement Unit (IMU) designed for competitive robotics. The Boron rapidly filters and fuses the rate of rotation and acceleration to form a reading for the heading of the robot in 6 axes. The result is reported over CANbus for easy integration into any robot. Overview # Ultra-low no-motion drift of 0.2 degrees per hour Low in-motion drift of 0.25 degrees per minute Low profile and compact design Large solder pads and terminal blocks for easy power and CAN connections Wide input voltage range (4.3v ~ 16v) Low CAN bus utilization by default (2.2%) with 100Hz default Yaw update rate Gyro Axes # The Boron has a set of 3 axis printed on top of the case, showing the axes of the accelerometer. Yaw is always defined as the rotation around the gravity vector. This means that if the gyro is mounted sideways, Yaw will still be the heading of the robot. Pitch and roll are calculated from the fusion of accelerometer data and gyro data. Note that mounting the Boron so that its Z axis points to the sky is the recommended usage due to tuning optimizations. Mounting # The Boron is optimized for the most precise performance in its Z axis. As a result, the gyro should be mounted such that its Z axis points towards the sky. The best place to mount the Boron is in the XY center of your robot, as mounting it closer to the edges of the chassis can cause unwanted accelerations that impact the accuracy of the gyro during robot rotation. Though not recommended, the Boron can be mounted to a rotating arm for resolving the orientation, either for zeroing an encoder or for direct control. In this use case, the Boron should be mounted so that Z axis is parallel to the rotation axis of the arm. Please note that, when the X axis points to the sky, you can quickly run into a case of gimbal lock . As a result, the Yaw will report incorrectly. If you are using the Boron sideays, do not use the Yaw Euler angle, only pitch and roll. The rotation quaternion will still work correctly. Wiring # The Boron accepts 4.2-16v via the screwless terminal block or solderpads. The CAN terminals should be wired to the RoboRIO CANbus. The Boron communicates using CAN 2.0B and does not support CAN-FD. Calibration # On boot, the Boron LED will turn yellow as it calibrates. The gyro is still usable in this state, but accuracy will be reduced until the Boron is given time to calibrate. Once the gyro has been left unmoving for a few seconds, the LED will turn green to indicate that it is fully operational and has CAN communication. If the LED turns red, that indicates that it cannot sense an active CANbus. Check your wiring if needed. The Boron can operate from boot without calibration, but it will operate with reduced accuracy. See Specifications for more details. Configuring # The Boron can be configured from the Alchemist Configuration Tool . In addition, Alchemist can be used to zero the gyro, manage status frame periods, and update the device firmware. Tip If you are unsure what a setting field does, hover over it. This will show a helpful tooltip about its function. Vendordep # Accessing the device is only possible via CAN. As such, ReduxLib needs to be installed. ReduxLib Boron Java API reference ReduxLib Boron C++ API reference",
      "content_preview": "Getting Started # The Boron Canandgyro is a powerful, precise Inertial Measurement Unit (IMU) designed for competitive robotics. The Boron rapidly filters and fuses the rate of rotation and acceleration to form a reading for the heading of the robot in 6 axes."
    },
    {
      "url": "https://docs.reduxrobotics.com/canandgyro/programming/calibrating.html",
      "title": "Calibration",
      "section": "Canandgyro",
      "language": "All",
      "content": "Calibration # Overview # It is sometimes useful to programmatically trigger calibration of the Canandgyro. Calibration must be done while the device remains still. The following code excerpt shows how to utilize the calibration system. Java // Creates a Canandgyro object referencing a Canandgyro with CAN ID 0 Canandgyro canandgyro = new Canandgyro ( 0 ); //Starts calibrating the gyroscope asynchronously canandgyro . startCalibration (); // Block the thread until calibration has finished, or until 7 seconds // have passed. // We recommend waiting at least 7 seconds for the calibration routine. // Because of this long wait, we recommend you do not do this // on a main thread. canandgyro . waitForCalibrationToFinish ( 7 ); //Alternatively, use isCalibrating to detect calibration asynchronously if ( canandgyro . isCalibrating ()) { // Run code if device is calibrating } else { // Run code if device is not calibrating } C++ // Creates a Canandgyro object referencing a Canandgyro with CAN ID 0 Canandgyro canandgyro { 0 }; //Starts calibrating the gyroscope asynchronously canandgyro . StartCalibration (); // Block the thread until calibration has finished, or until 7 seconds // have passed. // We recommend waiting at least 7 seconds for the calibration routine. // Because of this long wait, we recommend you do not do this // on a main thread. canandgyro . WaitForCalibrationToFinish ( 7 _s ); //Alternatively, use isCalibrating to detect calibration asynchronously if ( canandgyro . IsCalibrating ()) { // Run code if device is calibrating } else { // Run code if device is not calibrating }",
      "content_preview": "Calibration # Overview # It is sometimes useful to programmatically trigger calibration of the Canandgyro. Calibration must be done while the device remains still. The following code excerpt shows how to utilize the calibration system."
    },
    {
      "url": "https://docs.reduxrobotics.com/canandcolor/led-codes.html",
      "title": "LED Codes",
      "section": "Canandcolor",
      "language": "All",
      "content": "LED Codes # The Canandcolor features an LED for easy status identification. Color Description Slow Blink Green Normal operation, roboRIO detected on CAN bus Slow Blink Red roboRIO not detected or other CANbus faults Blinking Blue DFU in progress Solid Blue DFU failed, check Alchemist Alternating Red and Yellow Hardware fault Alternating Red and Blue CAN ID conflict",
      "content_preview": "LED Codes # The Canandcolor features an LED for easy status identification. Color Description Slow Blink Green Normal operation, roboRIO detected on CAN bus Slow Blink Red roboRIO not detected or other CANbus faults Blinking Blue DFU in progress Solid Blue DFU failed, check Alchemist Alternating..."
    },
    {
      "url": "https://docs.reduxrobotics.com/canandcolor/alchemist-guide.html",
      "title": "Canandcolor Alchemist Guide",
      "section": "Canandcolor",
      "language": "All",
      "content": "Canandcolor Alchemist Guide # The Canandcolor can be configured from the Alchemist Configuration Tool , which provides an easy to use UI for configuring the sensor. Overview # Once connected, the canandcolor can be selected from the list of devices. In addition to general device options, like blinking the LED and changing the CAN ID, there are other settings that can be adjusted. Sensor Card # The sensor card contains information about the onboard sensors on the Canandcolor. Note The sensor card displays fault information as a series of colored icons. You can mouse over the icons for more information about the specific faults. Green: No Observed Fault Yellow: Sticky Fault (Fault occured in the past, but not currently) Red: Active Fault Below the faults are the sensor outputs. Color outputs can be toggled between RGB (Red Green Blue) and HSV (Hue Saturation Value) using the toggle at the top of the card. All outputs display the current value, the minimum value that has been observed, and the maximum value that has been observed. These minimum and maximum values are useful for creating thresholds, and can be cleared using the Clear Min/Max button. In addition, a color display output is shown on the right of the card. Since the sensor is commonly used in situations where the true color output is dark, a Normalize Color Display option allows the color display magnitude to be normalized, so that the color output will show a color. Below the color display is the Digital Output statuses. True indicates that the output is HIGH, false indicates that the output is LOW. Setting Card # The setting card contains all of the device specific settings in the canandcolor. For the canandcolor, this is made up of 4 tabs. Frames # The frame tab lets you set the transmission rate of each of the sensor’s CAN frames in milliseconds. The color and proximity frames can optionally be aligned to the integration period of the sensor itself, so that the sensor automatically emits new packets when data is sampled from the underlying sensor. Warning Setting frame periods to 0 will disable them. This is true even if Align To Distance Integration Period is selected. Digital Output # There are two digital output setting tabs corresponding to the two digital output lines from the sensor. The layout of both are identical, except for Digout 2 which allows setting to “PWM” mode with a selector for which channel is transmitted over PWM. The minimum and maximum value of each input can be adjusted via the slider or number input boxes. The digital output will become True when all of the conditions within the sliders are met. In addition, the minimum amount of time in milliseconds that the conditions must be true in order for the digital output to be true can be set. This can be useful for “de-bouncing”, preventing the condition from being set to true if the conditions are only met for a brief amount of time. Important In HSV mode, there is an additional toggle to let you invert the condition of the hue slider. This is useful, as red objects can either show up as either a very high or very low hue value. When invert hue is selected, the digital output condition will resolve to true if the hue is greater then the maximum OR less then the minimum. Sensor Settings # The sensor settings tab lets you set the onboard LED brightness, the proximity sensor integration period, and the color sensor integration period.",
      "content_preview": "Canandcolor Alchemist Guide # The Canandcolor can be configured from the Alchemist Configuration Tool , which provides an easy to use UI for configuring the sensor. Overview # Once connected, the canandcolor can be selected from the list of devices."
    },
    {
      "url": "https://docs.reduxrobotics.com/canandgyro/usage-in-ftc.html",
      "title": "Usage in FTC",
      "section": "Canandgyro",
      "language": "All",
      "content": "Usage in FTC # The Boron Canandgyro is primarily targeted at FRC use-cases, but also provides an analog output port suitable for use in FIRST Tech Challenge applications. This analog port allows for a high-accuracy yaw reading to be bulk-read by the Rev Control or Expansion Hubs without the performance considerations of I2C interfaces, and offers both greater performance and reliability than the Control Hub’s built-in IMU. And, of course, it has robust ESD protection. Case considerations # The case that ships with the Boron does not expose the JST-PH port intended for use with the FTC control system. You will need to remove the Boron from this case by unscrewing the holding screws from the bottom of the case. We highly recommend you 3D print a new case to protect the device from foreign debris and to cover up the FRC-oriented push terminals that may not be relevant to your use case. One case is available here on Printables, featuring M4 mounting holes on a 32mm grid. Wiring # The Boron Canandgyro JST-PH port follows the Rev Control/Expansion Hub standard wiring pinout and can be wired directly into an analog port on a Control or Expansion Hub. This is sufficient to provide both power and signal to the device. If plugged into analog port 0-1, the yaw output will be sent to port 0 with port 1 left as not-connected. If plugged into analog port 2-3, the yaw output will be sent to port 2. We recommend you wire the Boron to the Control Hub specifically so it can be bulk-read with the least amount of latency. Mounting # See the Mounting section in Getting Started Robot configuration # To use an analog input, in the robot configuration menu in either the driver station or the robot controller app, navigate to the Control/Expansion Hub the Boron is plugged into, select Analog Input Devices , and then configure the port it is plugged into as an Analog Input . Programming the Analog Canandgyro # The Boron will output analog voltages between 0 volts and 3.3 volts. This voltage can be treated as linear from software; inherent analog nonlinearity may contribute up to approximately ~0.5 degrees of error. The gyro will boot to output 1.65 volts (0 degrees). Voltage increases in the positive yaw (Z-axis) rotation direction and decreases in the negative yaw direction, wrapping around at the 3.3 volt and 0 volt boundaries. In typical operation, you will want to read and store the current voltage as a “zero offset” during init to compensate for any drift that may accumulate during field setup, and subtract that from the current voltage output, with some additional logic to “wrap” the value to within one rotation. Below is an example with the Boron configured in the robot configuration as an Analog Input named canandgyro : Java @TeleOp ( name = \"Boron Canandgyro Analog Input Demo\" , group = \"Sensor\" ) public class ReduxBoronAnalogInput extends LinearOpMode { // We use an analog input for this exercise. AnalogInput canandgyro ; // Hardware Device Object double zeroPoint = 0 ; // the zero point @Override public void runOpMode () { // get a reference to our canandgyro canandgyro = hardwareMap . get ( AnalogInput . class , \"canandgyro\" ); // Updates the zero point right as the opmode starts and before the robot // may move. // This is recommended at the start of every opmode to clear the effect // of any drift or shift in robot pose accumulated from before-match // setup. zeroPoint = canandgyro . getVoltage (); // wait for the start button to be pressed. waitForStart (); // while the OpMode is active, loop and read the yaw angle. while ( opModeIsActive ()) { // Take the current voltage and subtract off the zero point to get // the \"voltage\" // We then do a conversion from voltage (0 to 3.3) to degrees (0 to 360) // and finally wrap the angle between -180 to 180 degrees using // the AngleUnit.normalizeDegrees method. double angle = AngleUnit . normalizeDegrees ( ( canandgyro . getVoltage () - zeroPoint ) * 360.0 / 3.3 ); // send the info back to driver station using telemetry function. telemetry . addData ( \"Yaw (degrees)\" , angle ); telemetry . update (); } } } Blocks Blocks file download Actual implementation will vary from codebase to codebase (and ideally you will want to integrate bulk reads ) but this hopefully demonstrates the general principles. Field-centric teleop # Field-centric teleop lets your robot move relative to the frame of the field rather than relative to itself. In practice this means when you press forward on the joystick your robot can move straight away from you and when you press back the robot can move towards you regardless of its heading. For information on this, refer to the well-written Game Manual Zero mecanum tutorial. Keep in mind you will need to convert the yaw reading to radians instead of degrees in the above example.",
      "content_preview": "Usage in FTC # The Boron Canandgyro is primarily targeted at FRC use-cases, but also provides an analog output port suitable for use in FIRST Tech Challenge applications."
    },
    {
      "url": "https://docs.reduxrobotics.com/canandgyro/programming/index.html",
      "title": "Programming Your Canandgyro",
      "section": "Canandgyro",
      "language": "All",
      "content": "Programming Your Canandgyro # Programming Overview Constructor Calibration Check Heading Party Mode Presence Detection Temperature Reset To Factory Default Calibration Overview Canandgyro Settings Creation Writing Settings To The Canandgyro Fetching Settings From Device Yaw Frame Period Angular Position Frame Period Angular Velocity Frame Period Acceleration Frame Period Status Frame Period Boron Canandgyro Faults Fetching Faults Types Of Faults Power Cycle CAN ID Conflict CAN General Error Out Of Temperature Range Hardware Fault Calibrating Angular Velocity Saturation Acceleration Saturation",
      "content_preview": "Programming Your Canandgyro # Programming Overview Constructor Calibration Check Heading Party Mode Presence Detection Temperature Reset To Factory Default Calibration Overview Canandgyro Settings Creation Writing Settings To The Canandgyro Fetching Settings From Device Yaw Frame Period Angular..."
    },
    {
      "url": "https://docs.reduxrobotics.com/canandgyro/programming/settings.html",
      "title": "Canandgyro Settings",
      "section": "Canandgyro",
      "language": "C++",
      "content": "Canandgyro Settings # The CanandgyroSettings object is used to reconfigure the Canandgyro. Creation # Java // Create with no values // Only values that are changed will be updated on the device CanandgyroSettings settings = new CanandgyroSettings (); // Make a copy of an existing CanandgyroSettings object. CanandgyroSettings copiedSettings = new CanandgyroSettings ( settings ); C++ // Create with no values // Only values that are changed will be updated on the device CanandgyroSettings settings {} // Make a copy of an existing CanandgyroSettings object. CanandgyroSettings copiedSettings { settings }; Values are fetched and updated using the getters and setters of the object. Important Only values updated by the user are changed on the device. Values that are not changed will remain untouched. Writing Settings To The Canandgyro # When you are ready to send and save the settings to the device, you can use Canandgyro.setSettings to transmit the contents of a CanandgyroSettings object to the Canandgyro. Java // A Canandgyro object with CAN ID 0 Canandgyro canandgyro = new Canandgyro ( 0 ); // Create a new settings object and add a value to set CanandgyroSettings settings = new CanandgyroSettings (); // set frame period to 20ms settings . setAngularPositionFramePeriod ( 0.02 ); // Write the settings to the Canandcolor with a timeout of 50 milliseconds per setting. // By default the settings will be written to flash -- they will persist on reboots. // If this is not desired, one can use // // settings.setEphemeral(true); // // to flag the settings as ephemeral (and not persist in flash on reboot). canandgyro . setSettings ( settings , 0.050 ); C++ // A Canandgyro object with CAN ID 0 Canandgyro canandgyro { 0 }; // Create a new settings object and add a value to set CanandgyroSettings settings {}; // set frame period to 20ms settings . SetAngularPositionFramePeriod ( 0.02 _s ); // Write the settings to the Canandcolor with a timeout of 50 milliseconds per setting. // By default the settings will be written to flash -- they will persist on reboots. // If this is not desired, one can use // // settings.setEphemeral(true); // // to flag the settings as ephemeral (and not persist in flash on reboot). canandgyro . SetSettings ( settings , 0.050 _s ); Fetching Settings From Device # Settings can be fetched from the end device in both a synchronous and asychronous manner. Due to the synchronous method blocking for 0.15-0.25 seconds, it is recommended to use it only in initialization routines for an autonomous or teleop program. getSettings will return an empty Optional (in Java) or std::nullopt (in C++) if the fetch times out before the device responds. The method allSettingsReceived in the CanandgyroSettings object can be used to determine if all settings have been fetched when working with async settings fetch. In addition, if getSettingsAsync is called after updating a Canandgyro’s settings, it will be populated with the fields that have been echoed by the device in its settings confirmation messages. For example, if the status frame is changed from 1 second to 2 seconds, repeated calls to getSettingsAsync will first returns either -1 in Java or nullopt in c++ for the status frame time, until confirmation that the status frame time has been updated, at which point the field will change to 2 seconds (the value set before). Synchronous (blocking) Java // A Canandgyro object with CAN ID 0 Canandgyro canandgyro = new Canandgyro ( 0 ); // Fetch this Canandgyro's settings. // This runs with a default timeout of 0.35 seconds. CanandgyroSettings settings = canandgyro . getSettings (); // Fetch this Canandgyro's settings. // This runs with a timeout of 0.5 seconds CanandgyroSettings settings = canandgyro . getSettings ( 0.5 ); // Fetch the status frame period from the received settings // This will be either a double (seconds) or null if the status frame period // was not successully received. if ( settings . getStatusFramePeriod (). isPresent ()) { System . out . printf ( \"Status frame period: %d\\n\" , settings . getStatusFramePeriod ()); } else { System . out . println ( \"getStatusFramePeriod failed to fetch :/\" ); } C++ using namespace redux :: sensors :: canandcolor ; // A Canandgyro object with CAN ID 0 Canandgyro canandgyro { 0 }; // Fetch this Canandgyro's settings // This runs with a default timeout of 0.35 seconds CanandgyroSettings stg = canandgyro . GetSettings (); // Fetch this Canandgyro's settings // This runs with a timeout of 0.5 seconds CanandgyroSettings stg = canandgyro . GetSettings ( 0.5 _s ); // Fetch the status frame period from the received settings // This will be either a units::seconds_t or std::nullopt if the status frame period // was not successully received. if ( settings . GetStatusFramePeriod ()) { fmt :: print ( \"Status frame period: {} \\n \" , settings . GetStatusFramePeriod ()); } else { fmt :: print ( \"GetStatusFramePeriod failed to fetch :/\" ); } Asynchronous (non-blocking) Java // A Canandgyro object with CAN ID 0 Canandgyro canandgyro = new Canandgyro ( 0 ); // Start the settings fetch canandgyro . startFetchSettings (); // ...spend some period of time waiting for settings... CanandgyroSettings settings = canandgyro . getSettingsAsync (); if ( settings . allSettingsReceived ()) { // We now know all settings have been received // ...do things with the settings object here... } C++ using namespace redux :: sensors :: Canandgyro ; // A Canandgyro object with CAN ID 0 Canandgyro canandgyro { 0 }; // Start the settings fetch canandgyro . StartFetchSettings (); //...spend some period of time waiting for settings... CanandgyroSettings settings = canandgyro . GetSettingsAsync (); if ( settings . AllSettingsReceived ()) { // We now know all settings have been received // ...do things with the settings object here... } Yaw Frame Period # The yaw frame period is the time between yaw pockets being sent by the Boron Canandgyro over the CAN Bus. By default, this value is 0.010 seconds, meaning a yaw packet is sent every 10 milliseconds (for a total of 100 times a second). Lower values will mean packets get sent more frequently, but will correspondingly increase CAN bus utilization. This value can be set to 0, which disables the yaw output. The maximum value of this value is 65.535 seconds (65535 milliseconds). This value is set with a resolution of 0.001 seconds (1 millisecond). Default value : 0.010 seconds Minimum value : 0 seconds (disables yaw output) Maximum value : 65.535 seconds FIRST® Robotics Competition The CAN 2.0B bus in the FIRST® Robotics Competition operates at a rate of 1 Mbit/s, or 125000 bytes per second. To estimate CAN usage, you can multiply the size of the CAN packet by its send frequency in hertz, and divide that by 125000. CAN packets have 8 bytes of overhead. For example, a yaw packet is 6 bytes of data, so the full packet is 14 bytes. At 0.010 seconds, or 100 times a second, this takes up 1400 / 125000 or 1.12% of the CAN bus. Angular Position Frame Period # The angular frame period is the time between angular pockets being sent by the Boron Canandgyro over the CAN Bus. This contains the quaternion of its orientation. By default, this value is 0.020 seconds, meaning a angular position packet is sent every 20 milliseconds (for a total of 50 times a second). Lower values will mean packets get sent more frequently, but will correspondingly increase CAN bus utilization. This value can be set to 0, which disables this frame. The maximum value of this value is 65.535 seconds (65535 milliseconds). This value is set with a resolution of 0.001 seconds (1 millisecond). Default value : 0.020 seconds Minimum value : 0 seconds (disables the frame) Maximum value : 65.535 seconds Angular Velocity Frame Period # The angular frame period is the time between angular velocity frames being sent by the Boron Canandgyro over the CAN Bus. By default, this value is 0.10 seconds, meaning a angular velocity packet is sent every 100 milliseconds (for a total of 10 times a second). Lower values will mean packets get sent more frequently, but will correspondingly increase CAN bus utilization. This value can be set to 0, which disables this frame. The maximum value of this value is 65.535 seconds (65535 milliseconds). This value is set with a resolution of 0.001 seconds (1 millisecond). Default value : 0.10 seconds Minimum value : 0 seconds (disables the frame) Maximum value : 65.535 seconds Acceleration Frame Period # The angular frame period is the time between acceleration frames being sent by the Boron Canandgyro over the CAN Bus. By default, this value is 0.10 seconds, meaning a acceleration packet is sent every 100 milliseconds (for a total of 10 times a second). Lower values will mean packets get sent more frequently, but will correspondingly increase CAN bus utilization. This value can be set to 0, which disables this frame. The maximum value of this value is 65.535 seconds (65535 milliseconds). This value is set with a resolution of 0.001 seconds (1 millisecond). Default value : 0.10 seconds Minimum value : 0 seconds (disables the frame) Maximum value : 65.535 seconds Status Frame Period # The status frame period is the time between status pockets being sent by the Boron Canandgyro over the CAN Bus. By default, this value is 0.1 seconds, meaning a status packet is sent every 100 milliseconds. Lower values will mean packets get sent more frequently, but will correspondingly increase CAN bus utilization. This value cannot be set to zero or disabled. The maximum value of this value is 16.383 seconds (16383 milliseconds). This value is set with a resolution of 0.001 seconds (1 millisecond). Default value : 0.1 seconds Minimum value : 0.001 seconds Maximum value : 16.383 seconds",
      "content_preview": "Canandgyro Settings # The CanandgyroSettings object is used to reconfigure the Canandgyro. Creation # Java // Create with no values // Only values that are changed will be updated on the device CanandgyroSettings settings = new CanandgyroSettings (); // Make a copy of an existing CanandgyroSettings..."
    },
    {
      "url": "https://docs.reduxrobotics.com/canandcolor/how-it-works.html",
      "title": "How does Canandcolor work?",
      "section": "Canandcolor",
      "language": "All",
      "content": "How does Canandcolor work? # The Canandcolor contains two distinct sensors onboard: A IR Proximity sensor and a color sensor. These both work on similar principles, sending the intensity of reflected light, but operate in different wavelengths. IR Proximity # The onboard IR Proximity sensor works by pulsing an IR LED out and measuring the intensity of reflected IR light. This gives a value proportional to proximity, as farther away objects will reflect less IR back to the sensor. If an object is too far away, not enough IR light reflects back to the sensor for it to read, and if an object is too close then too much light can reflect back, leading to oversaturation. In practice, the sensor oversaturates only at ranges under 2mm. The sensor has a controllable integration time, which is the amount of time that it collects IR light in order to determine the object’s range. Lower integration times will run at a faster rate, but will also have slightly more noise and less range. The Canandcolor supports integration times from 5ms to 40ms, which means your minimum latency is only 5ms (200Hz). Color Sensor # The color sensor works by measuring the intensity of different reflected wavelengths of light. Unlike the IR sensor, this does not emit its own light automatically, but rather lets the user control a built-in LED to provide consistent illumination to the target. The sensor has an integration time as well, similar to the exposure time in a camera. The longer the integration time, the more precise the color readings are, and the better it will perform at range. However, for almost all applications, the default integration time of 25 ms is sufficient. Objects’ colors can be sensed up to 100mm (4”) away easily by using the HSV (Hue, Saturation, Value) color detection mode. It can even work from further distances depending on ambient conditions.",
      "content_preview": "How does Canandcolor work? # The Canandcolor contains two distinct sensors onboard: A IR Proximity sensor and a color sensor. These both work on similar principles, sending the intensity of reflected light, but operate in different wavelengths."
    },
    {
      "url": "https://docs.reduxrobotics.com/canandcolor/programming/normal-operation.html",
      "title": "Programming Overview",
      "section": "Canandcolor",
      "language": "C++",
      "content": "Programming Overview # The central point of the Canandcolor in ReduxLib is the Canandcolor object. The Canandcolor object lets you read the detected color, meausred proximity proximity, set and read settings, read faults, and more. Constructor # Creating a Canandcolor object is simple. The one parameter you need is the CAN device ID assigned to the sensor, generally configured by Alchemist. Java // Creates a Canandcolor object referencing a Canandcolor with CAN ID 0 Canandcolor canandcolor = new Canandcolor ( 0 ); // Creates a Canandcolor object referencing a Canandcolor with CAN ID 3 Canandcolor canandcolor3 = new Canandcolor ( 3 ); C++ using namespace redux :: sensors :: canandcolor ; // Creates a Canandcolor object referencing a Canandcolor with CAN ID 0 Canandcolor canandcolor { 0 }; // Creates a Canandcolor object referencing a Canandcolor with CAN ID 3 Canandcolor canandcolor3 { 3 }; Reading Proximity # Proximity in the Canandcolor is represented as a value in the range [0, 1] which decreases as the sensed object approaches the sensor. This represents the intensity of reflected IR to the sensor, and will saturate to 1 if an object is too close to the sensor. Why is proximity unitless? The returned proximity value depends on the material as the reflectivity of IR will change how proximity relates to proximity. This is because proximity is proportional to reflected IR light intensity, rather than proximity directly. It is intended that users measure the proximity value in conditions they are going to use the sensor in, and then hard-code thresholds relevant to their application. Java double proximity = canandcolor . getProximity (); C++ double proximity = canandcolor . GetProximity (); Reading Color # Color in the Canandcolor is represented as individual values in the range [0, 1] which represents the intensity of that channel of color. For example, a pure red light will have a red color value close to 1, and blue/green color values close to 0. In addition, ColorData contains helper functions to convert the sensed color to HSV, and to WPILib Color objects. For most applications, users will want to use the HSV functions instead of RGB, as HSV is much easier to tune and senses color more independent of ambient conditions and brightness. Java //Get the raw RGB values from the sensor double red = canandcolor . getRed (); double blue = canandcolor . getBlue (); double green = canandcolor . getGreen (); //Get the HSV readings from the color object double hue = canandcolor . getHSVHue (); double saturation = canandcolor . getHSVSaturation (); double value = canandcolor . getHSVValue (); //Get a Canandcolor ColorData object from the sensor ColorData color = canandcolor . getColor (); //Convert the color to a WPILib color instance Color wpiColor = color . toWpilibColor (); C++ Presence Detection # Presence Detection checks if the sensor has sent a message in the last 2 seconds (by default). This is a useful tool to ensure that the sensor has not disconnected from the CAN bus. ReduxLib will also automatically warn the driver station of possibly disconnected devices. Java canandcolor . isConnected (); C++ canandcolor . IsConnected (); Temperature # The temperature function reports the onboard temperature reading of the device. This should be kept within -5 and 45 degrees Celsius for normal operation. Java canandcolor . getTemperature (); C++ canandcolor . GetTemperature (); Reset To Factory Default # Danger Resetting the sensor to factory default will wipe all settings. There is no way to undo this other then manually re-inputting all of your settings. Resets the sensor to factory defaults. CAN device IDs are preserved. Java canandcolor . resetFactoryDefaults (); C++ canandcolor . ResetFactoryDefaults ();",
      "content_preview": "Programming Overview # The central point of the Canandcolor in ReduxLib is the Canandcolor object. The Canandcolor object lets you read the detected color, meausred proximity proximity, set and read settings, read faults, and more. Constructor # Creating a Canandcolor object is simple."
    },
    {
      "url": "https://docs.reduxrobotics.com/canandgyro/known-issues.html",
      "title": "Known Issues",
      "section": "Canandgyro",
      "language": "All",
      "content": "Known Issues # The Boron Canandgyro was optimized for performance in the FIRST Robotics Competition. As a result, it has some bugs that may express themselves in other applications. Long Settling Time for Pitch and Roll # In some cases, Pitch and Roll can take a long time to settle. Typical behavior settles the Pitch and Roll to 0.1 degree of the final value in under 20 seconds after zeroing pose. However, in situations where pitch and roll are very small, it can take up to 60 seconds to settle within 0.1 degree. Solution # Re-calibrate the gyro from user code or Alchemist to force the gyro to redefine pitch and roll. Avoid zeroing pitch and roll from user code in most circumstances. Pitch and Roll Sensitivity # While the yaw axis is precisely calibrated and can support many continuous rotations without added drift, the pitch and roll axes are not. Continuous rotations in the pitch and roll axes will cause a buildup in pose error. Solution # Most applications will not see multiple rotations in pitch and roll. For those that do, use the Calibrate button in Alchemist or call startCalibration() from user code to force the gyro to refine the Pitch and Roll using the accelerometer more quickly. Alternatively, allow the gyro to rest for several seconds to let sensor fusion fix the pose.",
      "content_preview": "Known Issues # The Boron Canandgyro was optimized for performance in the FIRST Robotics Competition. As a result, it has some bugs that may express themselves in other applications. Long Settling Time for Pitch and Roll # In some cases, Pitch and Roll can take a long time to settle."
    },
    {
      "url": "https://docs.reduxrobotics.com/canandgyro/led-codes.html",
      "title": "LED Codes",
      "section": "Canandgyro",
      "language": "All",
      "content": "LED Codes # The Boron Canandgyro features an LED for easy status identification. Color Description Slow Blink Green Normal operation, roboRIO detected on CAN bus Slow Blink Red roboRIO not detected or other CANbus faults Solid Yellow Calibrating, operational with reduced accuracy Blinking Blue DFU in progress Solid Blue DFU failed, check Alchemist Alternating Red and Yellow Hardware fault Alternating Red and Blue CAN ID conflict",
      "content_preview": "LED Codes # The Boron Canandgyro features an LED for easy status identification. Color Description Slow Blink Green Normal operation, roboRIO detected on CAN bus Slow Blink Red roboRIO not detected or other CANbus faults Solid Yellow Calibrating, operational with reduced accuracy Blinking Blue DFU..."
    },
    {
      "url": "https://docs.reduxrobotics.com/canandcolor/electrical-specs.html",
      "title": "Performance Specifications",
      "section": "Canandcolor",
      "language": "All",
      "content": "Performance Specifications # General Specifications # Parameter Min Typ. Max Units Input Voltage 4.5 – 18 V Current Draw @ 5V – 42 110 mA Current Draw @ 12V – 30 105 mA Logic Level – 3.3 – V Ambient Temperature -5 – 45 °C Ranging Distance @ 5ms 0.2 – 12 cm Ranging Distance @ 10ms 0.2 – 14 cm Ranging Distance @ 20ms 0.2 – 18 cm Ranging Distance @ 40ms 0.3 – 24 cm Color Sense Range 0.3 – 10 cm Note Maximum ranging distance is dependent on material and lighting conditions. Maximum current draw measured with LED at 100% brightness.",
      "content_preview": "Performance Specifications # General Specifications # Parameter Min Typ. Max Units Input Voltage 4.5 – 18 V Current Draw @ 5V – 42 110 mA Current Draw @ 12V – 30 105 mA Logic Level – 3.3 – V Ambient Temperature -5 – 45 °C Ranging Distance @ 5ms 0.2 – 12 cm Ranging Distance @ 10ms 0.2 – 14 cm..."
    },
    {
      "url": "https://docs.reduxrobotics.com/reduxlib/",
      "title": "ReduxLib Docs and Installation",
      "section": "ReduxLib",
      "language": "C++",
      "content": "ReduxLib Docs and Installation # The current version of ReduxLib is 2025.0.0 . Current Java/C++ documentation # Java docs C++ docs LabVIEW is not supported at this time. Vendordep installation # Tip For more detailed information, see WPILib’s documentation on 3rd party libraries Online installation # In your robot project in WPILib VSCode, press Ctrl+Shift+P and select WPILib: Manage Vendor Libraries . When prompted for a JSON url, paste in https://frcsdk.reduxrobotics.com/ReduxLib_2025.json Offline installation # Download the current offline zip and extract its contents to either C:\\Users\\Public\\wpilib\\2025 on Windows or ~/wpilib/2025 on Linux/MacOS In your robot project in WPILib VSCode, press Ctrl+Shift+P and select WPILib: Manage Vendor Libraries . Select Install new libraries (offline) and then select ReduxLib Changelog # 2025.0.0 # Jan 5, 2024 Release for the 2025 season. 2025.0.0-beta2 # December 18, 2024 Adds Canandcolor 2025.0.0-beta0 # November 3, 2024 This release is identical to v2024.3.2 with the patches required to build against WPILib v2025.1.1-beta1. It should function identically but breakage may still happen (this is a beta after all); use at your own risk. 2024.3.2 # November 3, 2024 This release adds support for WPILib struct serialization for a few classes. New Features # [Java/C++] wpistruct support for Canandgyro and Canandmag status and faults classes C++ also gets support for angular velocity and acceleration data classes [Java/C++] New getStatus allows for fetching of Canandgyro.Status and Canandmag.Status objects directly [Java] faultBitfield() method for faults classes, for those who prefer bit flags [Java] Javadoc syntax highlighting and quality improvements Bug fixes # [Java] Add getStatusFrame() for Canandgyro and Canandmag Known issues # The current 2024 and 2025 beta release of Glass and other utilities do not unpack nested wpistruct schemas correctly. This is expected to be fixed soon. 2024.3.1 # October 18, 2024 We are proud to present the first release with Canandgyro support. This requires WPILib version 2024.3.2. If you have compilation issues with C++, make sure to update WPILib in your robot project! This is also paired with a new v2024.2.0 firmware release for Canandmags being used over CAN. You must update your Canandmag to v2024.2.0 for it to work properly with this vendordep! New Features # [Java/C++] add Canandgyro support [Driver] Support for a new, faster OTA algorithm [Java] Added Frame.hasData() as part of the abstract Frame class definition Breaking API changes # [Java/C++] Slight change to definition of CAN id layout; does not affect existing products [Java/C++] Reduce default settings timeouts to 20 ms across the board [Java] Frame callbacks now call on the Frame object itself rather than the FrameData as the argument, allowing for code that avoids pressuring GC [Java] Settings objects now return java.util.Optional instead of null on the getters, as NPEs on settings fetch is undesirable behavior [Java] CanandDeviceDetails uses a different set of autogenerated definitions Bug fixes # [Java] Fix AdvantageKit messing with Timer.getFPGATimestamp() [Java/C++] Fix settings operations timing out when they shouldn’t [Java/C++] Fix isConnected() functionality [Java] Fix Frame.removeCallback adding the callback instead [Java] Tweaks across the board to reduce object allocation [Driver] Fix Windows MSVC support We would like to thank everyone who reported these bugs. 2024.2.0 # June 5, 2024 Notable Breaking Changes # [Java/C++] Branding updates; Canandcoder renamed to Canandmag Bug fixes # [Driver] Increase robustness to HAL_CAN_OpenStreamSession not succeeding immidiately 2024.1.2 # February 19, 2024 Bugfixes # [Java] Fix an NPE in the firmware version checker 2024.1.1 # January 11, 2024 Notable Breaking Changes # Canandcoder.getSettings() and Canandcolor.getSettings() no longer return null/nullopt! They will always return a Settings object with the set of settings received. To check if all settings have been received, use allSettingsReceived (e.g. Canandcoder.Settings.allSettingsReceived()) Many settings, faults and status classes are now inner classes of their associated object in Java only. Basically, one writes Canandcoder.Settings instead of CanandcoderSettings. Canandcoder.isPresent and Canandcolor.isPresent have been renamed to isConnected and moved to CanandDevice (for consistency with WPILib’s similar function) [Java] New overloads for .getSettings() and .setSettings() have been added to acccomodate retries. [C++] GetSettings() and SetSettings have had their original function signatures have been changed, in particular the return type of .SetSettings(). The vendordep now sends 8-byte settings sets. Canandcoders with firmwares older than v2024.1.0 will need a firwmare update for settings to work correctly. – This is especially important for the original pre-October run (green Canandcoders), as settings will not set at all for their factory-flashed firmware. The Canandcolor API in general had large revisions from the preview in v2023.2.0. New Features # Settings have been overhauled with a focus on reliability. getSettings() and setSettings() for both Canandcoder and Canandcolor now retry failed operations by default, and will (by default) inform the driver station if ReduxLib is not absolutely sure settings have not been written successfully. Ephemeral settings writes are now supported in many places, allowing for changing device configuration without wearing down flash. Introduced firmware version checking on device instantiation, which produces errors on out-of-date firmware. Driver station errors/warnings are also logged for devices with instantiated objects that have been disconnected from the CAN bus. The Canandcolor API has been more or less rewritten from the preview in v2023.2.0, with many functions and classes renamed for clarity. These names are final for the 2024 season. The Canandcoder zero offset is now directly settable with CanandcoderSettings.SetZeroOffset 2023.2.0 # October 14, 2023 Notable Breaking Changes # All instances of “CANand” have been changed to “Canand” for consistency with everything that’s not ReduxLib. Our apologies for the breakage this will cause. Switching current code should be as simple as using the VSCode search and replace to change “CANand” (with Match Case selected) with “Canand” New Features # Canandcolor CAN color/proximity sensor suppport added CAN timestamps now use FPGA time rather than CLOCK_MONOTONIC Linux arm32/arm64 standalone builds are now provided Bug fixes # [Java] Fix hang on sim exit due to unterminated CanandEventLoop [Java] Fix crashes due to mutation of the listener list with CanandEventLoop [Java] Removed heap allocations from handleMessage() updates to reduce GC load [Java] CanandUtils.bytesToLong(byte[] data) now actually works [C++] Fix C++ crash on simulation init due to uninitialized HAL [Java/C++] Blocking settings operations reworked to be thread safe [Java/C++] Use the FPGA timestamp for all timediffs internally (it’s faster than the standard CLOCK_MONOTONIC/System.nanoTime for 2024) [Java/C++] CAN timestamps are now relative to the FPGA timestamp rather than CLOCK_MONOTONIC [Java/C++] Various doc comment fixes API changes # [Java] CAN/Setting/Setting command constants are now in Details -type classes, similar to the details namespace in C++ [Java] Frames have been reworked to avoid heap (de)allocation on update – the base class is abstract and implementing classes are backed by a primitive (or array of primitives) [Java] CanandMessage now has a copy constructor and is mutable to avoid heap allocation [C++] Source files have been internally reorganized – side classes for devices are now distributed in different headers that the main device header imports [C++] Canandcoder::kCountsPerRotation and Canandcoder::kCountsPerRotationPerSecond are now public [Java/C++] Constants are changed to fit the WPILib Hungarian notation [Java/C++] Support for the FETCH_SETTING_VALUE setting command has been added [Java/C++] ReduxCore version is now checked [Core] ReduxCore_WaitForCANMessage now returns an int (-1 means CANLink is exiting) [Core] ReduxCore_GetVersion now exists [Core] ReduxCore_CANMessage has been rearranged to account for 64-bit microsecond-resolution timestamps, and all timestamps are retimed to the FPGA timestamp 2023.1.0 # June 4, 2023 The Canandcoder can now have its on-board zeroing button disabled at runtime via getDisableZeroButton(boolean) and setDisableZeroButton(boolean) Several fields relating to Canandcoder-related constants have been made public rather than protected or private. The faultsValid field for CANandcoderFaults now functions as intended. C++ can now manually start the Redux CANLink server via redux::canand::EnsureCANLinkServer() CANandMessage uses timestamps in seconds now. Various docs typos 2023.0.1 # May 11, 2023 Builds using simulation should run without crashing. Proper simulation support is planned for later this year. 2023.0.0 # May 10, 2023 Initial release.",
      "content_preview": "ReduxLib Docs and Installation # The current version of ReduxLib is 2025.0.0 . Current Java/C++ documentation # Java docs C++ docs LabVIEW is not supported at this time."
    }
  ]
}
