{
  "vendor": "ctre",
  "version": "phoenix6",
  "built_at": "2025-12-04T21:01:31.929659",
  "pages": [
    {
      "url": "https://v6.docs.ctr-electronics.com/en/stable/docs/hardware-reference/talonfx/index.html",
      "title": "Talon FX",
      "section": "TalonFX",
      "language": "All",
      "content": "Talon FX Kraken X60 The Kraken X60 powered by Talon FX is a brushless motor developed by WestCoast Products that uses the latest BLDC motor control technology from CTR Electronics. The integrated Talon FX unlocks the full performance of the Kraken X60 BLDC motor while providing best-in-class motion control. Store Page CAD and purchase instructions. https://store.ctr-electronics.com/products/kraken-x60/ Hardware User Manual Wiring and mount instructions available on the WestCoast Products documentation site. https://docs.wcproducts.com/kraken-x60/ Kraken X44 The Kraken X44 powered by Talon FX is a compact brushless motor developed by WestCoast Products that uses the latest BLDC motor control technology from CTR Electronics. The integrated Talon FX unlocks the full performance of the Kraken X44 BLDC motor while providing best-in-class motion control. Store Page CAD and purchase instructions. https://store.ctr-electronics.com/products/kraken-x44/ Hardware User Manual Wiring and mount instructions available on the WestCoast Products documentation site. https://docs.wcproducts.com/kraken-x44/ Falcon 500 The Falcon 500 powered by Talon FX is a brushless motor with an integrated motor controller and high-resolution encoder, custom designed specifically for the FIRST Robotics Competition, through a collaboration between Cross the Road Electronics and VEX Robotics . Store Page CAD, Firmware and purchase instructions. https://store.ctr-electronics.com/falcon-500-powered-by-talon-fx/ Hardware User Manual Wiring and mount instructions in PDF format. https://ctre.download/files/user-manual/Falcon%20500%20v3%20User’s%20Guide.pdf Utilizing your TalonFX Improving Performance with Current Limits Motor Orientation Talon FX supports Clockwise and Counter Clockwise inverts. Inverts are determined from the perspective of looking at the face of the motor. Counter Clockwise Clockwise Actuator Limits CTR Electronics actuators, such as the Talon FX, support various kinds of hardware and software limits. Note The TalonFX + Kraken X60 does not support hardware limit switches. Instead, control request limit overrides can be used, or a CANcoder can be used as a remote limit switch . Documentation on retrieving and configuring limits can be found here . Limit Switches CTR Electronics supported actuators have limit features that will automatically neutral the actuator output (set voltage to 0) if a limit switch is activated. By default, limits are set to “normally open”. This means that the switch needs to be explicitly closed (or grounded) for the actuator output to be set to neutral. When the limit switch is closed (connected to ground), the actuator will disable and the pattern will move toward the forward/reverse limit pin (red blink pattern will move toward the forward limit pin when the forward limit is closed, and vice-versa). Tip For more information on limit switch wiring in the Falcon 500, consult the Falcon 500 User’s Guide . Status Light Reference Blink Codes Disabled Codes Animation (Click to play) LED State Cause Possible Fix LEDs Off No Power Provide 12V to Red/Black leads. Blinking Alternating Red Talon FX does not have a valid CAN/PWM signal. Ensure good connections between CANH and CANL (Yellow and Green) & robot controller is on. Blinking Alternating Orange TalonFX detects CAN but does not see Phoenix running on the robot controller. If Phoenix is running on the robot controller, ensure good connection between the controller and this device. Otherwise, deploy a robot program that uses Phoenix. Blinking Simultaneous Orange Talon FX has valid CAN signal and is disabled. Phoenix is running in robot controller and Talon FX has good CAN connection to robot controller. If robot is enabled, ensure a control request is being sent to the Talon FX. Enabled Codes Both Solid Orange Talon FX enabled with neutral output. Blinking Simultaneous Red Talon FX driving in reverse. Rate of blink corresponds to duty cycle applied. Blinking Simultaneous Green Talon FX driving forward. Rate of blink corresponds to duty cycle applied. Offset Alternating Red/Off Talon FX limited (hard or soft limit). Direction of offset determines forward/reverse limit. Special Codes Offset Orange/Off Talon FX in thermal cutoff. Allow Talon FX to cool. Consider configuring Stator Current Limits to reduce heat generation. Alternate Red/Green Talon FX driven with Pro-only command while unlicensed. Use non-Pro-only command, or license device for Pro. Alternate Red/Orange Damaged Hardware. Use Tuner X Self Test to confirm the LEDs and that the hardware fault is set, then contact CTRE Single LED alternates Green/Orange Talon FX in bootloader. Field-upgrade device in Tuner X.",
      "content_preview": "Talon FX Kraken X60 The Kraken X60 powered by Talon FX is a brushless motor developed by WestCoast Products that uses the latest BLDC motor control technology from CTR Electronics."
    },
    {
      "url": "https://v6.docs.ctr-electronics.com/en/stable/docs/tuner/tuner-swerve/validating-drivetrain.html",
      "title": "Validating the Drivetrain",
      "section": "Phoenix Tuner X",
      "language": "All",
      "content": "Validating the Drivetrain Tuner performs several validation procedures to confirm inverts, offsets and mechanical functionality of the drivetrain. This test consists of two steps: Verify Steer Verify Drive Verify Steer The Verify Steer test is used to confirm that the module azimuth (or steer) can rotate freely and what direction they rotate in. This test simply rotates all of the modules and confirms with the user if they rotated clockwise or counter-clockwise. The modules should rotate counter-clockwise (looking down at the module). Verify Drive The Verify Drive test is used to determine if the offsets were correctly applied and what the inverts of the drive motors should be. This process is as listed: Rotate the modules until they are at position 0 (the module 0 should be calibrated from the calibration step). Apply ~10% dutycycle. Confirm with the user if the robot would’ve moved forward or backwards. Without placing the robot on the ground, forward can be determined with the following steps. Look at the robot from the right side of the robot. Observe the wheels rotating. If the wheels rotate clockwise , this is forward (for the right side of the robot!). Repeat for the left side of the robot, but instead of clockwise, forward is counter-clockwise . Troubleshooting A couple of common troubleshooting steps are listed below. Q: The left or right-side of the drivetrain rotates in the wrong direction! Note If both sides are rotating in the incorrect direction, simply select No in the prompt that appears at the end of the test. Answer: Go back to the configuration page and reperform CANcoder calibration. Ensure that the bevel gear of the robot is facing toward the vertical center of the robot and that the module is centered (either with a locking pin or ruler). Q: The robot wheels did not move! Answer: Ensure that the robot is enabled in the FRC Driver Station . Q: The robot says the average velocity was too small! Answer: Confirm what direction the wheel is rotating. Same solution as Q: The left or right-side of the drivetrain rotates in the wrong direction! . Q: My motors are stall-whistling Answer: The motors will whistle (or screech) if they have stalled (outputting power, but the motor output shaft can’t move). Verify by hand that the steer and drive motors can turn freely. Q: My robot is spinning or stuttering Answer: Ensure the battery voltage is above 11V. Place the robot on blocks and rerun the steer test. If the modules aren’t aligned the robot forward direction (determined from the device assignment in a previous step), then the robot inverts will not be correct.",
      "content_preview": "Validating the Drivetrain Tuner performs several validation procedures to confirm inverts, offsets and mechanical functionality of the drivetrain. This test consists of two steps: Verify Steer Verify Drive Verify Steer The Verify Steer test is used to confirm that the module azimuth (or steer) can..."
    },
    {
      "url": "https://v6.docs.ctr-electronics.com/en/stable/docs/migration/migration-guide/api-structure-guide.html",
      "title": "API Structure",
      "section": "General",
      "language": "All",
      "content": "API Structure Phoenix 6 uses a separate, simpler set of namespaces and packages from Phoenix 5. Note For more information about the structure of Phoenix 6, see API Overview . v5 Java // Phoenix 5 is in the com.ctre.phoenix.* packages import com.ctre.phoenix.motorcontrol.can.WPI_TalonFX ; import com.ctre.phoenix.motorcontrol.TalonFXConfiguration ; import com.ctre.phoenix.motorcontrol.TalonFXControlMode ; import com.ctre.phoenix.motorcontrol.TalonFXInvertType ; import com.ctre.phoenix.motorcontrol.TalonFXSimCollection ; import com.ctre.phoenix.sensors.CANCoderConfiguration ; import com.ctre.phoenix.sensors.WPI_CANCoder ; // WPI_* for WPILib integration final WPI_TalonFX m_talonFX = new WPI_TalonFX ( 0 ); final WPI_CANCoder m_cancoder = new WPI_CANCoder ( 0 ); final TalonFXSimCollection m_talonFXSim = m_talonFX . getSimCollection (); final TalonFXConfiguration m_talonConfig = new TalonFXConfiguration (); final CANCoderConfiguration m_cancoderConfig = new CANCoderConfiguration (); TalonFXInvertType m_talonFXInverted = TalonFXInvertType . CounterClockwise ; m_talonFX . set ( TalonFXControlMode . PercentOutput , 0 ); C++ // Phoenix 5 is in the ctre/phoenix headers #include \"ctre/phoenix/motorcontrol/can/WPI_TalonFX.h\" #include \"ctre/phoenix/sensors/WPI_CANCoder.h\" // Phoenix 5 uses the ctre::phoenix namespace using namespace ctre :: phoenix ; // WPI_* for WPILib integration motorcontrol :: can :: WPI_TalonFX m_talonFX { 0 }; sensors :: WPI_CANCoder m_cancoder { 0 }; motorcontrol :: TalonFXSimCollection & m_talonFXSim { m_talonFX . GetSimCollection ()}; motorcontrol :: TalonFXConfiguration m_talonConfig {}; sensors :: CANCoderConfiguration m_cancoderConfig {}; motorcontrol :: TalonFXInvertType m_talonFXInverted { motorcontrol :: TalonFXInvertType :: CounterClockwise }; m_talonFX . Set ( motorcontrol :: TalonFXControlMode :: PercentOutput , 0 ); v6 Java // Phoenix 6 is in the com.ctre.phoenix6.* packages import com.ctre.phoenix6.configs.CANcoderConfiguration ; import com.ctre.phoenix6.configs.TalonFXConfiguration ; import com.ctre.phoenix6.controls.DutyCycleOut ; import com.ctre.phoenix6.hardware.CANcoder ; import com.ctre.phoenix6.hardware.TalonFX ; import com.ctre.phoenix6.signals.InvertedValue ; import com.ctre.phoenix6.sim.TalonFXSimState ; // All hardware classes already have WPILib integration final TalonFX m_talonFX = new TalonFX ( 0 ); final CANcoder m_cancoder = new CANcoder ( 0 ); final TalonFXSimState m_talonFXSim = m_talonFX . getSimState (); final DutyCycleOut m_talonFXOut = new DutyCycleOut ( 0 ); final TalonFXConfiguration m_talonFXConfig = new TalonFXConfiguration (); final CANcoderConfiguration m_cancoderConfig = new CANcoderConfiguration (); InvertedValue m_talonFXInverted = InvertedValue . CounterClockwise_Positive ; m_talonFX . setControl ( m_talonFXOut ); C++ // Phoenix 6 is in the ctre/phoenix6 headers #include \"ctre/phoenix6/CANcoder.hpp\" #include \"ctre/phoenix6/TalonFX.hpp\" // Phoenix 6 uses the ctre::phoenix6 namespace using namespace ctre :: phoenix6 ; // now types are organized cleanly by namespace // All hardware classes already have WPILib integration hardware :: TalonFX m_talonFX { 0 }; hardware :: CANcoder m_cancoder { 0 }; sim :: TalonFXSimState & m_talonFXSim { m_talonFX . GetSimState ()}; controls :: DutyCycleOut m_talonFXOut { 0 }; configs :: TalonFXConfiguration m_talonFXConfig {}; configs :: CANcoderConfiguration m_cancoderConfig {}; signals :: InvertedValue m_talonFXInverted { signals :: InvertedValue :: CounterClockwise_Positive }; m_talonFX . SetControl ( m_talonFXOut );",
      "content_preview": "API Structure Phoenix 6 uses a separate, simpler set of namespaces and packages from Phoenix 5. Note For more information about the structure of Phoenix 6, see API Overview ."
    },
    {
      "url": "https://v6.docs.ctr-electronics.com/en/stable/docs/tuner/tuner-swerve/swerve-system-requirements.html",
      "title": "Swerve Requirements",
      "section": "Phoenix Tuner X",
      "language": "All",
      "content": "Swerve Requirements The swerve project creator and swerve API have several limitations. These limitations are in place to maximize performance and improve maintainability. Only Phoenix 6 supported hardware (e.g. Talon FX, Talon FXS, CANcoder, CANdi™, Pigeon 2.0). 8 Talon FX or Talon FXS (4 steer, 4 drive) 4 CANcoder (4 steer) OR 4 Talon FXS + PWM encoder OR 4 CANdi™ 1 Pigeon 2.0 Requires Phoenix 6 software released for the current release year of Tuner X. Firmware version of devices should match the API year (25.X firmware corresponds to 2025 API/Tuner) Ensure Tuner X shows server version (located at the bottom of Tuner X) that matches the Tuner X major version (2025 Tuner X requires 2025 server version) Temporary diagnostic server (or an existing robot project for that year of software) must be running and Tuner should be connected to the robot. This allows the generator to perform it’s setup and auto-calibration routines Some of these requirements are inforced via a mechanism called “precheck”. You can see and refresh the precheck status by clicking the Refresh button in the top right. Note While the Swerve API and project generator can be utilized without Pro or FD, both of these enhance robot control. When utilizing Pro and CAN FD, sensor data is acquired synchronously. FusedCANcoder and FusedCANdi improves the accuracy of module positions. Requirement Checklist Users can utilize the below checklist to ensure their robot is ready for project generation. Requirement Done? REQUIRED: Is there the minimum number of devices? (8 Talon FX/FXS, 4 CANcoder/CANdi™/Talon FXS + PWM encoder, 1 Pigeon 2.0) REQUIRED: Do all devices appear in Tuner X? REQUIRED: Are all devices on the same CAN bus? REQUIRED: Is all firmware up-to-date? (25.X) REQUIRED: Is the current year (2025) of diagnostics running? Recommended: Have devices been renamed? (e.g. “TalonFX (Device ID 1)” -> “FL Steer Motor”) Recommended: Are the devices on a CANivore? Recommended: Are the devices Pro-licensed? Once the user has reviewed the requirements, continue to Creating your Project to get started.",
      "content_preview": "Swerve Requirements The swerve project creator and swerve API have several limitations. These limitations are in place to maximize performance and improve maintainability. Only Phoenix 6 supported hardware (e.g. Talon FX, Talon FXS, CANcoder, CANdi™, Pigeon 2.0)."
    },
    {
      "url": "https://v6.docs.ctr-electronics.com/en/stable/docs/migration/migration-guide/status-signals-guide.html",
      "title": "Status Signals",
      "section": "General",
      "language": "All",
      "content": "Status Signals Phoenix 6 expands the functionality of status signals with the introduction of the StatusSignal ( Java , C++ ). Note For more information about status signals in Phoenix 6, see Status Signals . Using Status Signals v5 Java // get latest TalonFX selected sensor position // units are encoder ticks int sensorPos = m_talonFX . getSelectedSensorPosition (); // latency is unknown // cannot synchronously wait for new data C++ // get latest TalonFX selected sensor position // units are encoder ticks int sensorPos = m_talonFX . GetSelectedSensorPosition (); // latency is unknown // cannot synchronously wait for new data v6 Java // acquire a refreshed TalonFX rotor position signal var rotorPosSignal = m_talonFX . getRotorPosition (); // because we are calling getRotorPosition() every loop, // we do not need to call refresh() //rotorPosSignal.refresh(); // retrieve position value that we just refreshed // units are rotations, uses the units library var rotorPos = rotorPosSignal . getValue (); // the units library can be bypassed using getValueAsDouble() double rotorPosRotations = rotorPosSignal . getValueAsDouble (); // get latency of the signal var rotorPosLatency = rotorPosSignal . getTimestamp (). getLatency (); // synchronously wait 20 ms for new data rotorPosSignal . waitForUpdate ( 0.020 ); C++ // acquire a refreshed TalonFX rotor position signal auto & rotorPosSignal = m_talonFX . GetRotorPosition (); // because we are calling GetRotorPosition() every loop, // we do not need to call Refresh() //rotorPosSignal.Refresh(); // retrieve position value that we just refreshed // units are rotations, uses the units library auto rotorPos = rotorPosSignal . GetValue (); // get latency of the signal auto rotorPosLatency = rotorPosSignal . GetTimestamp (). GetLatency (); // synchronously wait 20 ms for new data rotorPosSignal . WaitForUpdate ( 20 _ms ); Changing Update Frequency (Status Frame Period) v5 Java // slow down the Status 2 frame (selected sensor data) to 5 Hz (200ms) m_talonFX . setStatusFramePeriod ( StatusFrameEnhanced . Status_2_Feedback0 , 200 ); C++ // slow down the Status 2 frame (selected sensor data) to 5 Hz (200ms) m_talonFX . SetStatusFramePeriod ( StatusFrameEnhanced :: Status_2_Feedback0 , 200 ); v6 Java // slow down the position signal to 5 Hz m_talonFX . getPosition (). setUpdateFrequency ( 5 ); C++ // slow down the position signal to 5 Hz m_talonFX . GetPosition (). SetUpdateFrequency ( 5 _Hz ); Note When different update frequencies are specified for signals that share a status frame, the highest update frequency of all the relevant signals will be applied to the entire frame. Users can get a signal’s applied update frequency using the getAppliedUpdateFrequency() method. Common Signals Several status signals have changed name or form in Phoenix 6. General Signals Phoenix 5 Phoenix 6 BusVoltage SupplyVoltage Faults / StickyFaults (fills an object) Fault_* / StickyFault_* (individual faults) FirmwareVersion Version Talon FX Signals Phoenix 5 Phoenix 6 MotorOutputPercent DutyCycle StatorCurrent StatorCurrent (motoring +, braking -), TorqueCurrent (forward +, reverse -) Inverted (true/false; matches setInverted ) AppliedRotorPolarity (CCW+/CW+; typically matches Inverted config, affected by follower features) SelectedSensorPosition / SelectedSensorVelocity Position / Velocity IntegratedSensor* (in SensorCollection ) Rotor* ActiveTrajectory* (only Motion Magic® and the Motion Profile Executor) ClosedLoopReference* (all closed-loop control requests) IsFwdLimitSwitchClosed / IsRevLimitSwitchClosed (true/false) GetForwardLimit / GetReverseLimit (Open/Closed) CANcoder Signals Phoenix 5 Phoenix 6 MagnetFieldStrength MagnetHealth Pigeon 2 Signals Note Many Pigeon 2 signal getters in Phoenix 5 fill an array, such as YawPitchRoll . In Phoenix 6, these signals have been broken up into their individual components, such as Yaw , Pitch , and Roll . Phoenix 5 Phoenix 6 RawGyro AngularVelocity* 6dQuaternion Quat* BiasedAccelerometer Acceleration* BiasedMagnetometer MagneticField* RawMagnetometer RawMagneticField*",
      "content_preview": "Status Signals Phoenix 6 expands the functionality of status signals with the introduction of the StatusSignal ( Java , C++ ). Note For more information about status signals in Phoenix 6, see Status Signals ."
    },
    {
      "url": "https://v6.docs.ctr-electronics.com/en/stable/docs/canivore/canivore-api.html",
      "title": "CANivore API",
      "section": "CANivore",
      "language": "All",
      "content": "CANivore API All device constructors have an overload that takes a string CAN bus identifier. This identifier can be rio for the native roboRIO CAN bus, * to select the first available CANivore, or a CANivore’s name or serial number. On non-FRC Linux systems, this string can also be a SocketCAN interface. Note If there are multiple CANivores with the same name, the system will use the first CANivore found. If no CAN bus string is passed into the constructor, or the CAN bus string is empty, the behavior is platform-dependent: roboRIO: use the roboRIO native CAN bus Windows: use the first CANivore found non-FRC Linux: use SocketCAN interface can0 Java TalonFX fx_default = new TalonFX ( 0 ); // On roboRIO, this constructs a TalonFX on the RIO native CAN bus TalonFX fx_rio = new TalonFX ( 1 , \"rio\" ); // This also constructs a TalonFX on the RIO native CAN bus TalonFX fx_drivebase = new TalonFX ( 0 , \"Drivebase\" ); // This constructs a TalonFX on the CANivore bus named \"Drivebase\" CANcoder cc_elevator = new CANcoder ( 0 , \"Elevator\" ); // This constructs a CANcoder on the CANivore bus named \"Elevator\" C++ (Header) hardware :: TalonFX fx_default { 0 }; // On roboRIO, this constructs a TalonFX on the RIO native CAN bus hardware :: TalonFX fx_rio { 1 , \"rio\" }; // This also constructs a TalonFX on the RIO native CAN bus hardware :: TalonFX fx_drivebase { 0 , \"Drivebase\" }; // This constructs a TalonFX on the CANivore bus named \"Drivebase\" hardware :: CANcoder cc_elevator { 0 , \"Elevator\" }; // This constructs a CANcoder on the CANivore bus named \"Elevator\" Python fx_default = hardware . TalonFX ( 0 ) # On roboRIO, this constructs a TalonFX on the RIO native CAN bus fx_rio = hardware . TalonFX ( 1 , \"rio\" ) # This also constructs a TalonFX on the RIO native CAN bus fx_drivebase = hardware . TalonFX ( 0 , \"Drivebase\" ) # This constructs a TalonFX on the CANivore bus named \"Drivebase\" cc_elevator = hardware . CANcoder ( 0 , \"Elevator\" ) # This constructs a CANcoder on the CANivore bus named \"Elevator\" CANBus API Instead of raw strings, a CANBus object ( Java , C++ , Python ) can be constructed and provided to device constructors. The API can also be used to retrieve information about any given CAN bus, such as the bus utilization. Java // create a CAN bus for the CANivore named drivetrain CANBus canbus = new CANBus ( \"drivetrain\" ); // construct a TalonFX on the CAN bus TalonFX fx = new TalonFX ( 0 , canbus ); // retrieve bus utilization for the CAN bus CANBusStatus canInfo = canbus . getStatus (); float busUtil = canInfo . BusUtilization ; if ( busUtil > 0.8 ) { System . out . println ( \"CAN bus utilization is greater than 80%!\" ); } C++ // create a CAN bus for the CANivore named drivetrain CANBus canbus { \"drivetrain\" }; // construct a TalonFX on the CAN bus hardware :: TalonFX fx { 0 , canbus }; // retrieve bus utilization for the CANivore named drivetrain CANBus :: CANBusStatus canInfo = canbus . GetStatus (); float busUtil = canInfo . BusUtilization ; if ( busUtil > 0.8 ) { std :: cout << \"CAN bus utilization is greater than 80%!\" << std :: endl ; } Python # create a CAN bus for the CANivore named drivetrain canbus = CANBus ( \"drivetrain\" ) # construct a TalonFX on the CAN bus fx = hardware . TalonFX ( 0 , canbus ) # retrieve bus utilization for the CANivore named drivetrain can_info = canbus . get_status () bus_util = can_info . bus_utilization if bus_util > 0.8 : print ( \"CAN bus utilization is greater than 80%!\" ) CANivore Status Prints When working with CANivore CAN buses in a robot program, Phoenix prints some messages to report the state of the CANivore connection. These messages can be useful to debug connection issues (bad USB vs bad CAN) or report bugs to CTR Electronics. Connection Messages Message Connection Status CANbus Failed to Connect Could not connect to a CANivore with the given name or serial number CANbus Connected Successfully found and connected to the CANivore with the given name or serial number CANbus Disconnected Detected that a CANivore USB device has been disconnected CANivore Bring-up Messages (Linux only) Message Bring-up Status CANbus Failed Bring-up Found and connected to the CANivore, but could not configure the device or start the network CANbus Successfully Started Successfully configured the CANivore and started the network Network State Messages Message Network State CANbus Network Down Linux: The SocketCAN network has been deactivated, USB-to-CAN activity has stopped Windows: Could not open the communication channels for USB-to-CAN traffic CANbus Network Up Linux: The SocketCAN network has been activated, USB-to-CAN activity has resumed Windows: Successfully opened the communication channels for USB-to-CAN traffic",
      "content_preview": "CANivore API All device constructors have an overload that takes a string CAN bus identifier. This identifier can be rio for the native roboRIO CAN bus, * to select the first available CANivore, or a CANivore’s name or serial number."
    },
    {
      "url": "https://v6.docs.ctr-electronics.com/en/stable/docs/tuner/tuner-swerve/generating-running-project.html",
      "title": "Generating the Project",
      "section": "Phoenix Tuner X",
      "language": "All",
      "content": "Generating the Project The robot program can be generated by clicking the Generate Project button. This will open a prompt asking for the team number for the generated project, followed by the programming language. Alternatively, the constants file alone can be regenerated for an existing project using the Generate only TunerConstants button. Tip It’s highly recommended to export the project settings using the Save As icon in the top-right. This will save time if the robot program or constants file needs to be regenerated for any reason.",
      "content_preview": "Generating the Project The robot program can be generated by clicking the Generate Project button. This will open a prompt asking for the team number for the generated project, followed by the programming language."
    },
    {
      "url": "https://v6.docs.ctr-electronics.com/en/stable/docs/api-reference/device-specific/talonfx/closed-loop-requests.html",
      "title": "Closed",
      "section": "TalonFX",
      "language": "All",
      "content": "Closed-Loop Overview Closed-loop control typically refers to control of a motor that relies on sensor data to adjust based on error. Systems/mechanisms that rely on maintaining a certain position or velocity achieve this state using closed-loop control. This is achieved by feedback (PID) and feedforward control. Closed-loop control can be performed on the robot controller or on the individual motor controllers. The benefits of onboard closed-loop control are that there is no sensor latency, and the closed-loop controller has a 1 kHz update frequency. This can result in a more responsive output compared to running the closed-loop on the robot controller. Since closed-loop control changes based on the dynamics of the system (velocity, mass, CoG, etc.), closed-loop relies on PID and feedforward parameters. These parameters are configured either via Tuner Configs or in code . The parameters can be determined using System Identification (such as with WPILib SysId ) or through manual tuning . Manual tuning typically follows this process: Set all gains to zero. Determine \\(K_g\\) if using an elevator or arm . Select the appropriate Static Feedforward Sign for your closed-loop type. Increase \\(K_s\\) until just before the motor moves. If using velocity setpoints, increase \\(K_v\\) until the output velocity closely matches the velocity setpoints. Increase \\(K_p\\) until the output starts to oscillate around the setpoint. Increase \\(K_d\\) as much as possible without introducing jittering to the response. All closed-loop control requests follow the naming pattern {ClosedLoopMode}{ControlOutputType} . For example, the VelocityVoltage control request performs a velocity closed-loop using voltage output. Choosing Output Type The choice of control output type can affect the reproducibility and stability of the closed-loop control. DutyCycle has the benefit of being the simplest control output type, as it is unaffected by voltage and current measurements. However, because DutyCycle represents a proportion of the supply voltage, changes in battery voltage can affect the reproducibility of the control request. Voltage control output takes into account the supply voltage to ensure its voltage output remains consistent. As a result, Voltage control often results in more stable and reproducible behavior compared to DutyCycle control, so Voltage control is often preferred. A disadvantage with both DutyCycle and Voltage control output types is that they control acceleration indirectly and require a velocity feedforward \\(K_v\\) to hold a constant velocity. On the other hand, torque-based control output types, such as TorqueCurrentFOC, directly control acceleration , which has several advantages: Since the torque request is directly proportional to acceleration, \\(K_v\\) is generally unnecessary. A torque output of 0 corresponds to a constant velocity, assuming no external forces. \\(K_a\\) can be tuned independently of all the other closed-loop gains by comparing the measured acceleration with the requested acceleration. Because the output is in units of torque, the units of the gains more closely match those of forces in the real world. As a result, torque-based control output types offer more stable and reproducible behavior that can be easier to tune compared to the other control output types. Gain Slots It may be useful to switch between presets of gains in a motor controller, so the TalonFX supports multiple gain slots. All closed-loop control requests have a member variable Slot that can be assigned an integer ID to select the set of gains used by the closed-loop. The gain slots can be configured in code using Slot*Configs ( Java , C++ , Python ) objects. Gravity Feedforward The gravity feedforward \\(K_g\\) is the output necessary to overcome gravity, in units of the control output type . Phoenix 6 supports the two most common use cases for \\(K_g\\) —elevators and arms—using the GravityType config in the gain slots. Elevator/Static For systems with a constant gravity component, such as an elevator, \\(K_g\\) adds a constant value to the closed-loop output. To find \\(K_g\\) , determine the output necessary to hold the elevator at a constant height in open-loop control. Arm/Cosine For systems with an angular gravity component, such as an arm, the output of \\(K_g\\) is dependent on the cosine of the angle between the arm and horizontal. The value of \\(K_g\\) can be found by determining the output necessary to hold the arm horizontally forward. Since the arm \\(K_g\\) uses the angle of the arm relative to horizontal, the Talon FX often requires an absolute sensor whose position is 1:1 with the arm, and the sensor offset and ratios must be configured. When using an absolute sensor, such as a CANcoder, the sensor offset must be configured such that a position of 0 represents the arm being held horizontally forward. From there, the RotorToSensor ratio must be configured to the ratio between the absolute sensor and the Talon FX rotor. Static Feedforward Sign The static feedforward \\(K_s\\) is the output needed to overcome the system’s static friction, in units of the control output type . Because friction always opposes the direction of motion, the sign of \\(K_s\\) also depends on the direction of motion. Phoenix 6 provides two possible methods of determining this signage using the StaticFeedforwardSign config in the gain slots. Velocity Sign By default, the signage of \\(K_s\\) is determined by the signage of the velocity setpoint. In other words, if the velocity setpoint is positive, then the output of \\(K_s\\) is positive; if the velocity setpoint is negative, then \\(K_s\\) is negative. This option is always used when running velocity closed loops, and it is recommended for Motion Magic® controls and motion-profiled position closed loops. Closed-Loop Sign When using a position closed-loop controller, signage of \\(K_s\\) can instead be determined by the sign of the closed-loop error. For example, if the position error (target - measured) is positive, then the output of \\(K_s\\) is positive; if the error is negative, then \\(K_s\\) is negative. This option is typically used when a velocity setpoint is otherwise not available, such as when running unprofiled position closed loops. Important When using the sign of closed-loop error for \\(K_s\\) , it is important that the selected \\(K_s\\) value is not too large. Otherwise, the motor output may dither or oscillate when near the closed-loop target. Converting from Meters In some applications, it may be useful to translate between meters and rotations. This can be done using the following equation: \\[rotations = \\frac{meters}{2 \\pi \\cdot wheelRadius} \\cdot gearRatio\\] where meters is the target in meters, wheelRadius is the radius of the wheel in meters, and gearRatio is the gear ratio between the output shaft and the wheel. This equation also works with converting velocity from m/s to rps or acceleration from m/s² to rps/s. Continuous Mechanism Wrap A continuous mechanism is a mechanism with unlimited travel in any direction, and whose rotational position can be represented with multiple unique position values. Some examples of continuous mechanisms are swerve drive steer mechanisms or turrets (without cable management). ContinuousWrap ( Java , C++ , Python ) is a mode of closed loop operation that enables the Talon to take the “shortest path” to a target position for a continuous mechanism. It does this by assuming that the mechanism is continuous within 1 rotation. For example, if a Talon is currently at 2.1 rotations, it knows this is equivalent to every position that is exactly 1.0 rotations away from each other (3.1, 1.1, 0.1, -0.9, etc.). If that Talon is then commanded to a position of 0.8 rotations, instead of driving backwards 1.3 rotations or forwards 0.7 rotations, it will drive backwards 0.3 rotations to a target of 1.8 rotations. Note The ContinuousWrap config only affects the closed loop operation. Other signals such as Position are unaffected by this config. In order to use this feature, the FeedbackConfigs ( Java , C++ , Python ) ratio configs must be configured so that the mechanism is properly described. An example is provided below, where there is a continuous mechanism with a 12.8:1 speed reduction between the rotor and mechanism.",
      "content_preview": "Closed-Loop Overview Closed-loop control typically refers to control of a motor that relies on sensor data to adjust based on error. Systems/mechanisms that rely on maintaining a certain position or velocity achieve this state using closed-loop control."
    },
    {
      "url": "https://v6.docs.ctr-electronics.com/en/stable/docs/api-reference/examples/quickstart.html",
      "title": "Open",
      "section": "API Reference",
      "language": "All",
      "content": "Open-Loop Quickstart The below example showcases controlling a four-motor drivetrain. Declaring Motor Controllers The TalonFX motor controller constructor ( Java , C++ , Python ) requires a device ID (int) and an optional CAN bus (string). Note The name of the native roboRIO CAN bus is rio . This is also the default CAN bus on the roboRIO when none is specified. Java public class Robot extends TimedRobot { private static final String kCANBus = \"canivore\" ; private final TalonFX m_leftLeader = new TalonFX ( 0 , kCANBus ); private final TalonFX m_rightLeader = new TalonFX ( 1 , kCANBus ); private final TalonFX m_leftFollower = new TalonFX ( 2 , kCANBus ); private final TalonFX m_rightFollower = new TalonFX ( 3 , kCANBus ); } C++ (Header) class Robot : public frc :: TimedRobot { private : static constexpr char const * kCANBus { \"canivore\" }; ctre :: phoenix6 :: hardware :: TalonFX m_leftLeader { 0 , kCANBus }; ctre :: phoenix6 :: hardware :: TalonFX m_rightLeader { 1 , kCANBus }; ctre :: phoenix6 :: hardware :: TalonFX m_leftFollower { 2 , kCANBus }; ctre :: phoenix6 :: hardware :: TalonFX m_rightFollower { 3 , kCANBus }; } Configure Followers & Inverts In a traditional robot drivetrain, there are two motors attached to each horizontal side of the drivetrain. This setup typically (unless mechanically inverted) causes the right side to rotate in an opposite direction when given the same voltage. Java public Robot () { // start with factory-default configs var currentConfigs = new MotorOutputConfigs (); // The left motor is CCW+ currentConfigs . Inverted = InvertedValue . CounterClockwise_Positive ; m_leftLeader . getConfigurator (). apply ( currentConfigs ); // The right motor is CW+ currentConfigs . Inverted = InvertedValue . Clockwise_Positive ; m_rightLeader . getConfigurator (). apply ( currentConfigs ); // Ensure our followers are following their respective leader m_leftFollower . setControl ( new Follower ( m_leftLeader . getDeviceID (), false )); m_rightFollower . setControl ( new Follower ( m_rightLeader . getDeviceID (), false )); } C++ (Source) #include \"Robot.h\" using namespace ctre :: phoenix6 ; Robot :: Robot () { // start with factory-default configs configs :: MotorOutputConfigs currentConfigs {}; // The left motor is CCW+ currentConfigs . Inverted = signals :: InvertedValue :: CounterClockwise_Positive ; m_leftLeader . GetConfigurator (). Apply ( currentConfigs ); // The right motor is CW+ currentConfigs . Inverted = signals :: InvertedValue :: Clockwise_Positive ; m_rightLeader . GetConfigurator (). Apply ( currentConfigs ); // Ensure the followers are following their respective leader m_leftFollower . SetControl ( controls :: Follower { m_leftLeader . GetDeviceID (), false }); m_rightFollower . SetControl ( controls :: Follower { m_rightLeader . GetDeviceID (), false }); } Full Example Java public class Robot extends TimedRobot { private static final String kCANBus = \"canivore\" ; private final TalonFX m_leftLeader = new TalonFX ( 0 , kCANBus ); private final TalonFX m_rightLeader = new TalonFX ( 1 , kCANBus ); private final TalonFX m_leftFollower = new TalonFX ( 2 , kCANBus ); private final TalonFX m_rightFollower = new TalonFX ( 3 , kCANBus ); private final DutyCycleOut m_leftOut = new DutyCycleOut ( 0 ); private final DutyCycleOut m_rightOut = new DutyCycleOut ( 0 ); private final XboxController m_driverJoy = new XboxController ( 0 ); public Robot () { // start with factory-default configs var currentConfigs = new MotorOutputConfigs (); // The left motor is CCW+ currentConfigs . Inverted = InvertedValue . CounterClockwise_Positive ; m_leftLeader . getConfigurator (). apply ( currentConfigs ); // The right motor is CW+ currentConfigs . Inverted = InvertedValue . Clockwise_Positive ; m_rightLeader . getConfigurator (). apply ( currentConfigs ); // Ensure our followers are following their respective leader m_leftFollower . setControl ( new Follower ( m_leftLeader . getDeviceID (), false )); m_rightFollower . setControl ( new Follower ( m_rightLeader . getDeviceID (), false )); } @Override public void teleopPeriodic () { // retrieve joystick inputs var fwd = - m_driverJoy . getLeftY (); var rot = m_driverJoy . getRightX (); // modify control requests m_leftOut . Output = fwd + rot ; m_rightOut . Output = fwd - rot ; // send control requests m_leftLeader . setControl ( m_leftOut ); m_rightLeader . setControl ( m_rightOut ); } } C++ (Source) #include \"Robot.h\" using namespace ctre :: phoenix6 ; Robot :: Robot () { // start with factory-default configs configs :: MotorOutputConfigs currentConfigs {}; // The left motor is CCW+ currentConfigs . Inverted = signals :: InvertedValue :: CounterClockwise_Positive ; m_leftLeader . GetConfigurator (). Apply ( currentConfigs ); // The right motor is CW+ currentConfigs . Inverted = signals :: InvertedValue :: Clockwise_Positive ; m_rightLeader . GetConfigurator (). Apply ( currentConfigs ); // Ensure the followers are following their respective leader m_leftFollower . SetControl ( controls :: Follower { m_leftLeader . GetDeviceID (), false }); m_rightFollower . SetControl ( controls :: Follower { m_rightLeader . GetDeviceID (), false }); } void Robot :: TeleopPeriodic () { // retrieve joystick inputs auto fwd = - m_driverJoy . GetLeftY (); auto rot = m_driverJoy . GetRightX (); // modify control requests m_leftOut . Output = fwd + rot ; m_rightOut . Output = fwd - rot ; // send control requests m_leftLeader . SetControl ( m_leftOut ); m_rightLeader . SetControl ( m_rightOut ); } C++ (Header) private : static constexpr char const * kCANBus { \"canivore\" }; ctre :: phoenix6 :: hardware :: TalonFX m_leftLeader { 0 , kCANBus }; ctre :: phoenix6 :: hardware :: TalonFX m_rightLeader { 1 , kCANBus }; ctre :: phoenix6 :: hardware :: TalonFX m_leftFollower { 2 , kCANBus }; ctre :: phoenix6 :: hardware :: TalonFX m_rightFollower { 3 , kCANBus }; ctre :: phoenix6 :: controls :: DutyCycleOut m_leftOut { 0 }; ctre :: phoenix6 :: controls :: DutyCycleOut m_rightOut { 0 }; frc :: XboxController m_driverJoy { 0 };",
      "content_preview": "Open-Loop Quickstart The below example showcases controlling a four-motor drivetrain. Declaring Motor Controllers The TalonFX motor controller constructor ( Java , C++ , Python ) requires a device ID (int) and an optional CAN bus (string). Note The name of the native roboRIO CAN bus is rio ."
    },
    {
      "url": "https://v6.docs.ctr-electronics.com/en/stable/docs/application-notes/tuner-evolution.html",
      "title": "Tuner and an evolution in configuration",
      "section": "Application Notes",
      "language": "All",
      "content": "Tuner and an evolution in configuration Authored by Dalton Since the introduction of the CTRE Toolsuite (pre-2018), we at CTR have strived to provide intuitive means of configuring and utilizing our products. In 2018, we launched Phoenix Tuner (now lovingly referred to as Tuner v1). Tuner v1 introduced features like: batch firmware upgrading like devices, diagnostic server deployment, self tests, plotting and control. With Tuner, and by extension diagnostics, we have several primary objectives: Ease of debugging (exposed via self test). Seamless setup experience. Support and integrate our extension feature-set. Tuner v1 was and is great, but we wanted to do more. In the 2023 season, we introduced Tuner X. Introducing Tuner X The goal we had with Tuner X development was to refine and enhance the existing Tuner v1 feature set. We introduced Android support , improved batch upgrading, improved highlighting of duplicate devices, automatic firmware downloads (no more downloading CRFs!), improved self test and licensing support. With Tuner X, users can: Configure their device’s name & ID Blink a device, which is useful for identifying where the device is on the robot. Firmware update all devices to the latest version available (no more CRF downloads). Control individual motors with their Android phone, or on Windows. Plot various signals such as velocity, position and yaw. Self test their v6 device, which provides a marked up self test of the device. Important Tuner X does not require v6 and can be used with v5 flashed devices. For a full list of features, check out the v6 documentation . Introducing a new iteration of Tuner X Some of you may have noticed that your version of Tuner X has changed recently. We’ve been working on several key improvements to the application that should dramatically improve the user experience. While this blog will highlight some of those, it’s best to just try out the new Tuner yourself. Note Feedback is welcome and can be provided by emailing feedback @ ctr-electronics . com . Improved connection diagnostics Tuner requires a running diagnostic server to work. Typically, this is installed through a robot program utilizing one of our devices. Alternatively, this program is temporarily run using a button in Settings . We’ve improved the disconnection status card to contain information about the ping of the target and diagnostic state of the device. This 3 step check looks for the following: Ping of the target. Is diagnostics (or a robot program with diagnostics) running? Are there any devices reported? To summarize, if a user is not seeing devices in Tuner but checks 1 and 2 are good, then the next recommendation is to check the LED status of the device. We have an extensive list of status LEDs that indicate if the device is detected on a CAN bus, or other problems. This list can be found on the corresponding device page in the docs. For example, look at the CANcoder LED table . Redesigned device overview The device overview page has been redesigned to improve usability of plot, control and configuration. It’s never been easier to tune your closed-loop gains directly in Tuner! Bug squashing and usability improvements This list is by no means exhaustive, but provides a good idea of the changes between 2023.X and 2024 versions of Tuner X. Firmware selection now has a dropdown for year, allowing you to flash older year firmware Dramatically improved startup and navigation performance Dramatically improved plotting performance Dramatically improved commands timing out on Android Tuner Enable/Disable button colors have been adjusted to be more clear Fixed “connection blipping” on Android Tuner Fixed control sometimes stuttering and causing the device to disable Fixed licensing sometimes fail to load on Android Tuner Fixed SSH credentials popup not appearing sometimes Fixed lag when entering into various entries Fixed memory leak when plotting for long periods of time Fixed situation where the application would shutdown uncleanly and lose settings Fixed various clipping of icons, text and labels Fixed issue where CANivore USB toggle would be unable to enable or disable Fixed firmware flashing on Raspberry Pi Fixed temporary diagnostic deployment on non-RIO platforms Slows down CANivore polling, which improves Rio CPU performance when Tuner is open What’s next? We have a couple of exciting improvements to Tuner on our radar, keep an eye out on our changelog . Tuner X can be downloaded via the Microsoft Store and the Google Play Store .",
      "content_preview": "Tuner and an evolution in configuration Authored by Dalton Since the introduction of the CTRE Toolsuite (pre-2018), we at CTR have strived to provide intuitive means of configuring and utilizing our products. In 2018, we launched Phoenix Tuner (now lovingly referred to as Tuner v1)."
    },
    {
      "url": "https://v6.docs.ctr-electronics.com/en/stable/docs/tuner/index.html",
      "title": "Phoenix Tuner X",
      "section": "Phoenix Tuner X",
      "language": "All",
      "content": "Phoenix Tuner X What is Phoenix Tuner X? Phoenix Tuner X is the companion application allowing you to update, configure, analyze, and control your devices. Phoenix Tuner X can be installed from the Microsoft Store , the Google Play Store , and the Apple App Store . Phoenix Tuner X supports Windows 10 (1903+), Windows 11, Android (8.0+), macOS (12.0+), and iOS (15.0+). Important While CTR Electronics supports both Phoenix Tuner v1 and Phoenix Tuner X, certain features such as device licensing, Phoenix 6 Self Test, and improved field upgrading are only available in Phoenix Tuner X. Tip Many UI elements contain hover tooltips. That means the user can hover over them with their mouse for a text explanation of what they do. Connecting Tuner Device List Tuner History Device Details Tuner Configs Self Test Snapshot Controlling Devices Plotting Pigeon 2.0 Calibration Tools Swerve Project Generator",
      "content_preview": "Phoenix Tuner X What is Phoenix Tuner X? Phoenix Tuner X is the companion application allowing you to update, configure, analyze, and control your devices. Phoenix Tuner X can be installed from the Microsoft Store , the Google Play Store , and the Apple App Store ."
    },
    {
      "url": "https://v6.docs.ctr-electronics.com/en/stable/docs/application-notes/devblog.html",
      "title": "Development Blog",
      "section": "Application Notes",
      "language": "All",
      "content": "Development Blog Welcome to the development blog. Here, we will highlight various features of CTR Electronics devices and how they can be utilized in specific applications. Note This list may move in the future. Latency and Frequency Tuner and an evolution in configuration Factors that Impact Odometry Tuning CANrange",
      "content_preview": "Development Blog Welcome to the development blog. Here, we will highlight various features of CTR Electronics devices and how they can be utilized in specific applications. Note This list may move in the future."
    },
    {
      "url": "https://v6.docs.ctr-electronics.com/en/stable/docs/hardware-reference/talonfx/improving-performance-with-current-limits.html",
      "title": "Improving Performance with Current Limits",
      "section": "TalonFX",
      "language": "All",
      "content": "Improving Performance with Current Limits Current limiting is the process of restricting motor output when a given current has surpassed a limit. There are two types of current limits available: stator and supply. Each of these limits accomplishes different goals. This article goes over why current limiting is important, when to configure these limits, and how to configure them. Note By default, devices are configured with default current limits, listed in the relevant config API documentation. However, the optimal limits depend on how the motor is integrated into the system. There are additional safety measures in place to prevent damage to the motor or motor controller under excessive load. Stator and Supply Current Limits It’s important to understand the need for current limits and how they work. When a motor is under a load, it takes an increasing amount of current to continue rotating the shaft of the motor (and by extension the mechanism). The cumulative sum of all the currents in a multi-motor system, such as a robot, may excessively drain batteries, trigger brownout protection, or in the worst case trip breakers. There are two forms of current limiting: stator and supply. The relevant configs are located in the CurrentLimits config group ( Java , C++ , Python ). All current limits must be separately enabled using the appropriate enable config. Note Current limits are applied in TorqueCurrentFOC in addition to the PeakForwardTorqueCurrent and PeakReverseTorqueCurrent configs, where the most restrictive limit is used. Torque current is equivalent to stator current in magnitude. Stator Limits Stator current is the output current of the motor and is directly proportional to torque. 80 A stator current limit taking effect Stator current limits are used to restrict the torque output of the motor. This can be used to prevent wheel slip or avoid damaging a mechanism when running into a hard stop. Stator current limits also reduce heat buildup in the motor. Since stator current limits also limit supply current, they are also effective at preventing brownouts when accelerating from zero velocity. Relationship between Supply and Stator Current Note This explanation ignores energy loss from heat or other inefficiencies. By conservation of energy, power going into the motor must equal power out. Since power is equivalent to voltage times current, \\(V_{supply} * I_{supply} = V_{stator} * I_{stator}\\) , where \\(V_{stator}\\) is the output voltage of the motor. The duty cycle output of a motor is equivalent to \\(V_{stator} / V_{supply}\\) , so the relationship between supply and stator current can be described as \\(I_{supply} = I_{stator} * duty cycle\\) . As an example, if a motor is applied 100% output (~12 V) and has 80 A of measured stator current, as is the case at a high rotor velocity, then the supply current will also be 80 A. However, if the motor is applied 50% output (~6 V) and has 80 A of measured stator current, as is the case at a low rotor velocity, then supply current will only be 40 A. This means that stator current limits also effectively limit supply current. Supply current will not exceed a stator current limit and is often significantly lower than stator current. Another impact that stator current limits have is that they restrict acceleration. Stator current limits cap the torque output of the motor, which directly increases the amount of time it takes to accelerate to max velocity. As a result, it is important not to set stator current limits too low, otherwise performance may be negatively impacted. Without stator limit (~170 rotations/second²) With 80 A stator limit (~75 rotations/second²) Supply Limits Supply current is the current drawn from the battery. As a result, limiting supply current can avoid brownouts, prevent breakers from tripping, and improve the longevity of the battery. Tip Since stator current limits also limit supply current, it is sometimes not necessary to enable both limits. When enabled, the supply current limiter always ensures that the supply current does not exceed the configured SupplyCurrentLimit , preventing brownouts. Optionally, if the supply current limiter has been actively limiting for the SupplyCurrentLowerTime , the limit will be reduced to the SupplyCurrentLowerLimit until supply current is below that limit, preventing breakers from tripping. If the robot experiences brownouts despite configuring stator current limits, a supply current limit can also further help avoid brownouts. However, such brownouts are often caused by a bad battery or poor power wiring, so those should be examined first. Determining Current Limits While supply current limits can be theoretically estimated by calculating max supply draw for every mechanism, stator limits are not easy to estimate. Determine your stator current limits first, then supply if necessary. In some cases, stator current limits are sufficient to prevent battery brownouts, as stator current limits also limit supply current. Preventing Wheel Slip Stator current limits are excellent at preventing wheel slip, which is necessary to maximize power output of the system. To determine wheel slip, perform the following instructions: Place the robot on carpet against a wall. Begin plotting velocity and stator current in Tuner X . Slowly increase voltage output until the velocity becomes non-zero and the stator current drops. Set your stator current limit to a value below the observed stator current in Tuner. In the example below, the wheels began slipping at around 130 A. Preventing Brownouts Brownouts occur when the robot voltage dips below a threshold. For the FRC roboRIO , this threshold is 6.3 V on the roboRIO 1 and 6.75 V (by default) on the roboRIO 2. When the roboRIO dips below the threshold, it will disable all actuators to prevent a total robot reboot. Brownouts most commonly occur when the motor accelerates or is otherwise under high load (such as in a pushing match). Since stator current limits are highly effective at limiting supply current, especially at the start of acceleration, they are also highly effective at preventing brownouts in both of these scenarios. For some high-inertia mechanisms, such as some flywheels, supply current limits can also be used to further prevent brownouts during long periods of acceleration or high load. However, the robot should be checked for some common electrical issues before considering more restrictive current limits: Check the health of the battery, which can be done using a Battery Beak or by performing a full discharge test with a battery analyzer . Make sure your battery leads are properly tightened to the battery, and the battery connector is properly crimped. If using the CTRE PDP, make sure the leads going into the PDP are properly crimped and secured. Check all device power connections at the PDP/PDH. The PDP/PDH should be clearly connected to copper and not wire insulation. As motor supply currents increase, the battery voltage will decrease in a similar fashion. A simplified equation for modeling voltage sag is shown below along with a calculator. However, it is easier and more accurate to empirically determine supply current limits. The process of empirically finding these limits is the same as in Improving Battery Longevity . \\[V_{loaded} = V_{unloaded} - (I_{totalsupply} * R_{battery})\\] Loaded Battery Voltage Calculator Unloaded voltage (V) Total current draw (A) Battery resistance (mOhms) = 0 V Be aware that battery health (in the form of battery resistance above) significantly impacts how large current draw affects the output voltage of the battery. Health of the battery can be roughly determined via a Battery Beak or by performing a battery discharge test with a battery analyzer . Improving Battery Longevity While supply limits can be estimated using battery datasheets and average mechanism current draw, the easiest and most reliable method is to test, analyze, and reduce. By applying a conservative supply limit to mechanisms that can operate with minimal current draw, you can improve the performance of other mechanisms (e.g. reducing your intake current limits to increase the amount of current available for a swerve drivetrain). Plot a mechanism’s supply currents throughout the match. Reduce the supply current limits until your performance begins to suffer (unable to intake items, etc.). Increase this value slightly for some comfort room. Repeat this for all mechanisms on a fresh battery each time. Time how long it takes before brownouts are regular and battery capacity has dropped. For example, a user may have the following mechanisms and current limits: x4 Kraken(s) on swerve drive - 120 A stator, 70 A supply x4 Kraken(s) on swerve azimuth - 60 A stator, no supply limit (<60 A) x1 Kraken(s) on elevator - 80 A stator, 30 A supply x1 Kraken(s) on intake - 20 A stator, no supply limit (<20 A) This would yield a peak supply current of <570 A in the worst case scenario. However, this current draw is extremely unlikely . Stator current limits ensure all motors and mechanisms will not be under peak load at the same time. Peak current draw occurs towards the end of acceleration when stator current limits are enabled. Additionally, peak supply current is often extremely brief (>60 A on all 4 swerve drive motors lasts <0.5 seconds). A more common scenario is 4 swerve drive motors accelerating at the same time for a peak supply current of 280 A. When determining supply current limits for a mechanism, ensure that its peak supply current and the duration of that peak does not cause any breakers to trip. FRC breakers typically trip from temperature and can sustain well beyond their rated amperage for a given amount of time. Consult the manufacturer datasheet for the breakers you use to see their trip times. Reduce your current limits until your battery life is in an acceptable range. How to Apply Current Limits Current limits must be enabled and configured . This can be done in Tuner X configs or using the Phoenix 6 configuration API . Java var talonFXConfigurator = m_talonFX . getConfigurator (); var limitConfigs = new CurrentLimitsConfigs (); // enable stator current limit limitConfigs . StatorCurrentLimit = 120 ; limitConfigs . StatorCurrentLimitEnable = true ; talonFXConfigurator . apply ( limitConfigs ); C++ auto & talonFXConfigurator = m_talonFX . GetConfigurator (); configs :: CurrentLimitsConfigs limitConfigs {}; // enable stator current limit limitConfigs . StatorCurrentLimit = 120 ; limitConfigs . StatorCurrentLimitEnable = true ; talonFXConfigurator . Apply ( limitConfigs ); Python talonfx_configurator = self . talonfx . configurator limit_configs = configs . CurrentLimitsConfigs () # enable stator current limit limit_configs . stator_current_limit = 120 limit_configs . stator_current_limit_enable = true talonfx_configurator . apply ( limit_configs )",
      "content_preview": "Improving Performance with Current Limits Current limiting is the process of restricting motor output when a given current has surpassed a limit. There are two types of current limits available: stator and supply. Each of these limits accomplishes different goals."
    },
    {
      "url": "https://v6.docs.ctr-electronics.com/en/stable/docs/api-reference/api-usage/hoot-replay.html",
      "title": "Hoot Replay",
      "section": "API Reference",
      "language": "All",
      "content": "Hoot Replay Note Information on logging to hoot files can be found in Signal Logging . Hoot Replay allows users to playback hoot logs in their robot program. This allows for testing changes to robot code in simulation using measurements recorded from the real robot. Important Hoot Replay requires the hoot log to have a Pro-licensed device. Currently, only one hoot log may be replayed at a time. Compared to other replay frameworks, Hoot Replay offers automatic status signal playback without any code changes. However, replaying custom logged signals still requires modifications to the robot’s subsystems. Hoot Replay is controlled using the HootReplay class ( Java , C++ , Python ) and supports playing back device status signals and custom user signals. Configs and control requests are ignored during replay. Hoot Replay uses a different vendordep (see Installing Phoenix 6 ) that replaces Hardware-Attached Simulation with Hoot Replay. Note that only one Phoenix 6 vendordep may be used in the vendordeps folder at a time. Starting Hoot Replay At the start of the robot program, the desired hoot log can be loaded using HootReplay.loadFile(fileName) ( Java , C++ , Python ). Hoot Replay will start automatically after the log has been loaded. Java HootReplay . loadFile ( \"./logs/example.hoot\" ); C++ HootReplay :: LoadFile { \"./logs/example.hoot\" }; Python HootReplay . load_file ( \"./logs/example.hoot\" ) It is important that the hoot log is loaded before any devices are constructed or configured. To make this process easier, the CANBus(canbus, fileName) constructor ( Java , C++ , Python ) can instead be used to load the hoot log. Java // construct the CANBus with the hoot log final CANBus canbus = new CANBus ( \"canivore\" , \"./logs/example.hoot\" ); // now the log is guaranteed to be loaded before devices are constructed final TalonFX talonFX = new TalonFX ( 0 , canbus ); C++ // construct the CANBus with the hoot log CANBus canbus { \"canivore\" , \"./logs/example.hoot\" }; // now the log is guaranteed to be loaded before devices are constructed hardware :: TalonFX talonFX { 0 , canbus }; Python # construct the CANBus with the hoot log self . _canbus = CANBus ( \"canivore\" , \"./logs/example.hoot\" ) # now the log is guaranteed to be loaded before devices are constructed self . _talon_fx = hardware . TalonFX ( 0 , canbus ) Controlling Replay During Hoot Replay, the simulated robot will automatically enable and run through all the maneuvers recorded in the hoot log. There are also several APIs that can be used to manage playback. HootReplay.pause() temporarily pauses playback HootReplay.play() resumes playback from the current point in the file HootReplay.stop() pauses playback and returns to the start of the file HootReplay.restart() restarts playback from the start of the file HootReplay.setSpeed(speed) changes the speed of playback by a scalar The status of Hoot Replay can be checked using HootReplay.isFileLoaded() and HootReplay.isPlaying() . Threads can also wait for Hoot Replay to start using HootReplay.waitForPlaying(timeout) . Tip HootReplay.isPlaying() and HootReplay.waitForPlaying(timeout) immediately return true when running on the robot or in regular simulation. Additionally, after pausing or stopping Hoot Replay, playback can advance by a fixed timestep using HootReplay.stepTiming(timeDelta) , updating all signals accordingly. Java // stop and return to start of log HootReplay . stop (); var startPos = talonFX . getPosition (). getValue (); // advance by 1 second and compare positions HootReplay . stepTiming ( 1.0 ); var endPos = talonFX . getPosition (). getValue (); C++ // stop and return to start of log HootReplay :: Stop (); auto const startPos = talonFX . GetPosition (). GetValue (); // advance by 1 second and compare positions HootReplay :: StepTiming ( 1 _s ); auto const endPos = talonFX . GetPosition (). GetValue (); Python # stop and return to start of log HootReplay . stop () start_pos = self . _talon_fx . get_position () . value # advance by 1 second and compare positions HootReplay . step_timing ( 1.0 ) end_pos = self . _talon_fx . get_position () . value Replaying Custom Signals Users can also fetch custom signals written to the loaded hoot log by utilizing the get*() functions. An example application of this is replaying vision data to test changes in the drivetrain pose estimator. All custom signal getters return a HootReplay.SignalData ( Java , C++ , Python ) object containing information about the signal, including its timestamp and any logged units. The success of fetching the custom signal can be validated by checking the status field. Java // Fetch the logged raw vision measurements var visionData = HootReplay . getDoubleArray ( \"camera pose\" ); if ( visionData . status . isOK ()) { var camPose = new Pose2d ( visionData . value [ 0 ] , visionData . value [ 1 ] , Rotation2d . fromDegrees ( visionData . value [ 2 ] ) ); // now run regular vision processing on the vision data if ( isCameraPoseValid ( camPose )) { drivetrain . addVisionMeasurement ( camPose , visionData . timestampSeconds ); } } C++ // Fetch the logged raw vision measurements auto const visionData = HootReplay :: GetDoubleArray ( \"camera pose\" ); if ( visionData . status . IsOK ()) { frc :: Pose2d const camPose { visionData . value [ 0 ] * 1 _m , visionData . value [ 1 ] * 1 _m , frc :: Rotation2d { visionData . value [ 2 ] * 1 _deg } }; // now run regular vision processing on the vision data if ( IsCameraPoseValid ( camPose )) { drivetrain . AddVisionMeasurement ( camPose , visionData . timestamp ); } } Python # Fetch the logged raw vision measurements vision_data = HootReplay . get_double_array ( \"camera pose\" ) if visionData . status . is_ok (): cam_pose = Pose2d ( vision_data . value [ 0 ], vision_data . value [ 1 ], Rotation2d . fromDegrees ( vision_data . value [ 2 ]) ) # now run regular vision processing on the vision data if is_camera_pose_valid ( cam_pose ): drivetrain . add_vision_measurement ( cam_pose , vision_data . timestamp ) Adjusting Robot Code Architecture Replaying custom signals typically requires changes to the architecture of the robot’s subsystems or other hardware classes. As an example, consider changes to a Vision class. When working with vision, a robot program will typically fetch raw/unfiltered camera/pose data (the “inputs”) from the vision library (such as a list of targets). Then, it will perform some additional processing and filtering on that data to get the final vision pose estimate (the “output”). The goal is to replay the “inputs” so the replayed program can test changes to the subsequent data processing and filtering. This means the robot program should only replay data that is unaffected by code logic , letting the program determine all the new outputs. The simplest way to make the code easily replayed is to consolidate all input fetches into a single fetchInputs() function, save the results to class member variables, and log the data using SignalLogger . From there, a single periodic function would be responsible for calling that function and performing all data processing to get the outputs. For example, if the only data pulled from the vision library is the raw vision pose estimate and its timestamp: Java public class Vision { private final Camera camera = new Camera (...); /* vision inputs */ private PoseEstimate cameraPoseEst = new PoseEstimate (); // ... private void fetchInputs () { // fetch and log inputs cameraPoseEst = camera . getPoseEstimate (); final var poseArr = new double [ 3 ] { cameraPoseEst . pose . getX (), cameraPoseEst . pose . getY (), cameraPoseEst . pose . getRotation (). getDegrees () }; SignalLogger . writeDoubleArray ( \"CameraPoseEst/pose\" , poseArr ); SignalLogger . writeDouble ( \"CameraPoseEst/timestamp\" , cameraPoseEst . timestamp ); } public void periodic () { fetchInputs (); // process inputs here... } } C++ class Vision { private : Camera camera {...}; /* vision inputs */ PoseEstimate cameraPoseEst {}; // ... void FetchInputs () { // fetch and log inputs cameraPoseEst = camera . GetPoseEstimate (); std :: array < double , 3 > const poseArr { cameraPoseEst . pose . X (). value (), cameraPoseEst . pose . Y (). value (), cameraPoseEst . pose . Rotation (). Degrees (). value () }; SignalLogger :: WriteDoubleArray ( \"CameraPoseEst/pose\" , poseArr ); SignalLogger :: WriteValue ( \"CameraPoseEst/timestamp\" , cameraPoseEst . timestamp ); } public : void Periodic () { FetchInputs (); // process inputs here... } }; Python class Vision : def __init__ ( self ): self . _camera = Camera ( ... ) # vision inputs self . _camera_pose_est = PoseEstimate () # ... def _fetch_inputs ( self ): # fetch and log inputs self . _camera_pose_est = camera . getPoseEstimate () pose_arr = [ self . _camera_pose_est . pose . x , self . _camera_pose_est . pose . y , self . _camera_pose_est . pose . rotation () . degrees () ] SignalLogger . write_double_array ( \"CameraPoseEst/pose\" , pose_arr ) SignalLogger . write_double ( \"CameraPoseEst/timestamp\" , self . _camera_pose_est . timestamp ) def periodic ( self ): self . _fetch_inputs () # process inputs here... This makes it easy to implement a fetchInputsReplay() function, which can be called when Utils.isReplay() ( Java , C++ , Python ) returns true. This function would do the reverse of the regular fetchInputs() , pulling out the data from HootReplay and saving it to the class member variables. For example, the previous Vision example would now have: Java private void fetchInputsReplay () { // pull out inputs from the log final var cameraPoseEst_pose = HootReplay . getDoubleArray ( \"CameraPoseEst/pose\" ); final var cameraPoseEst_timestamp = HootReplay . getDouble ( \"CameraPoseEst/timestamp\" ); if ( cameraPoseEst_pose . status . isOK () && cameraPoseEst_timestamp . status . isOK () ) { cameraPoseEst = new PoseEstimate (); cameraPoseEst . pose = new Pose2d ( cameraPoseEst_pose . value [ 0 ] , cameraPoseEst_pose . value [ 1 ] , Rotation2d . fromDegrees ( cameraPoseEst_pose . value [ 2 ] ) ); cameraPoseEst . timestamp = cameraPoseEst_timestamp . value ; } } public void periodic () { if ( Utils . isReplay ()) { fetchInputsReplay (); } else { fetchInputs (); } // process inputs here... } C++ private : void FetchInputsReplay () { // pull out inputs from the log auto const cameraPoseEst_pose = HootReplay :: GetDoubleArray ( \"CameraPoseEst/pose\" ); auto const cameraPoseEst_timestamp = HootReplay :: GetValue < units :: second_t > ( \"CameraPoseEst/timestamp\" ); if ( cameraPoseEst_pose . status . IsOK () && cameraPoseEst_timestamp . status . IsOK () ) { cameraPoseEst = PoseEstimate {}; cameraPoseEst . pose = frc :: Pose2d { cameraPoseEst_pose . value [ 0 ] * 1 _m , cameraPoseEst_pose . value [ 1 ] * 1 _m , frc :: Rotation2d { cameraPoseEst_pose . value [ 2 ] * 1 _deg } }; cameraPoseEst . timestamp = cameraPoseEst_timestamp . value ; } } public : void Periodic () { if ( utils :: IsReplay ()) { FetchInputsReplay (); } else { FetchInputs (); } // process inputs here... } Python def _fetch_inputs_replay ( self ): # pull out inputs from the log camera_pose_est_pose = HootReplay . get_double_array ( \"CameraPoseEst/pose\" ) camera_pose_est_timestamp = HootReplay . get_double ( \"CameraPoseEst/timestamp\" ) if ( camera_pose_est_pose . status . is_ok () and camera_pose_est_timestamp . status . is_ok () ): self . _camera_pose_est = PoseEstimate () self . _camera_pose_est . pose = [ camera_pose_est_pose . value [ 0 ], camera_pose_est_pose . value [ 1 ], Rotation2d . fromDegrees ( camera_pose_est_pose . value [ 2 ]) ] self . _camera_pose_est . timestamp = camera_pose_est_timestamp . value def periodic ( self ): if Utils . is_replay (): self . _fetch_inputs_replay () else : self . _fetch_inputs () # process inputs here...",
      "content_preview": "Hoot Replay Note Information on logging to hoot files can be found in Signal Logging . Hoot Replay allows users to playback hoot logs in their robot program. This allows for testing changes to robot code in simulation using measurements recorded from the real robot."
    },
    {
      "url": "https://v6.docs.ctr-electronics.com/en/stable/docs/api-reference/simulation/simulation-intro.html",
      "title": "Introduction to Simulation",
      "section": "API Reference",
      "language": "All",
      "content": "Introduction to Simulation Many CTR Electronics devices support high-fidelity simulation, allowing the simulated robot to match the behavior of the real robot hardware as closely as possible. This makes simulation a powerful tool to quickly diagnose and fix bugs in robot code without relying on access to hardware. Supported Devices Currently, all Phoenix 6 devices are supported in simulation. Warning Multiple CAN buses using the CANivore API is not supported at this time. All CAN devices will appear on the same CAN bus . If you wish to run your robot code in simulation, ensure devices have unique IDs across CAN buses . Simulation API Each supported device has a device-specific SimState object that can be used to manage I/O with the simulated device. The object can be retrieved by calling getSimState() on an instance of a device. Java var talonFXSim = m_talonFX . getSimState (); C++ auto & talonFXSim = m_talonFX . GetSimState (); Python talon_fx_sim = self . talon_fx . sim_state Note Phoenix 6 utilizes the Java units library and C++ units library when applicable. In general, simulation logic should only interact with the SimState class and the physics simulator (such as WPILib’s DCMotorSim ), and the rest of the robot code should never interact with those simulation classes. This clear separation between simulation and hardware logic ensures that simulation most accurately reflects the behavior of the real robot hardware. Orientation The SimState API ignores typical device invert settings, as the user may change invert for any reason (such as flipping which direction is forward for a drivebase). As a result, for some devices, the SimState object supports specifying the orientation of the device relative to the robot chassis ( Java , C++ , Python ). This orientation represents the mechanical linkage between the device and the robot chassis. It should not be changed with runtime invert , as runtime invert specifies the logical orientation of the device. Rather, the orientation should only be modified when the mechanical linkage itself changes , such as when switching between two gearboxes inverted from each other. Java var leftTalonFXSim = m_leftTalonFX . getSimState (); var rightTalonFXSim = m_rightTalonFX . getSimState (); // left drivetrain motors are typically CCW+ leftTalonFXSim . Orientation = ChassisReference . CounterClockwise_Positive ; // right drivetrain motors are typically CW+ rightTalonFXSim . Orientation = ChassisReference . Clockwise_Positive ; C++ auto & leftTalonFXSim = m_leftTalonFX . GetSimState (); auto & rightTalonFXSim = m_rightTalonFX . GetSimState (); // left drivetrain motors are typically CCW+ leftTalonFXSim . Orientation = sim :: ChassisReference :: CounterClockwise_Positive ; // right drivetrain motors are typically CW+ rightTalonFXSim . Orientation = sim :: ChassisReference :: Clockwise_Positive ; Python left_talon_fx_sim = self . left_talon_fx . sim_state right_talon_fx_sim = self . right_talon_fx . sim_state # left drivetrain motors are typically CCW+ left_talon_fx_sim . orientation = sim . ChassisReference . CounterClockwise_Positive # right drivetrain motors are typically CW+ right_talon_fx_sim . orientation = sim . ChassisReference . Clockwise_Positive Inputs and Outputs All SimState objects contain multiple inputs to manipulate the state of the device based on simulation physics calculations. For example, all device SimState objects have a supply voltage input: Important Non-FRC platforms are required to set supply voltage, as it affects simulation calculations. It’s recommended that FRC users set supply voltage to RobotController.getBatteryVoltage() ( Java , C++ ) to take advantage of WPILib’s BatterySim ( Java , C++ ) API. Java // set the supply voltage of the TalonFX to 12 V m_talonFXSim . setSupplyVoltage ( Volts . of ( 12 )); C++ // set the supply voltage of the TalonFX to 12 V m_talonFXSim . SetSupplyVoltage ( 12 _V ); Python # set the supply voltage of the TalonFX to 12 V self . talon_fx_sim . set_supply_voltage ( 12.0 ) Some device SimState objects also contain outputs that can be used in simulation physics calculations. For example, the TalonFXSimState ( Java , C++ , Python ) object has a motor voltage output that can be used to calculate position and velocity: Important For all motor controllers, the RawRotorPosition and RotorVelocity values must be set for simulated PID and current limits to behave correctly. Additionally, simulated PID more closely matches hardware when updating the SimState more frequently, such as using a WPILib Notifier . Java private static final double kGearRatio = 10.0 ; private final DCMotorSim m_motorSimModel = new DCMotorSim ( LinearSystemId . createDCMotorSystem ( DCMotor . getKrakenX60Foc ( 1 ), 0.001 , kGearRatio ) DCMotor . getKrakenX60Foc ( 1 ) ); public void simulationPeriodic () { var talonFXSim = m_talonFX . getSimState (); // set the supply voltage of the TalonFX talonFXSim . setSupplyVoltage ( RobotController . getBatteryVoltage ()); // get the motor voltage of the TalonFX var motorVoltage = talonFXSim . getMotorVoltageMeasure (); // use the motor voltage to calculate new position and velocity // using WPILib's DCMotorSim class for physics simulation m_motorSimModel . setInputVoltage ( motorVoltage . in ( Volts )); m_motorSimModel . update ( 0.020 ); // assume 20 ms loop time // apply the new rotor position and velocity to the TalonFX; // note that this is rotor position/velocity (before gear ratio), but // DCMotorSim returns mechanism position/velocity (after gear ratio) talonFXSim . setRawRotorPosition ( m_motorSimModel . getAngularPosition (). times ( kGearRatio )); talonFXSim . setRotorVelocity ( m_motorSimModel . getAngularVelocity (). times ( kGearRatio )); } C++ static constexpr double kGearRatio = 10.0 ; frc :: sim :: DCMotorSim m_motorSimModel { frc :: LinearSystemId :: DCMotorSystem { frc :: DCMotor :: KrakenX60FOC ( 1 ), 0.001 _kg_sq_m , kGearRatio }, frc :: DCMotor :: KrakenX60FOC ( 1 ) }; void SimulationPeriodic () { auto & talonFXSim = m_talonFX . GetSimState (); // set the supply voltage of the TalonFX talonFXSim . SetSupplyVoltage ( frc :: RobotController :: GetBatteryVoltage ()); // get the motor voltage of the TalonFX auto motorVoltage = talonFXSim . GetMotorVoltage (); // use the motor voltage to calculate new position and velocity // using WPILib's DCMotorSim class for physics simulation m_motorSimModel . SetInputVoltage ( motorVoltage ); m_motorSimModel . Update ( 20 _ms ); // assume 20 ms loop time // apply the new rotor position and velocity to the TalonFX; // note that this is rotor position/velocity (before gear ratio), but // DCMotorSim returns mechanism position/velocity (after gear ratio) talonFXSim . SetRawRotorPosition ( kGearRatio * m_motorSimModel . GetAngularPosition ()); talonFXSim . SetRotorVelocity ( kGearRatio * m_motorSimModel . GetAngularVelocity ()); } Python GEAR_RATIO = 10.0 def __init__ ( self ): gearbox = DCMotor . krakenX60FOC ( 1 ) self . motor_sim_model = DCMotorSim ( LinearSystemId . DCMotorSystem ( gearbox , 0.001 , GEAR_RATIO ), gearbox ) def simulationPeriodic ( self ): talon_fx_sim = self . talon_fx . sim_state # set the supply voltage of the TalonFX talon_fx_sim . set_supply_voltage ( RobotControllergetBatteryVoltage ()) # get the motor voltage of the TalonFX motor_voltage = talon_fx_sim . motor_voltage # use the motor voltage to calculate new position and velocity # using WPILib's DCMotorSim class for physics simulation self . motor_sim_model . setInputVoltage ( motor_voltage ) self . motor_sim_model . update ( 0.020 ) # assume 20 ms loop time # apply the new rotor position and velocity to the TalonFX; # note that this is rotor position/velocity (before gear ratio), but # DCMotorSim returns mechanism position/velocity (after gear ratio) talon_fx_sim . set_raw_rotor_position ( GEAR_RATIO * units . radiansToRotations ( self . motor_sim_model . getAngularPosition ()) ) talon_fx_sim . set_rotor_velocity ( GEAR_RATIO * units . radiansToRotations ( self . motor_sim_model . getAngularVelocity ()) ) High Fidelity CAN Bus Simulation As a part of high-fidelity simulation, the influence of the CAN bus is simulated at a level similar to what happens on a real robot. This means that the timing behavior of control and status signals in simulation will align to the same framing intervals seen on a real CAN bus. In simulation, this may appear as a delay between setting a signal and getting its real value, or between setting its real value and getting it in API. In unit tests, it may be useful to increase the update rate of status signals to avoid erroneous failures and minimize delays. The update rate can be modified for simulation by wrapping the signal update frequency in a Utils.isSimulation() ( Java , C++ , Python ) condition. Java if ( Utils . isSimulation ()) { // set update rate to 1ms for unit tests m_velocitySignal . setUpdateFrequency ( Hertz . of ( 1000 )); } C++ if ( utils :: IsSimulation ()) { // set update rate to 1ms for unit tests m_velocitySignal . SetUpdateFrequency ( 1000 _Hz ); } Python if utils . is_simulation (): # set update rate to 1ms for unit tests self . velocity_signal . set_update_frequency ( 1000.0 )",
      "content_preview": "Introduction to Simulation Many CTR Electronics devices support high-fidelity simulation, allowing the simulated robot to match the behavior of the real robot hardware as closely as possible."
    },
    {
      "url": "https://v6.docs.ctr-electronics.com/en/stable/docs/canivore/canivore-config.html",
      "title": "Advanced Configuration",
      "section": "CANivore",
      "language": "All",
      "content": "Advanced Configuration The CANivore provides additional configuration options for advanced users. CAN Bus Termination The CANivore has a 120 \\(\\Omega\\) programmable resister for terminating the CAN bus. The resistor can be configured using the CAN Bus Termination toggle in the CANivore device card in Phoenix Tuner X. Warning A CAN bus requires two termination resistors, one at each extreme end. If only one is present, communication over CAN may fail. caniv - CANivore CLI caniv is a Command-line Interface (CLI) to interact with CANivores outside of Phoenix Tuner X. Note Unlike the CANivores page in Phoenix Tuner X, caniv does not require a running Phoenix Diagnostic Server. On Linux systems (including the roboRIO), caniv can be found at /usr/local/bin . On Windows systems, the program is in the Phoenix Tuner X application cache directory, which can be opened by opening the Diagnostic Log page and clicking the left folder icon in the top right: To view a list of available commands, run caniv either with no parameters or with --help .",
      "content_preview": "Advanced Configuration The CANivore provides additional configuration options for advanced users. CAN Bus Termination The CANivore has a 120 \\(\\Omega\\) programmable resister for terminating the CAN bus."
    },
    {
      "url": "https://v6.docs.ctr-electronics.com/en/stable/docs/hardware-reference/candle/index.html",
      "title": "CANdle®",
      "section": "General",
      "language": "All",
      "content": "CANdle® The CTR Electronics’ CANdle® branded device makes it easy to control individually addressable LEDs over CAN. Combined with being a 5V high-efficiency DC voltage regulator, the CANdle® is a versatile addition to any robot. Store Page CAD and purchase instructions. https://store.ctr-electronics.com/products/candle Blink Codes Animation (Click to play) LED State Cause Possible Fix LEDs Off No power, or the StatusLedWhenActive config is set to Disabled. If you cannot communicate with the CANdle® and all LEDs are off, validate 12V on the Red/Black (+Vin/-Vin) leads. Blinking Red CANdle® does not have valid CAN or Pixel pulse train [1]. Ensure good connections between CANH and CANL (Yellow and Green) and the CAN bus or Pixel pulse train [1], and robot controller is on. Blinking Orange CANdle® has a good CAN or Pixel pulse train [1] connection but is not being controlled. If the robot program is trying to control the CANdle®, ensure good connection between the controller and this device. Blinking Green CANdle® has a good CAN or Pixel pulse train [1] connection and is being actively controlled. Rapid Red 5V too high fault. Check for a short between +Vout and 5V out. Blip Red Short circuit or software fuse fault. Use Tuner X to determine which fault is active. Check for shorts across the output leads, and reduce the current load on the CANdle® (max 6 A). Blip Orange Thermal fault. Allow CANdle® to cool. Consider disabling the onboard LEDs or reducing the current load on the CANdle®. Alternate Red/Orange Damaged Hardware. Use Tuner X Self Test to confirm the LEDs and that the hardware fault is set, then contact CTRE Alternate Orange/Green CANdle® in bootloader. Field-upgrade device in Tuner X. [1] CANdle can be directly controlled using a WS2812B-compliant pulse train from other devices, such as an Arduino. See the User’s Guide for more information.",
      "content_preview": "CANdle® The CTR Electronics’ CANdle® branded device makes it easy to control individually addressable LEDs over CAN. Combined with being a 5V high-efficiency DC voltage regulator, the CANdle® is a versatile addition to any robot. Store Page CAD and purchase instructions."
    },
    {
      "url": "https://v6.docs.ctr-electronics.com/en/stable/docs/migration/migration-guide/closed-loop-guide.html",
      "title": "Closed",
      "section": "General",
      "language": "All",
      "content": "Closed-Loop Control Phoenix 6 enhances the experience of using onboard closed-loop control through the use of standardized units and a variety of control output types. Note For more information about closed-loop control in Phoenix 6, see Closed-Loop Overview . Closed-Loop Setpoints Phoenix 6 uses canonical units for closed-loop setpoints. Note This calculator assumes the RotorToSensorRatio and SensorToMechanismRatio configs are both set to 1. If this is not the case in your robot program, divide the resulting values by both ratios. Setpoint Conversion Name Value Units Formula Position Original \\(\\mathrm{raw\\_units}\\) \\(x_{\\mathrm{old}}\\) New \\(\\mathrm{rotations}\\) \\(x_{\\mathrm{new}}=x_{\\mathrm{old}} \\cdot \\frac{1}{2048} \\frac{\\mathrm{rot}}{\\mathrm{raw\\_unit}}\\) Velocity Original \\(\\frac{\\mathrm{raw\\_units}}{\\mathrm{100ms}}\\) \\(v_{\\mathrm{old}}\\) New \\(\\frac{\\mathrm{rot}}{\\mathrm{second}}\\) \\(v_{\\mathrm{new}}=v_{\\mathrm{old}} \\cdot \\frac{1}{2048} \\frac{\\mathrm{rot}}{\\mathrm{raw\\_unit}} \\cdot 10 \\frac{\\mathrm{100ms}}{\\mathrm{second}} \\) Acceleration Original \\(\\frac{\\mathrm{raw\\_units}}{\\mathrm{100ms} \\cdot \\mathrm{second}}\\) \\(a_{\\mathrm{old}}\\) New \\(\\frac{\\mathrm{rot}}{\\mathrm{second}^2}\\) \\(a_{\\mathrm{new}}=a_{\\mathrm{old}} \\cdot \\frac{1}{2048} \\frac{\\mathrm{rot}}{\\mathrm{raw\\_unit}} \\cdot 10 \\frac{\\mathrm{100ms}}{\\mathrm{second}} \\) Closed-Loop Gains Position without Voltage Comp Phoenix 5 ControlMode.Position with voltage compensation disabled maps to the Phoenix 6 PositionDutyCycle control request. Note This calculator assumes the RotorToSensorRatio and SensorToMechanismRatio configs are both set to 1. If this is not the case in your robot program, multiply the resulting gains by both ratios. Position without Voltage Compensation Name Value Units Formula kP Original \\(\\frac{\\mathrm{raw\\_output}}{\\mathrm{unit}}\\) \\(kP_{\\mathrm{old}}\\) New \\(\\frac{\\mathrm{duty\\_cycle}}{\\mathrm{rot}}\\) \\(kP_{\\mathrm{new}}=kP_{\\mathrm{old}} \\cdot 2048 \\frac{\\mathrm{unit}}{\\mathrm{rot}} \\cdot \\frac{1}{1023} \\frac{\\mathrm{duty\\_cycle}}{\\mathrm{raw\\_output}}\\) kI Original \\(\\frac{\\mathrm{raw\\_output}}{\\mathrm{unit} \\cdot \\mathrm{millisecond}}\\) \\(kI_{\\mathrm{old}}\\) New \\(\\frac{\\mathrm{duty\\_cycle}}{\\mathrm{rot} \\cdot \\mathrm{second}}\\) \\(kI_{\\mathrm{new}}=kI_{\\mathrm{old}} \\cdot 2048 \\frac{\\mathrm{unit}}{\\mathrm{rot}} \\cdot \\frac{1}{1023} \\frac{\\mathrm{duty\\_cycle}}{\\mathrm{raw\\_output}} \\cdot 1000 \\frac{\\mathrm{millisecond}}{\\mathrm{second}}\\) kD Original \\(\\frac{\\mathrm{raw\\_output}}{\\mathrm{unit} / \\mathrm{millisecond}}\\) \\(kD_{\\mathrm{old}}\\) New \\(\\frac{\\mathrm{duty\\_cycle}}{\\mathrm{rot} / \\mathrm{second}}\\) \\(kD_{\\mathrm{new}}=kD_{\\mathrm{old}} \\cdot 2048 \\frac{\\mathrm{unit}}{\\mathrm{rot}} \\cdot \\frac{1}{1023} \\frac{\\mathrm{duty\\_cycle}}{\\mathrm{raw\\_output}} \\cdot \\frac{1}{1000} \\frac{\\mathrm{second}}{\\mathrm{millisecond}}\\) Position with Voltage Comp Phoenix 5 ControlMode.Position with voltage compensation enabled has been replaced with the Phoenix 6 PositionVoltage control request, which directly controls voltage. Note This calculator assumes the RotorToSensorRatio and SensorToMechanismRatio configs are both set to 1. If this is not the case in your robot program, multiply the resulting gains by both ratios. Position with Voltage Compensation Voltage Compensation Value: Name Value Units Formula kP Original \\(\\frac{\\mathrm{\\mathrm{raw\\_output}}}{\\mathrm{unit}}\\) \\(kP_{\\mathrm{old}}\\) New \\(\\frac{\\mathrm{V}}{\\mathrm{rot}}\\) \\(kP_{\\mathrm{new}}=kP_{\\mathrm{old}} \\cdot 2048 \\frac{\\mathrm{unit}}{\\mathrm{rot}} \\cdot \\frac{1}{1023} \\frac{\\mathrm{duty\\_cycle}}{\\mathrm{raw\\_output}} \\cdot \\mathrm{V\\_comp} \\frac{\\mathrm{V}}{\\mathrm{duty\\_cycle}}\\) kI Original \\(\\frac{\\mathrm{\\mathrm{raw\\_output}}}{\\mathrm{unit} \\cdot \\mathrm{millisecond}}\\) \\(kI_{\\mathrm{old}}\\) New \\(\\frac{\\mathrm{V}}{\\mathrm{rot} \\cdot \\mathrm{second}}\\) \\(kI_{\\mathrm{new}}=kI_{\\mathrm{old}} \\cdot 2048 \\frac{\\mathrm{unit}}{\\mathrm{rot}} \\cdot \\frac{1}{1023} \\frac{\\mathrm{duty\\_cycle}}{\\mathrm{raw\\_output}} \\cdot 1000 \\frac{\\mathrm{millisecond}}{\\mathrm{second}} \\cdot \\mathrm{V\\_comp} \\frac{\\mathrm{V}}{\\mathrm{duty\\_cycle}}\\) kD Original \\(\\frac{\\mathrm{\\mathrm{raw\\_output}}}{\\mathrm{unit} / \\mathrm{millisecond}}\\) \\(kD_{\\mathrm{old}}\\) New \\(\\frac{\\mathrm{V}}{\\mathrm{rot} / \\mathrm{second}}\\) \\(kD_{\\mathrm{new}}=kD_{\\mathrm{old}} \\cdot 2048 \\frac{\\mathrm{unit}}{\\mathrm{rot}} \\cdot \\frac{1}{1023} \\frac{\\mathrm{duty\\_cycle}}{\\mathrm{raw\\_output}} \\cdot \\frac{1}{1000} \\frac{\\mathrm{second}}{\\mathrm{millisecond}} \\cdot \\mathrm{V\\_comp} \\frac{\\mathrm{V}}{\\mathrm{duty\\_cycle}}\\) Velocity without Voltage Comp Phoenix 5 ControlMode.Velocity with voltage compensation disabled maps to the Phoenix 6 VelocityDutyCycle control request. Additionally, kF from Phoenix 5 has been replaced with kV in Phoenix 6. Note This calculator assumes the RotorToSensorRatio and SensorToMechanismRatio configs are both set to 1. If this is not the case in your robot program, multiply the resulting gains by both ratios. Velocity without Voltage Compensation Name Value Units Formula kP Original \\(\\frac{\\mathrm{raw\\_output}}{\\mathrm{unit} / \\mathrm{100ms}}\\) \\(kP_{\\mathrm{old}}\\) New \\(\\frac{\\mathrm{duty\\_cycle}}{\\mathrm{rot} / \\mathrm{sec}}\\) \\(kP_{\\mathrm{new}}=kP_{\\mathrm{old}} \\cdot 2048 \\frac{\\mathrm{unit}}{\\mathrm{rot}} \\cdot \\frac{1}{1023} \\frac{\\mathrm{duty\\_cycle}}{\\mathrm{raw\\_output}} \\cdot \\frac{1}{10} \\frac{\\mathrm{sec}}{\\mathrm{100ms}}\\) kI Original \\(\\frac{\\mathrm{raw\\_output}}{(\\mathrm{unit} / \\mathrm{100ms}) \\cdot \\mathrm{millisecond}}\\) \\(kI_{\\mathrm{old}}\\) New \\(\\frac{\\mathrm{duty\\_cycle}}{\\mathrm{rot}}\\) \\(kI_{\\mathrm{new}}=kI_{\\mathrm{old}} \\cdot 2048 \\frac{\\mathrm{unit}}{\\mathrm{rot}} \\cdot \\frac{1}{1023} \\frac{\\mathrm{duty\\_cycle}}{\\mathrm{raw\\_output}} \\cdot 1000 \\frac{\\mathrm{millisecond}}{\\mathrm{second}} \\cdot \\frac{1}{10} \\frac{\\mathrm{sec}}{\\mathrm{100ms}}\\) kD Original \\(\\frac{\\mathrm{raw\\_output}}{(\\mathrm{unit} / \\mathrm{100ms}) / \\mathrm{millisecond}}\\) \\(kD_{\\mathrm{old}}\\) New \\(\\frac{\\mathrm{duty\\_cycle}}{\\mathrm{rot} / \\mathrm{second}^{2}}\\) \\(kD_{\\mathrm{new}}=kD_{\\mathrm{old}} \\cdot 2048 \\frac{\\mathrm{unit}}{\\mathrm{rot}} \\cdot \\frac{1}{1023} \\frac{\\mathrm{duty\\_cycle}}{\\mathrm{raw\\_output}} \\cdot \\frac{1}{1000} \\frac{\\mathrm{second}}{\\mathrm{millisecond}} \\cdot \\frac{1}{10} \\frac{\\mathrm{sec}}{\\mathrm{100ms}}\\) kF kV Original \\(\\frac{\\mathrm{raw\\_output}}{\\mathrm{unit} / \\mathrm{100millisecond}}\\) \\(kF_{\\mathrm{old}}\\) New \\(\\frac{\\mathrm{duty\\_cycle}}{\\mathrm{rot} / \\mathrm{second}}\\) \\(kV_{\\mathrm{new}}=kF_{\\mathrm{old}} \\cdot 2048 \\frac{\\mathrm{unit}}{\\mathrm{rot}} \\cdot \\frac{1}{1023} \\frac{\\mathrm{duty\\_cycle}}{\\mathrm{raw\\_output}} \\cdot \\frac{1}{10} \\frac{\\mathrm{second}}{\\mathrm{100ms}}\\) Velocity with Voltage Comp Phoenix 5 ControlMode.Velocity with voltage compensation enabled has been replaced with the Phoenix 6 VelocityVoltage control request, which directly controls voltage. Additionally, kF from Phoenix 5 has been replaced with kV in Phoenix 6. Note This calculator assumes the RotorToSensorRatio and SensorToMechanismRatio configs are both set to 1. If this is not the case in your robot program, multiply the resulting gains by both ratios. Velocity with Voltage Compensation Voltage Compensation Value: Name Value Units Formula kP Original \\(\\frac{\\mathrm{\\mathrm{raw\\_output}}}{\\mathrm{unit} / \\mathrm{100ms}}\\) \\(kP_{\\mathrm{old}}\\) New \\(\\frac{\\mathrm{V}}{\\mathrm{rot} / \\mathrm{sec}}\\) \\(kP_{\\mathrm{new}}=kP_{\\mathrm{old}} \\cdot 2048 \\frac{\\mathrm{unit}}{\\mathrm{rot}} \\cdot \\frac{1}{1023} \\frac{\\mathrm{duty\\_cycle}}{\\mathrm{raw\\_output}} \\cdot \\frac{1}{10} \\frac{\\mathrm{second}}{\\mathrm{100ms}} \\cdot \\mathrm{V\\_comp} \\frac{\\mathrm{V}}{\\mathrm{duty\\_cycle}}\\) kI Original \\(\\frac{\\mathrm{\\mathrm{raw\\_output}}}{(\\mathrm{unit} / \\mathrm{100ms}) \\cdot \\mathrm{millisecond}}\\) \\(kI_{\\mathrm{old}}\\) New \\(\\frac{\\mathrm{V}}{\\mathrm{rot}}\\) \\(kI_{\\mathrm{new}}=kI_{\\mathrm{old}} \\cdot 2048 \\frac{\\mathrm{unit}}{\\mathrm{rot}} \\cdot \\frac{1}{1023} \\frac{\\mathrm{duty\\_cycle}}{\\mathrm{raw\\_output}} \\cdot 1000 \\frac{\\mathrm{millisecond}}{\\mathrm{second}} \\cdot \\frac{1}{10} \\frac{\\mathrm{second}}{\\mathrm{100ms}} \\cdot \\mathrm{V\\_comp} \\frac{\\mathrm{V}}{\\mathrm{duty\\_cycle}}\\) kD Original \\(\\frac{\\mathrm{\\mathrm{raw\\_output}}}{(\\mathrm{unit} / \\mathrm{100ms}) / \\mathrm{millisecond}}\\) \\(kD_{\\mathrm{old}}\\) New \\(\\frac{\\mathrm{V}}{\\mathrm{rot} / \\mathrm{second}^{2}}\\) \\(kD_{\\mathrm{new}}=kD_{\\mathrm{old}} \\cdot 2048 \\frac{\\mathrm{unit}}{\\mathrm{rot}} \\cdot \\frac{1}{1023} \\frac{\\mathrm{duty\\_cycle}}{\\mathrm{raw\\_output}} \\cdot \\frac{1}{1000} \\frac{\\mathrm{second}}{\\mathrm{millisecond}} \\cdot \\frac{1}{10} \\frac{\\mathrm{second}}{\\mathrm{100ms}} \\cdot \\mathrm{V\\_comp} \\frac{\\mathrm{V}}{\\mathrm{duty\\_cycle}}\\) kF kV Original \\(\\frac{\\mathrm{\\mathrm{raw\\_output}}}{\\mathrm{unit} / \\mathrm{100ms}}\\) \\(kF_{\\mathrm{old}}\\) New \\(\\frac{\\mathrm{V}}{\\mathrm{rot} / \\mathrm{second}}\\) \\(kV_{\\mathrm{new}}=kF_{\\mathrm{old}} \\cdot 2048 \\frac{\\mathrm{unit}}{\\mathrm{rot}} \\cdot \\frac{1}{1023} \\frac{\\mathrm{duty\\_cycle}}{\\mathrm{raw\\_output}} \\cdot \\frac{1}{10} \\frac{\\mathrm{second}}{\\mathrm{100ms}} \\cdot \\mathrm{V\\_comp} \\frac{\\mathrm{V}}{\\mathrm{duty\\_cycle}}\\) Using Closed-Loop Control v5 Java // robot init, set slot 0 gains m_motor . config_kF ( 0 , 0.05 , 50 ); m_motor . config_kP ( 0 , 0.046 , 50 ); m_motor . config_kI ( 0 , 0.0002 , 50 ); m_motor . config_kD ( 0 , 4.2 , 50 ); // enable voltage compensation m_motor . configVoltageComSaturation ( 12 ); m_motor . enableVoltageCompensation ( true ); // periodic, run velocity control with slot 0 configs, // target velocity of 50 rps (10240 ticks/100ms) m_motor . selectProfileSlot ( 0 , 0 ); m_motor . set ( ControlMode . Velocity , 10240 ); C++ // robot init, set slot 0 gains m_motor . Config_kF ( 0 , 0.05 , 50 ); m_motor . Config_kP ( 0 , 0.046 , 50 ); m_motor . Config_kI ( 0 , 0.0002 , 50 ); m_motor . Config_kD ( 0 , 4.2 , 50 ); // enable voltage compensation m_motor . ConfigVoltageComSaturation ( 12 ); m_motor . EnableVoltageCompensation ( true ); // periodic, run velocity control with slot 0 configs, // target velocity of 50 rps (10240 ticks/100ms) m_motor . SelectProfileSlot ( 0 , 0 ); m_motor . Set ( ControlMode :: Velocity , 10240 ); v6 Java // class member variable final VelocityVoltage m_velocity = new VelocityVoltage ( 0 ); // robot init, set slot 0 gains var slot0Configs = new Slot0Configs (); slot0Configs . kV = 0.12 ; slot0Configs . kP = 0.11 ; slot0Configs . kI = 0.48 ; slot0Configs . kD = 0.01 ; m_talonFX . getConfigurator (). apply ( slot0Configs , 0.050 ); // periodic, run velocity control with slot 0 configs, // target velocity of 50 rps m_velocity . Slot = 0 ; m_motor . setControl ( m_velocity . withVelocity ( 50 )); C++ // class member variable controls :: VelocityVoltage m_velocity { 0 _tps }; // robot init, set slot 0 gains configs :: Slot0Configs slot0Configs {}; slot0Configs . kV = 0.12 ; slot0Configs . kP = 0.11 ; slot0Configs . kI = 0.48 ; slot0Configs . kD = 0.01 ; m_talonFX . GetConfigurator (). Apply ( slot0Configs , 50 _ms ); // periodic, run velocity control with slot 0 configs, // target velocity of 50 rps m_velocity . Slot = 0 ; m_motor . SetControl ( m_velocity . WithVelocity ( 50 _tps )); Motion Magic® v5 Java // robot init, set slot 0 gains m_motor . config_kF ( 0 , 0.05 , 50 ); // PID runs on position m_motor . config_kP ( 0 , 0.2 , 50 ); m_motor . config_kI ( 0 , 0 , 50 ); m_motor . config_kD ( 0 , 4.2 , 50 ); // set Motion Magic settings m_motor . configMotionCruiseVelocity ( 16384 ); // 80 rps = 16384 ticks/100ms cruise velocity m_motor . configMotionAcceleration ( 32768 ); // 160 rps/s = 32768 ticks/100ms/s acceleration m_motor . configMotionSCurveStrength ( 3 ); // s-curve smoothing strength of 3 // enable voltage compensation m_motor . configVoltageComSaturation ( 12 ); m_motor . enableVoltageCompensation ( true ); // periodic, run Motion Magic with slot 0 configs m_motor . selectProfileSlot ( 0 , 0 ); // target position of 200 rotations (409600 ticks) // add 0.02 (2%) arbitrary feedforward to overcome friction m_motor . set ( ControlMode . MotionMagic , 409600 , DemandType . ArbitraryFeedforward , 0.02 ); C++ // robot init, set slot 0 gains m_motor . Config_kF ( 0 , 0.05 , 50 ); // PID runs on position m_motor . Config_kP ( 0 , 0.2 , 50 ); m_motor . Config_kI ( 0 , 0 , 50 ); m_motor . Config_kD ( 0 , 4.2 , 50 ); // set Motion Magic settings m_motor . ConfigMotionCruiseVelocity ( 16384 ); // 80 rps = 16384 ticks/100ms cruise velocity m_motor . ConfigMotionAcceleration ( 32768 ); // 160 rps/s = 32768 ticks/100ms/s acceleration m_motor . ConfigMotionSCurveStrength ( 3 ); // s-curve smoothing strength of 3 // enable voltage compensation m_motor . ConfigVoltageComSaturation ( 12 ); m_motor . EnableVoltageCompensation ( true ); // periodic, run Motion Magic with slot 0 configs m_motor . SelectProfileSlot ( 0 , 0 ); // target position of 200 rotations (409600 ticks) // add 0.02 (2%) arbitrary feedforward to overcome friction m_motor . Set ( ControlMode :: MotionMagic , 409600 , DemandType :: ArbitraryFeedforward , 0.02 ); v6 Note The Motion Magic® S-Curve Strength has been replaced with jerk control in Phoenix 6. Java // class member variable final MotionMagicVoltage m_motmag = new MotionMagicVoltage ( 0 ); // robot init var talonFXConfigs = new TalonFXConfiguration (); // set slot 0 gains var slot0Configs = talonFXConfigs . Slot0Configs ; slot0Configs . kS = 0.24 ; // add 0.24 V to overcome friction slot0Configs . kV = 0.12 ; // apply 12 V for a target velocity of 100 rps // PID runs on position slot0Configs . kP = 4.8 ; slot0Configs . kI = 0 ; slot0Configs . kD = 0.1 ; // set Motion Magic settings var motionMagicConfigs = talonFXConfigs . MotionMagicConfigs ; motionMagicConfigs . MotionMagicCruiseVelocity = 80 ; // 80 rps cruise velocity motionMagicConfigs . MotionMagicAcceleration = 160 ; // 160 rps/s acceleration (0.5 seconds) motionMagicConfigs . MotionMagicJerk = 1600 ; // 1600 rps/s^2 jerk (0.1 seconds) m_talonFX . getConfigurator (). apply ( talonFXConfigs , 0.050 ); // periodic, run Motion Magic with slot 0 configs, // target position of 200 rotations m_motmag . Slot = 0 ; m_motor . setControl ( m_motmag . withPosition ( 200 )); C++ // class member variable controls :: MotionMagicVoltage m_motmag { 0 _tr }; // robot init configs :: TalonFXConfiguration talonFXConfigs {}; // set slot 0 gains auto & slot0Configs = talonFXConfigs . Slot0Configs ; slot0Configs . kS = 0.24 ; // add 0.24 V to overcome friction slot0Configs . kV = 0.12 ; // apply 12 V for a target velocity of 100 rps // PID runs on position slot0Configs . kP = 4.8 ; slot0Configs . kI = 0 ; slot0Configs . kD = 0.1 ; // set Motion Magic settings auto & motionMagicConfigs = talonFXConfigs . MotionMagicConfigs ; motionMagicConfigs . MotionMagicCruiseVelocity = 80 ; // 80 rps cruise velocity motionMagicConfigs . MotionMagicAcceleration = 160 ; // 160 rps/s acceleration (0.5 seconds) motionMagicConfigs . MotionMagicJerk = 1600 ; // 1600 rps/s^2 jerk (0.1 seconds) m_talonFX . GetConfigurator (). Apply ( talonFXConfigs , 50 _ms ); // periodic, run Motion Magic with slot 0 configs, // target position of 200 rotations m_motmag . Slot = 0 ; m_motor . SetControl ( m_motmag . WithPosition ( 200 _tr )); Motion Profiling Closed-loop control requests have been expanded to support motion profiles generated by the robot controller. Java // class member variable final PositionVoltage m_position = new PositionVoltage ( 0 ); // Trapezoid profile with max velocity 80 rps, max accel 160 rps/s final TrapezoidProfile m_profile = new TrapezoidProfile ( new TrapezoidProfile . Constraints ( 80 , 160 ) ); // Final target of 200 rot, 0 rps TrapezoidProfile . State m_goal = new TrapezoidProfile . State ( 200 , 0 ); TrapezoidProfile . State m_setpoint = new TrapezoidProfile . State (); // robot init, set slot 0 gains var slot0Configs = new Slot0Configs (); slot0Configs . kS = 0.24 ; // add 0.24 V to overcome friction slot0Configs . kV = 0.12 ; // apply 12 V for a target velocity of 100 rps slot0Configs . kP = 4.8 ; slot0Configs . kI = 0 ; slot0Configs . kD = 0.1 ; m_talonFX . getConfigurator (). apply ( Slot0Configs , 0.050 ); // periodic, update the profile setpoint for 20 ms loop time m_setpoint = m_profile . calculate ( 0.020 , m_setpoint , m_goal ); // apply the setpoint to the control request m_position . Position = m_setpoint . position ; m_position . Velocity = m_setpoint . velocity ; m_motor . setControl ( m_position ); C++ // class member variable controls :: PositionVoltage m_position { 0 _tr }; // Trapezoid profile with max velocity 80 rps, max accel 160 rps/s frc :: TrapezoidProfile < units :: turns > m_profile {{ 80 _tps , 160 _tr_per_s_sq }}; // Final target of 200 rot, 0 rps frc :: TrapezoidProfile < units :: turns >:: State m_goal { 200 _tr , 0 _tps }; frc :: TrapezoidProfile < units :: turns >:: State m_setpoint {}; // robot init, set slot 0 gains configs :: Slot0Configs slot0Configs {}; slot0Configs . kS = 0.24 ; // add 0.24 V to overcome friction slot0Configs . kV = 0.12 ; // apply 12 V for a target velocity of 100 rps slot0Configs . kP = 4.8 ; slot0Configs . kI = 0 ; slot0Configs . kD = 0.1 ; m_talonFX . GetConfigurator (). Apply ( slot0Configs , 50 _ms ); // periodic, update the profile setpoint for 20 ms loop time m_setpoint = m_profile . Calculate ( 20 _ms , m_setpoint , m_goal ); // apply the setpoint to the control request m_position . Position = m_setpoint . position ; m_position . Velocity = m_setpoint . velocity ; m_motor . SetControl ( m_position );",
      "content_preview": "Closed-Loop Control Phoenix 6 enhances the experience of using onboard closed-loop control through the use of standardized units and a variety of control output types. Note For more information about closed-loop control in Phoenix 6, see Closed-Loop Overview ."
    },
    {
      "url": "https://v6.docs.ctr-electronics.com/en/stable/docs/installation/installation-nonfrc.html",
      "title": "Installing Phoenix 6 (non",
      "section": "General",
      "language": "All",
      "content": "Installing Phoenix 6 (non-FRC) Important Users in FRC can skip this article. Phoenix 6 is fully supported outside of FRC on supported systems with a USB to CAN adapter. Note CANivore is the recommended USB to CAN adapter with support for CAN FD , name specification, and Windows (as host). Installation Installation is composed of a few primary pieces. Users may skip CANivore installation if they are using a generic USB-to-CAN adapter. Installing the Phoenix APT Repository (Optional) CANivore Installation API Installation Installing the Phoenix APT Repository Phoenix 6 is distributed through our APT repository. Begin with adding the repository to your APT sources. YEAR = <year> sudo curl -s --compressed -o /usr/share/keyrings/ctr-pubkey.gpg \"https://deb.ctr-electronics.com/ctr-pubkey.gpg\" sudo curl -s --compressed -o /etc/apt/sources.list.d/ctr ${ YEAR } .list \"https://deb.ctr-electronics.com/ctr ${ YEAR } .list\" Note <year> should be replaced with the year of Phoenix 6 software for which you have purchased licenses. Open /etc/apt/sources.list.d/ctr${YEAR}.list with an editor of your choice. sudo nano /etc/apt/sources.list.d/ctr ${ YEAR } .list In the tools entry, replace stable with the distribution you want to use. # APT repo for CTR tools, including canivore-usb deb [ signed-by = /usr/share/keyrings/ctr-pubkey.gpg ] https://deb.ctr-electronics.com/tools stable main For example. Raspberry Pi would look like: # APT repo for CTR tools, including canivore-usb deb [ signed-by = /usr/share/keyrings/ctr-pubkey.gpg ] https://deb.ctr-electronics.com/tools raspberrypi main Available distributions can be found in the dropdown below. Modifying .list Distribution System <dist> Raspberry Pi raspberrypi NVIDIA Jetson jetson Other Linux systems (default) stable Warning Do not modify the distribution of the libs/<year> entry in the .list file. CANivore Installation On non-FRC Linux systems, the canivore-usb kernel module must be installed to add SocketCAN support for the CANivore. The kernel module is distributed through our APT repository. Note Custom bit rates and CAN 2.0 are not supported at this time. The parameters passed into SocketCAN are not applied by the firmware. Raspberry Pi Warning Raspberry Pi 4 with 32-bit OS require additional instructions. See Raspberry Pi Errata for more information. Install the Raspberry Pi kernel headers. sudo apt install raspberrypi-kernel-headers Update APT and install canivore-usb sudo apt update sudo apt install canivore - usb - y Other Supported Distributions Update APT and install canivore-usb . sudo apt update sudo apt install canivore-usb Tip To get a robot application up and running quickly, check out our non-FRC Linux example . API Installation C++ (Linux) Phoenix 6 can be installed and updated using the following: sudo apt update sudo apt install phoenix6 Tip To get a robot application up and running quickly, check out our non-FRC Linux example . Python Installation is available through PyPI . py -3 -m pip install phoenix6 C# (Windows) Installation is available through Nuget . An example on adding Nuget packages to a Visual Studio project is available in the Microsoft Quickstart . Firmware Installation Device firmware upgrading is handled by the Phoenix Tuner X configuration client. Simulation vs Hardware Python Users may notice the robot program is using simulated devices by default. This is the default behavior if the host platform supports simulation (see requirements for a full list of supported platforms). In order for the robot program to communicate with physical devices (on platforms that support both simulation and hardware), the CTR_TARGET environment variable must be set. Possible values of CTR_TARGET are: Hardware (see Hardware-Attached Simulation ) Simulation (see Introduction to Simulation ) Replay (see Hoot Replay ) Examples of setting CTR_TARGET are shown below. Windows $env:CTR_TARGET = \"Hardware\" # Set the environment variable, which will persist for the duration of this powershell instance. Linux export CTR_TARGET = Hardware # Export the environment variable so it's persistent in the shell Or CTR_TARGET = Hardware python3 application.py # Set the environment variable only for the python call Troubleshooting Bad return status on module... This error can show up on Raspberry Pi or Jetson systems when using the incorrect tools distribution for APT. Refer to Modifying list Distribution to correct your .list file. Diagnostics is running but no CAN Symptom: Tuner can ping the system and see that diagnostics is running but there are no devices. Possible Solutions: Verify that the CAN Bus is valid. Motors should be blinking orange. Consult Hardware Reference for a full list of LED codes. Verify that the canivore-usb kernel module is correctly installed by running modinfo canivore-usb . If canivore-usb shows installed with APT but does not appear with modinfo , then an update may have broken the module. Uninstall and reinstall canivore-usb with: sudo apt remove canivore-usb canivore-usb-kernel sudo apt install canivore-usb Raspberry Pi Errata On a Raspberry Pi 4 or newer, the latest 32-bit Raspberry Pi OS image will default to using the 64-bit kernel while still using 32-bit APT packages. As a result, the canivore-usb kernel module will fail to install. There are two options to work around this issue: (Recommended) Use the 64-bit Raspberry Pi OS. This allows programs to use all available RAM and improves overall system performance and stability. Add arm_64bit=0 to /boot/config.txt and reboot. This forces the Raspberry Pi to use the 32-bit kernel. Note that programs will be limited to using 3 GB of RAM, and system performance may be impacted. Warning Do not add arm_64bit=0 to /boot/config.txt when using the 64-bit Raspberry Pi OS. Attempting to do so may cause the Pi to be unable to boot. Examples The same Phoenix 6 examples can be used as a reference outside of FRC. The function calls are identical, although the framework that is used to call them may be different and specialized for FRC. Non FRC Projects We recommend that users use the standard language projects to use our library outside of FRC. For example, a typical Python project will have a main.py that utilizes the phoenix6 library that’s installed with pip . A typical C# project is a Visual Studio project that includes our libraries via nuget. For C++, an example utilizing CMake is provided here . Note When utilizing actuators outside of FRC, the user must continuously feed an enable signal to the device. For more information, see Enabling Actuators . Alternative Support In the event that the Phoenix 6 API does not fit the user’s needs (e.g. when using devices such as a TalonSRX ), users can utilize the Phoenix 5 API . We also provide a hardware robot controller called the HERO development board . The HERO can be programmed in C# to utilize compatible v5 devices.",
      "content_preview": "Installing Phoenix 6 (non-FRC) Important Users in FRC can skip this article. Phoenix 6 is fully supported outside of FRC on supported systems with a USB to CAN adapter. Note CANivore is the recommended USB to CAN adapter with support for CAN FD , name specification, and Windows (as host)."
    },
    {
      "url": "https://v6.docs.ctr-electronics.com/en/stable/docs/installation/installation.html",
      "title": "Installing Phoenix 6",
      "section": "General",
      "language": "All",
      "content": "Installing Phoenix 6 Installing Phoenix 6 (FRC) Click here to learn about installing the Phoenix 6 library for FRC. This explains adding the Phoenix vendordep into your robot project. Installing Phoenix 6 (FRC) Installing Phoenix 6 (non-FRC) Click here to learn about installing the Phoenix 6 library outside of FRC. This explains including our apt-get repository and applicable binaries. Installing Phoenix 6 (non-FRC)",
      "content_preview": "Installing Phoenix 6 Installing Phoenix 6 (FRC) Click here to learn about installing the Phoenix 6 library for FRC. This explains adding the Phoenix vendordep into your robot project."
    },
    {
      "url": "https://v6.docs.ctr-electronics.com/en/stable/docs/hardware-reference/cancoder/index.html",
      "title": "CANcoder",
      "section": "CANcoder",
      "language": "All",
      "content": "CANcoder The CANcoder is the next evolution in the line of CTRE magnetic encoder products. As its name implies, this product is a rotary magnetic encoder that communicates over the CAN bus. Supporting CAN FD and CAN 2.0, this product provides the same position and velocity with the same resolutions you’ve come to expect from the SRX Magnetic Encoder. Store Page CAD, Firmware and purchase instructions. https://store.ctr-electronics.com/cancoder/ Hardware User Manual Wiring and mount instructions in PDF format. https://store.ctr-electronics.com/content/user-manual/CANCoder%20User’s%20Guide.pdf Status Light Reference Note Users wishing to test magnet placement must wait 8 seconds after boot for the LEDs to blink the magnet placement status. Blink Codes Animation (Click to play) LED State Cause Possible Fix LED Off No Power Provide 12V to Red/Black leads. Slow Bright Red CANcoder does not have valid CAN. Ensure good connections between CANH and CANL (Yellow and Green) & robot controller is on. Rapid Dim Red CAN bus never detected since boot, CANcoder now reporting strength of magnet. Magnet is out of range (<25 mT or > 135 mT) Ensure good connections between CANH and CANL (Yellow and Green) & robot controller is on. Additionally, ensure the magnet's center axis is aligned with the defined center of the CANcoder housing and the magnet is in range of the CANcoder. See Section 2.1 of the Hardware User Manual. Rapid Dim Orange CAN bus never detected since boot, CANcoder now reporting strength of magnet. Magnet is in range with slightly reduced accuracy (25-45 mT or 75-135 mT). Ensure good connections between CANH and CANL (Yellow and Green) & robot controller is on. Additionally, ensure the magnet's center axis is aligned with the defined center of the CANcoder housing and the CANcoder is not too close or too far from the magnet. See Section 2.1 of the Hardware User Manual. Rapid Dim Green CAN bus never detected since boot, CANcoder now reporting strength of magnet. Magnet is in range. Ensure good connections between CANH and CANL (Yellow and Green) & robot controller is on. Rapid Bright Red CAN bus healthy. Magnet is out of range (<25 mT or > 135 mT) Ensure the magnet's center axis is aligned with the defined center of the CANcoder housing and the magnet is in range of the CANcoder. See Section 2.1 of the Hardware User Manual. Rapid Bright Orange CAN bus healthy. Magnet is in range with slightly reduced accuracy (25-45 mT or 75-135 mT). Ensure the magnet's center axis is aligned with the defined center of the CANcoder housing and the CANcoder is not too close or too far from the magnet. See Section 2.1 of the Hardware User Manual. Rapid Bright Green CAN bus healthy. Magnet is in range. Alternate Red/Orange Damaged Hardware. Use Tuner X Self Test to confirm the LEDs and that the hardware fault is set, then contact CTRE Alternate Orange/Green CANcoder in bootloader. Field-upgrade device in Tuner X. Magnet Placement Using the CANcoder User’s Guide , verify that magnet placement is correct for the CANcoder. Verifying Sensor Direction CANcoder sensor direction can be configured via the Config page in Phoenix Tuner X. Zeroing the CANcoder The zero offset for the CANcoder absolute position can be configured using the Magnet Offset config. Additionally, CANcoders can be zeroed in Tuner X by pressing on the button shown below. This sets the Magnet Offset config and reports the applied offset to the user. Important The Tuner X CANcoder zeroing button requires 2024 diagnostics or newer.",
      "content_preview": "CANcoder The CANcoder is the next evolution in the line of CTRE magnetic encoder products. As its name implies, this product is a rotary magnetic encoder that communicates over the CAN bus."
    },
    {
      "url": "https://v6.docs.ctr-electronics.com/en/stable/docs/tuner/tuner-swerve/creating-your-project.html",
      "title": "Creating your Project",
      "section": "Phoenix Tuner X",
      "language": "All",
      "content": "Creating your Project Wheel Radius (inches) The radius can be found by measuring the width of the module wheel, then dividing that by 2. FL to FR distance (inches) This is the distance between the center of the front-left module, and the center of the front-right module. FL to BL distance (inches) This is the distance between the center of the front-left module, and the center of the back-left module. Module Type The type of swerve module, such as WCP Swerve X standard, flipped gear, or flipped belt. Users not using any of the supported modules should select Custom instead. Drive Ratio This is the gearing ratio between the output shaft of the motor and the module wheel. Swerve X users can find that information here . Steer Ratio (Custom) This is the gearing ratio between the output shaft of the steering motor and the azimuth gear. For the Custom module type, users must calculate this based on their gearing themselves, or consult their manufacturer. Import Project Import an existing Tuner X swerve project save file. New Project Create a new project based on the settings configured. Users should configure the settings applicable for their robot and click New Project once they are done. Tip Throughout the application is various tooltips, that when you hover on them, provide instructions. If you are unsure on what something means, try hovering on it! Wizard Options Once a project is open, a couple of options are exposed at the top-right. In order from left to right: Factory default all devices Open the swerve settings menu Export project Exit project",
      "content_preview": "Creating your Project Wheel Radius (inches) The radius can be found by measuring the width of the module wheel, then dividing that by 2. FL to FR distance (inches) This is the distance between the center of the front-left module, and the center of the front-right module."
    },
    {
      "url": "https://v6.docs.ctr-electronics.com/en/stable/docs/tuner/tools/log-extractor.html",
      "title": "Extracting Signal Logs",
      "section": "Phoenix Tuner X",
      "language": "All",
      "content": "Extracting Signal Logs Tip Information on how to use the signal logger API can be found in the corresponding API article . Tuner X offers in-app functionality to retrieve, manage, and convert hoot logs to compatible formats. CTRE hoot logs can be retrieved utilizing the file explorer on the left of the application. The file explorer offers the functionality to download and delete logs on a remote target. On the right side, the Convert tab can be used to import and convert hoot logs to available formats. Once a hoot log has been downloaded, it is automatically placed in the conversion queue to the right. Logs can also be manually imported or removed using the two buttons at the top-right of the conversion queue. If a log file is reported as unlicensed, users can perform a Deep Scan of the log if they believe it should contain pro-licensed devices. By default, Tuner will only scan the first few megabytes of the log for pro-licensed devices to save time during scan and export. Filtering for Signals Since hoot logs can contain a massive amount of data, users may want to trim the exported log file. Tuner supports simple search and regex filtering of signals in a hoot . Filters are optional and configured on a per-log basis. Note If no signals are selected, all signals will be exported during conversion. In the below picture, regex is used to select only the MotorVoltage , Position , and Velocity signals for TalonFX-11 . Important If the hoot log does not contain any Pro-licensed devices, a limited set of signals may be exported for free using the AdvantageScope (wpilog) option. Converting After adding hoot logs to the queue, select the output directory and one of the output types. Then, click the Convert button to begin the conversion process. This may take some time depending on the output format, the size of the hoot file, and the number of selected signals. Common Issues Problem: When converting, I get hoot log API version too old, cannot export its signals Solution: This may happen if your hoot file was generated using an old version of Phoenix. Update your Phoenix installation (by updating your vendordep in Installing Phoenix 6 ) and recreate your log file. If the log file recorded is critical, reach out to support @ ctr-electronics . com . Problem: When converting, I get Could not read to end of input file Solution: This occurs when the converter encounters bad data. This typically occurs when the robot is turned off in the middle of writing to the log. Users can often ignore this error message, although the last few seconds of data may be lost. To avoid this issue, run SignalLogger.stop() before shutting down the robot program.",
      "content_preview": "Extracting Signal Logs Tip Information on how to use the signal logger API can be found in the corresponding API article . Tuner X offers in-app functionality to retrieve, manage, and convert hoot logs to compatible formats."
    },
    {
      "url": "https://v6.docs.ctr-electronics.com/en/stable/docs/api-reference/api-usage/configuration.html",
      "title": "Configuration",
      "section": "API Reference",
      "language": "All",
      "content": "Configuration Devices support persistent settings through the use of “configs”. Tip Configs can also be configured using Phoenix Tuner X. See Tuner Configs for more information. Configuration Objects There are device-specific Configuration classes that group configuration data of devices in a meaningful way. These classes are Passive Data Structures . One example is TalonFXConfiguration , which has subgroups of configs such as MotorOutputConfigs . The configs can be modified through public member variables of the Configuration object. The complete list of configuration objects can be found in the API documentation ( Java , C++ , Python ). Note Phoenix 6 utilizes the C++ units library and, optionally, the Java units library when applicable. Using the Java units library may increase GC overhead. Java var talonFXConfigs = new TalonFXConfiguration (); C++ configs :: TalonFXConfiguration talonFXConfigs {}; Python talonfx_configs = configs . TalonFXConfiguration () Modifying Configurations Configuration objects are mutable, so they can be saved in a member variable and reused. Additionally, configuration objects support modification using method chaining. This can be useful for constructing them as a class member variable or at compile time. In Java, this can also be used to provide unit types. Java final TalonFXConfiguration talonFXConfigs = new TalonFXConfiguration () . withMotorOutput ( new MotorOutputConfigs () . withInverted ( InvertedValue . Clockwise_Positive ) . withNeutralMode ( NeutralModeValue . Brake ) ) . withCurrentLimits ( new CurrentLimitsConfigs () . withStatorCurrentLimit ( Amps . of ( 120 )) . withStatorCurrentLimitEnable ( true ) ); C++ static constexpr configs :: TalonFXConfiguration talonFXConfigs = configs :: TalonFXConfiguration {} . WithMotorOutput ( configs :: MotorOutputConfigs {} . WithInverted ( signals :: InvertedValue :: Clockwise_Positive ) . WithNeutralMode ( signals :: NeutralModeValue :: Brake ) ) . WithCurrentLimits ( configs :: CurrentLimitsConfigs {} . WithStatorCurrentLimit ( 120 _A ) . WithStatorCurrentLimitEnable ( true ) ); Python self . _talon_fx_configs = ( configs . TalonFXConfiguration () . with_motor_output ( configs . MotorOutputConfigs () . with_inverted ( signals . InvertedValue . CLOCKWISE_POSITIVE ) . with_neutral_mode ( signals . NeutralModeValue . BRAKE ) ) . with_current_limits ( configs . CurrentLimitsConfigs () . with_stator_current_limit ( 120.0 ) . with_stator_current_limit_enable ( True ) ) ) Future Proofing Configs There is a corner case with configs where the device may have firmware with newer configs that didn’t exist when the version of the API was built. To account for this problem, device Configuration objects have a FutureProofConfigs ( Java , C++ , Python ) field. Configurator API Device objects have a getConfigurator() method that returns a device-specific Configurator object. The Configurator is used to retrieve, apply, and factory default the configs of a device. Note The getConfigurator() routine can be called frequently without any performance implications. The device-specific configurators have type-specific overloads that allow for the widest variety of device-compatible configs. As a result, the caller can pass the entire device Configuration object or just the relevant subgroup of configs to the Configurator API. Java var talonFXConfigurator = m_talonFX . getConfigurator (); C++ auto & talonFXConfigurator = m_talonFX . GetConfigurator (); Python talonfx_configurator = self . talonfx . configurator Reading Configs To read configs stored in a device, use the refresh() method to update a Configuration object. The example below demonstrates retrieving a full TalonFXConfiguration ( Java , C++ , Python ) object from a TalonFX device. Warning refresh() is a blocking API call that waits on the device to respond. Calling refresh() periodically may slow down the execution time of the periodic function, as it will always wait up to DefaultTimeoutSeconds ( Java , C++ , Python ) for the response when no timeout parameter is specified. Java var talonFXConfigurator = m_talonFX . getConfigurator (); var talonFXConfigs = new TalonFXConfiguration (); // optional timeout (in seconds) as a second optional parameter talonFXConfigurator . refresh ( talonFXConfigs ); C++ auto & talonFXConfigurator = m_talonFX . GetConfigurator (); configs :: TalonFXConfiguration talonFXConfigs {}; // optional timeout (in seconds) as a second optional parameter talonFXConfigurator . Refresh ( talonFXConfigs ); Python talonfx_configurator = self . talonfx . configurator talonfx_configs = configs . TalonFXConfiguration () # optional timeout (in seconds) as a second optional parameter talonfx_configurator . refresh ( talonfx_configs ) Applying Configs Configs can be applied to a device by calling apply() on the Configurator with a Configuration object. Warning apply() is a blocking API call that waits on the device to respond. Calling apply() periodically may slow down the execution time of the periodic function, as it will always wait up to DefaultTimeoutSeconds ( Java , C++ , Python ) for the response when no timeout parameter is specified. Java var talonFXConfigurator = m_talonFX . getConfigurator (); var motorConfigs = new MotorOutputConfigs (); // set invert to CW+ and apply config change motorConfigs . Inverted = InvertedValue . Clockwise_Positive ; talonFXConfigurator . apply ( motorConfigs ); C++ auto & talonFXConfigurator = m_talonFX . GetConfigurator (); configs :: MotorOutputConfigs motorConfigs {}; // set invert to CW+ and apply config change motorConfigs . Inverted = signals :: InvertedValue :: Clockwise_Positive ; talonFXConfigurator . Apply ( motorConfigs ); Python talonfx_configurator = self . talonfx . configurator motor_configs = configs . MotorOutputConfigs () # set invert to CW+ and apply config change motor_configs . inverted = signals . InvertValue . CLOCKWISE_POSITIVE talonfx_configurator . apply ( motor_configs ) Tip To modify a single configuration value without affecting the other configs, users can call refresh() after constructing the config object, or users can cache the config object and reuse it for future calls to apply() . Factory Default A newly-created Configuration object contains the default configuration values of a device. As a result, it is unnecessary to factory default a device before applying a modified device Configuration object. A device’s configs can be explicitly restored to the factory defaults by passing a newly-created Configuration object to the device Configurator . Java m_talonFX . getConfigurator (). apply ( new TalonFXConfiguration ()); C++ m_talonFX . GetConfigurator (). Apply ( configs :: TalonFXConfiguration {}); Python self . talonfx . configurator . apply ( configs . TalonFXConfiguration ())",
      "content_preview": "Configuration Devices support persistent settings through the use of “configs”. Tip Configs can also be configured using Phoenix Tuner X. See Tuner Configs for more information."
    },
    {
      "url": "https://v6.docs.ctr-electronics.com/en/stable/docs/licensing/team-licensing.html",
      "title": "Season Pass Licensing",
      "section": "General",
      "language": "All",
      "content": "Season Pass Licensing Tip Season Pass can be purchased at https://store.ctr-electronics.com/ . Season Pass is a single, cost-effective purchase that allows FRC teams to license compatible devices with Phoenix Pro for the entire season. The steps for licensing devices with season pass are as follows. Purchase a season pass at https://store.ctr-electronics.com/ . Wait for the email that says your license is ready (typically 1-2 minutes). Follow the below steps for attaching a team number to your license. Once a team number has been attached, licensing process is the same as Device Licensing . When is a Season Pass Applicable? Season Pass licenses enable Pro features when the licensed device is: Used on a roboRIO configured for the team number assigned to the Season Pass Season Pass licensing will work on the roboRIO regardless of whether the device is on the native CAN Bus or a CANivore Bus. Used for Hardware Attached Simulation (a CANivore connected to PC) with a WPILib robot project Used on a roboRIO configured for one of the reserved “Off-Season Demo” team numbers (currently team numbers 9970 - 9999) Attaching a Team Number to Season Pass Warning Attaching a team number to a season pass is permanent. On the “Profile” page of Tuner X, click on the license to attach a team for. Enter the team number in the box below the list of licenses. Click Assign Team . A prompt will appear asking the user to confirm the entered team number. Note Note that the robot must be configured for the assigned team number. An invalid team number on the robot will result in the device not appearing as Pro licensed. How many devices can I activate? A season pass contains 100 individual device licenses. In the event that a team needs more licenses, contact us at support @ ctr-electronics . com .",
      "content_preview": "Season Pass Licensing Tip Season Pass can be purchased at https://store.ctr-electronics.com/ . Season Pass is a single, cost-effective purchase that allows FRC teams to license compatible devices with Phoenix Pro for the entire season."
    },
    {
      "url": "https://v6.docs.ctr-electronics.com/en/stable/docs/api-reference/wpilib-integration/index.html",
      "title": "WPILib Integration",
      "section": "API Reference",
      "language": "All",
      "content": "WPILib Integration Phoenix 6 API used as part of WPILib robot projects provides implementations of common WPILib interfaces that FRC teams use. Note While the Python API does support simulation, it currently does not hook into WPILib’s simulation GUI at this time. MotorController Integration Motor Safety Simulation SysId Integration Advantages of SignalLogger over DataLog Plumbing & Running SysId Unit Testing",
      "content_preview": "WPILib Integration Phoenix 6 API used as part of WPILib robot projects provides implementations of common WPILib interfaces that FRC teams use. Note While the Python API does support simulation, it currently does not hook into WPILib’s simulation GUI at this time."
    },
    {
      "url": "https://v6.docs.ctr-electronics.com/en/stable/docs/api-reference/device-specific/talonfx/talonfx-control-intro.html",
      "title": "Introduction to TalonFX Control",
      "section": "TalonFX",
      "language": "All",
      "content": "Introduction to TalonFX Control The TalonFX has a variety of open-loop and closed-loop control requests and supports Field Oriented Control. Control Output Types The TalonFX currently supports three base control output types: DutyCycle, Voltage, and TorqueCurrentFOC. Note There are various configuration options available that influence the onboard control (for example, see Improving Performance with Current Limits ). DutyCycle A DutyCycle control request outputs a proportion of the supply voltage, which typically ranges from -1.0 to 1.0, inclusive. This control output type is typically used in systems where it is important to be capable of running at the maximum speed possible, such as in a typical robot drivetrain. Voltage A Voltage control request directly controls the output voltage of the motor. The output voltage is capped by the supply voltage to the device. Since the output of a Voltage control request is typically unaffected by the supply voltage, this control output type results in more stable and reproducible behavior than a DutyCycle control request. TorqueCurrentFOC Important This feature requires the device to be Pro licensed . A TorqueCurrentFOC control request uses Field Oriented Control to directly control the output torque current of the motor. Unlike the other control output types, where output roughly controls the velocity of the motor, a TorqueCurrentFOC request directly controls the acceleration of the motor. Field Oriented Control Important This feature requires the device to be Pro licensed . Field Oriented Control (FOC) is a commutation mode that increases peak power by ~15%. All control modes that optionally support FOC have an EnableFOC field ( Java , C++ , Python ). There are also control types that require FOC, such as TorqueCurrentFOC. Behavior While Unlicensed When controlling an unlicensed device, the device will automatically fall back to non-FOC commutation for control requests that support the EnableFOC field. For control requests that require FOC, such as TorqueCurrentFOC, the unlicensed device will: Disable control output Set the UnlicensedFeatureInUse fault Blink unlicensed",
      "content_preview": "Introduction to TalonFX Control The TalonFX has a variety of open-loop and closed-loop control requests and supports Field Oriented Control. Control Output Types The TalonFX currently supports three base control output types: DutyCycle, Voltage, and TorqueCurrentFOC."
    },
    {
      "url": "https://v6.docs.ctr-electronics.com/en/stable/docs/api-reference/mechanisms/swerve/swerve-builder-api.html",
      "title": "Swerve Builder API",
      "section": "API Reference",
      "language": "All",
      "content": "Swerve Builder API To simplify the API surface, both builder and factory paradigms are used. Users create a SwerveDrivetrain by first defining the global drivetrain characteristics and then each module characteristics. Note Phoenix 6 supports the Java units library when applicable. Defining Drivetrain Characteristics Drivetrain, in this instance, refers to the SwerveDrivetrainConstants class ( Java , C++ , Python ). This class defines characteristics that are not tied to the swerve modules, such as the CAN bus or Pigeon 2 device ID. Note All devices in the swerve drivetrain must be on the same CAN bus. Users can optionally provide a configuration object to apply custom configs to the Pigeon 2, such as mount orientation. Leaving the configuration object null will skip applying configs to the Pigeon 2. Defining Module Characteristics The typical FRC drivetrain includes 4 identical modules. To simplify module creation, the SwerveModuleConstantsFactory ( Java , C++ , Python ) class is used to set up constants common across all modules, such as the drive/steer gear ratios and the wheel radius. Some extra steps may be required to determine some constants, described below. CouplingGearRatio The ratio at which the output wheel rotates when the azimuth spins. In a traditional swerve module, this is the inverse of the 1st stage of the drive motor. To manually determine the coupling ratio, lock the drive wheel in-place, then rotate the azimuth three times. Observe the number of rotations reported by the drive motor. The coupling ratio will be \\(driveRotations / 3\\) , or \\(driveRotations / azimuthRotations\\) . SlipCurrent This is the amount of stator current the drive motors can apply without slippage. Follow the instructions in Preventing Wheel Slip to find the slip current of the drivetrain. DriveMotorInitialConfigs / SteerMotorInitialConfigs / EncoderInitialConfigs An initial configuration object that can be used to apply custom configs to the backing devices for each swerve module. This is useful for situations such as applying supply current limits. Building the Swerve Module Constants SwerveModuleConstants ( Java , C++ , Python ) can be created from the previous SwerveModuleConstantsFactory . A typical swerve drivetrain consists of four identical modules: Front Left, Front Right, Back Left, Back Right. While these modules can be instantiated directly (only really useful if the modules have different physical characteristics), the modules can also be created by calling createModuleConstants(...) with the aforementioned factory. Note The X and Y position of the modules is measured from the center point of the robot along the X and Y axes, respectively. These values use the same coordinate system as Translation2d ( Java , C++ , Python ), where forward is positive X and left is positive Y. Building the SwerveDrivetrain SwerveDrivetrain ( Java , C++ , Python ) is the class that handles odometry, configuration and control of the drivetrain. The constructor for this class takes the previous SwerveDrivetrainConstants and a list of SwerveModuleConstants . Utilization of SwerveDrivetrain consists of SwerveRequests that define the state of the drivetrain. For full details of using SwerveRequests to control your swerve, see Swerve Requests . Full Example Note CommandSwerveDrivetrain is a version created by the Tuner X Swerve Project Generator that implements Subsystem ( Java , C++ , Python ) for easy command-based integration. Java 1 // Generated by the Tuner X Swerve Project Generator 2 // https://v6.docs.ctr-electronics.com/en/stable/docs/tuner/tuner-swerve/index.html 3 public class TunerConstants { 4 // Both sets of gains need to be tuned to your individual robot. 5 6 // The steer motor uses any SwerveModule.SteerRequestType control request with the 7 // output type specified by SwerveModuleConstants.SteerMotorClosedLoopOutput 8 private static final Slot0Configs steerGains = new Slot0Configs () 9 . withKP ( 100 ). withKI ( 0 ). withKD ( 0.5 ) 10 . withKS ( 0.1 ). withKV ( 1.91 ). withKA ( 0 ) 11 . withStaticFeedforwardSign ( StaticFeedforwardSignValue . UseClosedLoopSign ); 12 // When using closed-loop control, the drive motor uses the control 13 // output type specified by SwerveModuleConstants.DriveMotorClosedLoopOutput 14 private static final Slot0Configs driveGains = new Slot0Configs () 15 . withKP ( 0.1 ). withKI ( 0 ). withKD ( 0 ) 16 . withKS ( 0 ). withKV ( 0.124 ); 17 18 // The closed-loop output type to use for the steer motors; 19 // This affects the PID/FF gains for the steer motors 20 private static final ClosedLoopOutputType kSteerClosedLoopOutput = ClosedLoopOutputType . Voltage ; 21 // The closed-loop output type to use for the drive motors; 22 // This affects the PID/FF gains for the drive motors 23 private static final ClosedLoopOutputType kDriveClosedLoopOutput = ClosedLoopOutputType . Voltage ; 24 25 // The type of motor used for the drive motor 26 private static final DriveMotorArrangement kDriveMotorType = DriveMotorArrangement . TalonFX_Integrated ; 27 // The type of motor used for the drive motor 28 private static final SteerMotorArrangement kSteerMotorType = SteerMotorArrangement . TalonFX_Integrated ; 29 30 // The remote sensor feedback type to use for the steer motors; 31 // When not Pro-licensed, Fused*/Sync* automatically fall back to Remote* 32 private static final SteerFeedbackType kSteerFeedbackType = SteerFeedbackType . FusedCANcoder ; 33 34 // The stator current at which the wheels start to slip; 35 // This needs to be tuned to your individual robot 36 private static final Current kSlipCurrent = Amps . of ( 120.0 ); 37 38 // Initial configs for the drive and steer motors and the azimuth encoder; these cannot be null. 39 // Some configs will be overwritten; check the `with*InitialConfigs()` API documentation. 40 private static final TalonFXConfiguration driveInitialConfigs = new TalonFXConfiguration (); 41 private static final TalonFXConfiguration steerInitialConfigs = new TalonFXConfiguration () 42 . withCurrentLimits ( 43 new CurrentLimitsConfigs () 44 // Swerve azimuth does not require much torque output, so we can set a relatively low 45 // stator current limit to help avoid brownouts without impacting performance. 46 . withStatorCurrentLimit ( Amps . of ( 60.0 )) 47 . withStatorCurrentLimitEnable ( true ) 48 ); 49 private static final CANcoderConfiguration encoderInitialConfigs = new CANcoderConfiguration (); 50 // Configs for the Pigeon 2; leave this null to skip applying Pigeon 2 configs 51 private static final Pigeon2Configuration pigeonConfigs = null ; 52 53 // CAN bus that the devices are located on; 54 // All swerve devices must share the same CAN bus 55 public static final CANBus kCANBus = new CANBus ( \"canivore\" , \"./logs/example.hoot\" ); 56 57 // Theoretical free speed (m/s) at 12 V applied output; 58 // This needs to be tuned to your individual robot 59 public static final LinearVelocity kSpeedAt12Volts = MetersPerSecond . of ( 4.54 ); 60 61 // Every 1 rotation of the azimuth results in kCoupleRatio drive motor turns; 62 // This may need to be tuned to your individual robot 63 private static final double kCoupleRatio = 3.8181818181818183 ; 64 65 private static final double kDriveGearRatio = 7.363636363636365 ; 66 private static final double kSteerGearRatio = 15.42857142857143 ; 67 private static final Distance kWheelRadius = Inches . of ( 2.167 ); 68 69 private static final boolean kInvertLeftSide = false ; 70 private static final boolean kInvertRightSide = true ; 71 72 private static final int kPigeonId = 1 ; 73 74 // These are only used for simulation 75 private static final MomentOfInertia kSteerInertia = KilogramSquareMeters . of ( 0.01 ); 76 private static final MomentOfInertia kDriveInertia = KilogramSquareMeters . of ( 0.01 ); 77 // Simulated voltage necessary to overcome friction 78 private static final Voltage kSteerFrictionVoltage = Volts . of ( 0.2 ); 79 private static final Voltage kDriveFrictionVoltage = Volts . of ( 0.2 ); 80 81 public static final SwerveDrivetrainConstants DrivetrainConstants = new SwerveDrivetrainConstants () 82 . withCANBusName ( kCANBus . getName ()) 83 . withPigeon2Id ( kPigeonId ) 84 . withPigeon2Configs ( pigeonConfigs ); 85 86 private static final SwerveModuleConstantsFactory < TalonFXConfiguration , TalonFXConfiguration , CANcoderConfiguration > ConstantCreator = 87 new SwerveModuleConstantsFactory < TalonFXConfiguration , TalonFXConfiguration , CANcoderConfiguration > () 88 . withDriveMotorGearRatio ( kDriveGearRatio ) 89 . withSteerMotorGearRatio ( kSteerGearRatio ) 90 . withCouplingGearRatio ( kCoupleRatio ) 91 . withWheelRadius ( kWheelRadius ) 92 . withSteerMotorGains ( steerGains ) 93 . withDriveMotorGains ( driveGains ) 94 . withSteerMotorClosedLoopOutput ( kSteerClosedLoopOutput ) 95 . withDriveMotorClosedLoopOutput ( kDriveClosedLoopOutput ) 96 . withSlipCurrent ( kSlipCurrent ) 97 . withSpeedAt12Volts ( kSpeedAt12Volts ) 98 . withDriveMotorType ( kDriveMotorType ) 99 . withSteerMotorType ( kSteerMotorType ) 100 . withFeedbackSource ( kSteerFeedbackType ) 101 . withDriveMotorInitialConfigs ( driveInitialConfigs ) 102 . withSteerMotorInitialConfigs ( steerInitialConfigs ) 103 . withEncoderInitialConfigs ( encoderInitialConfigs ) 104 . withSteerInertia ( kSteerInertia ) 105 . withDriveInertia ( kDriveInertia ) 106 . withSteerFrictionVoltage ( kSteerFrictionVoltage ) 107 . withDriveFrictionVoltage ( kDriveFrictionVoltage ); 108 109 110 // Front Left 111 private static final int kFrontLeftDriveMotorId = 3 ; 112 private static final int kFrontLeftSteerMotorId = 2 ; 113 private static final int kFrontLeftEncoderId = 1 ; 114 private static final Angle kFrontLeftEncoderOffset = Rotations . of ( 0.15234375 ); 115 private static final boolean kFrontLeftSteerMotorInverted = true ; 116 private static final boolean kFrontLeftEncoderInverted = false ; 117 118 private static final Distance kFrontLeftXPos = Inches . of ( 10 ); 119 private static final Distance kFrontLeftYPos = Inches . of ( 10 ); 120 121 // Front Right 122 private static final int kFrontRightDriveMotorId = 1 ; 123 private static final int kFrontRightSteerMotorId = 0 ; 124 private static final int kFrontRightEncoderId = 0 ; 125 private static final Angle kFrontRightEncoderOffset = Rotations . of ( - 0.4873046875 ); 126 private static final boolean kFrontRightSteerMotorInverted = true ; 127 private static final boolean kFrontRightEncoderInverted = false ; 128 129 private static final Distance kFrontRightXPos = Inches . of ( 10 ); 130 private static final Distance kFrontRightYPos = Inches . of ( - 10 ); 131 132 // Back Left 133 private static final int kBackLeftDriveMotorId = 7 ; 134 private static final int kBackLeftSteerMotorId = 6 ; 135 private static final int kBackLeftEncoderId = 3 ; 136 private static final Angle kBackLeftEncoderOffset = Rotations . of ( - 0.219482421875 ); 137 private static final boolean kBackLeftSteerMotorInverted = true ; 138 private static final boolean kBackLeftEncoderInverted = false ; 139 140 private static final Distance kBackLeftXPos = Inches . of ( - 10 ); 141 private static final Distance kBackLeftYPos = Inches . of ( 10 ); 142 143 // Back Right 144 private static final int kBackRightDriveMotorId = 5 ; 145 private static final int kBackRightSteerMotorId = 4 ; 146 private static final int kBackRightEncoderId = 2 ; 147 private static final Angle kBackRightEncoderOffset = Rotations . of ( 0.17236328125 ); 148 private static final boolean kBackRightSteerMotorInverted = true ; 149 private static final boolean kBackRightEncoderInverted = false ; 150 151 private static final Distance kBackRightXPos = Inches . of ( - 10 ); 152 private static final Distance kBackRightYPos = Inches . of ( - 10 ); 153 154 155 public static final SwerveModuleConstants < TalonFXConfiguration , TalonFXConfiguration , CANcoderConfiguration > FrontLeft = 156 ConstantCreator . createModuleConstants ( 157 kFrontLeftSteerMotorId , kFrontLeftDriveMotorId , kFrontLeftEncoderId , kFrontLeftEncoderOffset , 158 kFrontLeftXPos , kFrontLeftYPos , kInvertLeftSide , kFrontLeftSteerMotorInverted , kFrontLeftEncoderInverted 159 ); 160 public static final SwerveModuleConstants < TalonFXConfiguration , TalonFXConfiguration , CANcoderConfiguration > FrontRight = 161 ConstantCreator . createModuleConstants ( 162 kFrontRightSteerMotorId , kFrontRightDriveMotorId , kFrontRightEncoderId , kFrontRightEncoderOffset , 163 kFrontRightXPos , kFrontRightYPos , kInvertRightSide , kFrontRightSteerMotorInverted , kFrontRightEncoderInverted 164 ); 165 public static final SwerveModuleConstants < TalonFXConfiguration , TalonFXConfiguration , CANcoderConfiguration > BackLeft = 166 ConstantCreator . createModuleConstants ( 167 kBackLeftSteerMotorId , kBackLeftDriveMotorId , kBackLeftEncoderId , kBackLeftEncoderOffset , 168 kBackLeftXPos , kBackLeftYPos , kInvertLeftSide , kBackLeftSteerMotorInverted , kBackLeftEncoderInverted 169 ); 170 public static final SwerveModuleConstants < TalonFXConfiguration , TalonFXConfiguration , CANcoderConfiguration > BackRight = 171 ConstantCreator . createModuleConstants ( 172 kBackRightSteerMotorId , kBackRightDriveMotorId , kBackRightEncoderId , kBackRightEncoderOffset , 173 kBackRightXPos , kBackRightYPos , kInvertRightSide , kBackRightSteerMotorInverted , kBackRightEncoderInverted 174 ); 175 176 /** 177 * Creates a CommandSwerveDrivetrain instance. 178 * This should only be called once in your robot program,. 179 */ 180 public static CommandSwerveDrivetrain createDrivetrain () { 181 return new CommandSwerveDrivetrain ( 182 DrivetrainConstants , FrontLeft , FrontRight , BackLeft , BackRight 183 ); 184 } 185 186 187 /** 188 * Swerve Drive class utilizing CTR Electronics' Phoenix 6 API with the selected device types. 189 */ 190 public static class TunerSwerveDrivetrain extends SwerveDrivetrain < TalonFX , TalonFX , CANcoder > { 191 /** 192 * Constructs a CTRE SwerveDrivetrain using the specified constants. 193 * <p> 194 * This constructs the underlying hardware devices, so users should not construct 195 * the devices themselves. If they need the devices, they can access them through 196 * getters in the classes. 197 * 198 * @param drivetrainConstants Drivetrain-wide constants for the swerve drive 199 * @param modules Constants for each specific module 200 */ 201 public TunerSwerveDrivetrain ( 202 SwerveDrivetrainConstants drivetrainConstants , 203 SwerveModuleConstants <? , ? , ?> ... modules 204 ) { 205 super ( 206 TalonFX :: new , TalonFX :: new , CANcoder :: new , 207 drivetrainConstants , modules 208 ); 209 } 210 211 /** 212 * Constructs a CTRE SwerveDrivetrain using the specified constants. 213 * <p> 214 * This constructs the underlying hardware devices, so users should not construct 215 * the devices themselves. If they need the devices, they can access them through 216 * getters in the classes. 217 * 218 * @param drivetrainConstants Drivetrain-wide constants for the swerve drive 219 * @param odometryUpdateFrequency The frequency to run the odometry loop. If 220 * unspecified or set to 0 Hz, this is 250 Hz on 221 * CAN FD, and 100 Hz on CAN 2.0. 222 * @param modules Constants for each specific module 223 */ 224 public TunerSwerveDrivetrain ( 225 SwerveDrivetrainConstants drivetrainConstants , 226 double odometryUpdateFrequency , 227 SwerveModuleConstants <? , ? , ?> ... modules 228 ) { 229 super ( 230 TalonFX :: new , TalonFX :: new , CANcoder :: new , 231 drivetrainConstants , odometryUpdateFrequency , modules 232 ); 233 } 234 235 /** 236 * Constructs a CTRE SwerveDrivetrain using the specified constants. 237 * <p> 238 * This constructs the underlying hardware devices, so users should not construct 239 * the devices themselves. If they need the devices, they can access them through 240 * getters in the classes. 241 * 242 * @param drivetrainConstants Drivetrain-wide constants for the swerve drive 243 * @param odometryUpdateFrequency The frequency to run the odometry loop. If 244 * unspecified or set to 0 Hz, this is 250 Hz on 245 * CAN FD, and 100 Hz on CAN 2.0. 246 * @param odometryStandardDeviation The standard deviation for odometry calculation 247 * in the form [x, y, theta]ᵀ, with units in meters 248 * and radians 249 * @param visionStandardDeviation The standard deviation for vision calculation 250 * in the form [x, y, theta]ᵀ, with units in meters 251 * and radians 252 * @param modules Constants for each specific module 253 */ 254 public TunerSwerveDrivetrain ( 255 SwerveDrivetrainConstants drivetrainConstants , 256 double odometryUpdateFrequency , 257 Matrix < N3 , N1 > odometryStandardDeviation , 258 Matrix < N3 , N1 > visionStandardDeviation , 259 SwerveModuleConstants <? , ? , ?> ... modules 260 ) { 261 super ( 262 TalonFX :: new , TalonFX :: new , CANcoder :: new , 263 drivetrainConstants , odometryUpdateFrequency , 264 odometryStandardDeviation , visionStandardDeviation , modules 265 ); 266 } 267 } 268 } C++ (Header) 1 #include \"ctre/phoenix6/swerve/SwerveDrivetrain.hpp\" 2 3 using namespace ctre :: phoenix6 ; 4 5 namespace subsystems { 6 /* Forward declaration */ 7 class CommandSwerveDrivetrain ; 8 } 9 10 // Generated by the Tuner X Swerve Project Generator 11 // https://v6.docs.ctr-electronics.com/en/stable/docs/tuner/tuner-swerve/index.html 12 class TunerConstants { 13 // Both sets of gains need to be tuned to your individual robot. 14 15 // The steer motor uses any SwerveModule.SteerRequestType control request with the 16 // output type specified by SwerveModuleConstants::SteerMotorClosedLoopOutput 17 static constexpr configs :: Slot0Configs steerGains = configs :: Slot0Configs {} 18 . WithKP ( 100 ). WithKI ( 0 ). WithKD ( 0.5 ) 19 . WithKS ( 0.1 ). WithKV ( 1.91 ). WithKA ( 0 ) 20 . WithStaticFeedforwardSign ( signals :: StaticFeedforwardSignValue :: UseClosedLoopSign ); 21 // When using closed-loop control, the drive motor uses the control 22 // output type specified by SwerveModuleConstants::DriveMotorClosedLoopOutput 23 static constexpr configs :: Slot0Configs driveGains = configs :: Slot0Configs {} 24 . WithKP ( 0.1 ). WithKI ( 0 ). WithKD ( 0 ) 25 . WithKS ( 0 ). WithKV ( 0.124 ); 26 27 // The closed-loop output type to use for the steer motors; 28 // This affects the PID/FF gains for the steer motors 29 static constexpr swerve :: ClosedLoopOutputType kSteerClosedLoopOutput = swerve :: ClosedLoopOutputType :: Voltage ; 30 // The closed-loop output type to use for the drive motors; 31 // This affects the PID/FF gains for the drive motors 32 static constexpr swerve :: ClosedLoopOutputType kDriveClosedLoopOutput = swerve :: ClosedLoopOutputType :: Voltage ; 33 34 // The type of motor used for the drive motor 35 static constexpr swerve :: DriveMotorArrangement kDriveMotorType = swerve :: DriveMotorArrangement :: TalonFX_Integrated ; 36 // The type of motor used for the drive motor 37 static constexpr swerve :: SteerMotorArrangement kSteerMotorType = swerve :: SteerMotorArrangement :: TalonFX_Integrated ; 38 39 // The remote sensor feedback type to use for the steer motors; 40 // When not Pro-licensed, Fused*/Sync* automatically fall back to Remote* 41 static constexpr swerve :: SteerFeedbackType kSteerFeedbackType = swerve :: SteerFeedbackType :: FusedCANcoder ; 42 43 // The stator current at which the wheels start to slip; 44 // This needs to be tuned to your individual robot 45 static constexpr units :: ampere_t kSlipCurrent = 120 _A ; 46 47 // Initial configs for the drive and steer motors and the azimuth encoder; these cannot be null. 48 // Some configs will be overwritten; check the `With*InitialConfigs()` API documentation. 49 static constexpr configs :: TalonFXConfiguration driveInitialConfigs {}; 50 static constexpr configs :: TalonFXConfiguration steerInitialConfigs = configs :: TalonFXConfiguration {} 51 . WithCurrentLimits ( 52 configs :: CurrentLimitsConfigs {} 53 // Swerve azimuth does not require much torque output, so we can set a relatively low 54 // stator current limit to help avoid brownouts without impacting performance. 55 . WithStatorCurrentLimit ( 60 _A ) 56 . WithStatorCurrentLimitEnable ( true ) 57 ); 58 59 static constexpr configs :: CANcoderConfiguration encoderInitialConfigs {}; 60 // Configs for the Pigeon 2; leave this nullopt to skip applying Pigeon 2 configs 61 static constexpr std :: optional < configs :: Pigeon2Configuration > pigeonConfigs = std :: nullopt ; 62 63 static constexpr std :: string_view kCANBusName = \"canivore\" ; 64 65 public : 66 // CAN bus that the devices are located on; 67 // All swerve devices must share the same CAN bus 68 static inline const CANBus kCANBus { kCANBusName , \"./logs/example.hoot\" }; 69 70 // Theoretical free speed (m/s) at 12 V applied output; 71 // This needs to be tuned to your individual robot 72 static constexpr units :: meters_per_second_t kSpeedAt12Volts = 4.54 _mps ; 73 74 private : 75 // Every 1 rotation of the azimuth results in kCoupleRatio drive motor turns; 76 // This may need to be tuned to your individual robot 77 static constexpr units :: scalar_t kCoupleRatio = 3.8181818181818183 ; 78 79 static constexpr units :: scalar_t kDriveGearRatio = 7.363636363636365 ; 80 static constexpr units :: scalar_t kSteerGearRatio = 15.42857142857143 ; 81 static constexpr units :: inch_t kWheelRadius = 2.167 _in ; 82 83 static constexpr bool kInvertLeftSide = false ; 84 static constexpr bool kInvertRightSide = true ; 85 86 static constexpr int kPigeonId = 1 ; 87 88 // These are only used for simulation 89 static constexpr units :: kilogram_square_meter_t kSteerInertia = 0.01 _kg_sq_m ; 90 static constexpr units :: kilogram_square_meter_t kDriveInertia = 0.01 _kg_sq_m ; 91 // Simulated voltage necessary to overcome friction 92 static constexpr units :: volt_t kSteerFrictionVoltage = 0.2 _V ; 93 static constexpr units :: volt_t kDriveFrictionVoltage = 0.2 _V ; 94 95 public : 96 static constexpr swerve :: SwerveDrivetrainConstants DrivetrainConstants = swerve :: SwerveDrivetrainConstants {} 97 . WithCANBusName ( kCANBusName ) 98 . WithPigeon2Id ( kPigeonId ) 99 . WithPigeon2Configs ( pigeonConfigs ); 100 101 private : 102 static constexpr swerve :: SwerveModuleConstantsFactory ConstantCreator = 103 swerve :: SwerveModuleConstantsFactory < configs :: TalonFXConfiguration , configs :: TalonFXConfiguration , configs :: CANcoderConfiguration > {} 104 . WithDriveMotorGearRatio ( kDriveGearRatio ) 105 . WithSteerMotorGearRatio ( kSteerGearRatio ) 106 . WithCouplingGearRatio ( kCoupleRatio ) 107 . WithWheelRadius ( kWheelRadius ) 108 . WithSteerMotorGains ( steerGains ) 109 . WithDriveMotorGains ( driveGains ) 110 . WithSteerMotorClosedLoopOutput ( kSteerClosedLoopOutput ) 111 . WithDriveMotorClosedLoopOutput ( kDriveClosedLoopOutput ) 112 . WithSlipCurrent ( kSlipCurrent ) 113 . WithSpeedAt12Volts ( kSpeedAt12Volts ) 114 . WithDriveMotorType ( kDriveMotorType ) 115 . WithSteerMotorType ( kSteerMotorType ) 116 . WithFeedbackSource ( kSteerFeedbackType ) 117 . WithDriveMotorInitialConfigs ( driveInitialConfigs ) 118 . WithSteerMotorInitialConfigs ( steerInitialConfigs ) 119 . WithEncoderInitialConfigs ( encoderInitialConfigs ) 120 . WithSteerInertia ( kSteerInertia ) 121 . WithDriveInertia ( kDriveInertia ) 122 . WithSteerFrictionVoltage ( kSteerFrictionVoltage ) 123 . WithDriveFrictionVoltage ( kDriveFrictionVoltage ); 124 125 126 // Front Left 127 static constexpr int kFrontLeftDriveMotorId = 3 ; 128 static constexpr int kFrontLeftSteerMotorId = 2 ; 129 static constexpr int kFrontLeftEncoderId = 1 ; 130 static constexpr units :: turn_t kFrontLeftEncoderOffset = 0.15234375 _tr ; 131 static constexpr bool kFrontLeftSteerMotorInverted = true ; 132 static constexpr bool kFrontLeftEncoderInverted = false ; 133 134 static constexpr units :: inch_t kFrontLeftXPos = 10 _in ; 135 static constexpr units :: inch_t kFrontLeftYPos = 10 _in ; 136 137 // Front Right 138 static constexpr int kFrontRightDriveMotorId = 1 ; 139 static constexpr int kFrontRightSteerMotorId = 0 ; 140 static constexpr int kFrontRightEncoderId = 0 ; 141 static constexpr units :: turn_t kFrontRightEncoderOffset = -0.4873046875 _tr ; 142 static constexpr bool kFrontRightSteerMotorInverted = true ; 143 static constexpr bool kFrontRightEncoderInverted = false ; 144 145 static constexpr units :: inch_t kFrontRightXPos = 10 _in ; 146 static constexpr units :: inch_t kFrontRightYPos = -10 _in ; 147 148 // Back Left 149 static constexpr int kBackLeftDriveMotorId = 7 ; 150 static constexpr int kBackLeftSteerMotorId = 6 ; 151 static constexpr int kBackLeftEncoderId = 3 ; 152 static constexpr units :: turn_t kBackLeftEncoderOffset = -0.219482421875 _tr ; 153 static constexpr bool kBackLeftSteerMotorInverted = true ; 154 static constexpr bool kBackLeftEncoderInverted = false ; 155 156 static constexpr units :: inch_t kBackLeftXPos = -10 _in ; 157 static constexpr units :: inch_t kBackLeftYPos = 10 _in ; 158 159 // Back Right 160 static constexpr int kBackRightDriveMotorId = 5 ; 161 static constexpr int kBackRightSteerMotorId = 4 ; 162 static constexpr int kBackRightEncoderId = 2 ; 163 static constexpr units :: turn_t kBackRightEncoderOffset = 0.17236328125 _tr ; 164 static constexpr bool kBackRightSteerMotorInverted = true ; 165 static constexpr bool kBackRightEncoderInverted = false ; 166 167 static constexpr units :: inch_t kBackRightXPos = -10 _in ; 168 static constexpr units :: inch_t kBackRightYPos = -10 _in ; 169 170 171 public : 172 static constexpr swerve :: SwerveModuleConstants FrontLeft = ConstantCreator . CreateModuleConstants ( 173 kFrontLeftSteerMotorId , kFrontLeftDriveMotorId , kFrontLeftEncoderId , kFrontLeftEncoderOffset , 174 kFrontLeftXPos , kFrontLeftYPos , kInvertLeftSide , kFrontLeftSteerMotorInverted , kFrontLeftEncoderInverted ); 175 static constexpr swerve :: SwerveModuleConstants FrontRight = ConstantCreator . CreateModuleConstants ( 176 kFrontRightSteerMotorId , kFrontRightDriveMotorId , kFrontRightEncoderId , kFrontRightEncoderOffset , 177 kFrontRightXPos , kFrontRightYPos , kInvertRightSide , kFrontRightSteerMotorInverted , kFrontRightEncoderInverted ); 178 static constexpr swerve :: SwerveModuleConstants BackLeft = ConstantCreator . CreateModuleConstants ( 179 kBackLeftSteerMotorId , kBackLeftDriveMotorId , kBackLeftEncoderId , kBackLeftEncoderOffset , 180 kBackLeftXPos , kBackLeftYPos , kInvertLeftSide , kBackLeftSteerMotorInverted , kBackLeftEncoderInverted ); 181 static constexpr swerve :: SwerveModuleConstants BackRight = ConstantCreator . CreateModuleConstants ( 182 kBackRightSteerMotorId , kBackRightDriveMotorId , kBackRightEncoderId , kBackRightEncoderOffset , 183 kBackRightXPos , kBackRightYPos , kInvertRightSide , kBackRightSteerMotorInverted , kBackRightEncoderInverted ); 184 185 /** 186 * Creates a CommandSwerveDrivetrain instance. 187 * This should only be called once in your robot program. 188 */ 189 static subsystems :: CommandSwerveDrivetrain CreateDrivetrain (); 190 }; 191 192 193 /** 194 * \\brief Swerve Drive class utilizing CTR Electronics' Phoenix 6 API with the selected device types. 195 */ 196 class TunerSwerveDrivetrain : public swerve :: SwerveDrivetrain < hardware :: TalonFX , hardware :: TalonFX , hardware :: CANcoder > { 197 public : 198 using SwerveModuleConstants = swerve :: SwerveModuleConstants < configs :: TalonFXConfiguration , configs :: TalonFXConfiguration , configs :: CANcoderConfiguration > ; 199 200 /** 201 * \\brief Constructs a CTRE SwerveDrivetrain using the specified constants. 202 * 203 * This constructs the underlying hardware devices, so users should not construct 204 * the devices themselves. If they need the devices, they can access them 205 * through getters in the classes. 206 * 207 * \\param drivetrainConstants Drivetrain-wide constants for the swerve drive 208 * \\param modules Constants for each specific module 209 */ 210 template < std :: same_as < SwerveModuleConstants > ... ModuleConstants > 211 TunerSwerveDrivetrain ( swerve :: SwerveDrivetrainConstants const & driveTrainConstants , ModuleConstants const & ... modules ) : 212 SwerveDrivetrain { driveTrainConstants , modules ...} 213 {} 214 215 /** 216 * \\brief Constructs a CTRE SwerveDrivetrain using the specified constants. 217 * 218 * This constructs the underlying hardware devices, so users should not construct 219 * the devices themselves. If they need the devices, they can access them 220 * through getters in the classes. 221 * 222 * \\param drivetrainConstants Drivetrain-wide constants for the swerve drive 223 * \\param odometryUpdateFrequency The frequency to run the odometry loop. If 224 * unspecified or set to 0 Hz, this is 250 Hz on 225 * CAN FD, and 100 Hz on CAN 2.0. 226 * \\param modules Constants for each specific module 227 */ 228 template < std :: same_as < SwerveModuleConstants > ... ModuleConstants > 229 TunerSwerveDrivetrain ( 230 swerve :: SwerveDrivetrainConstants const & driveTrainConstants , 231 units :: hertz_t odometryUpdateFrequency , 232 ModuleConstants const & ... modules 233 ) : 234 SwerveDrivetrain { driveTrainConstants , odometryUpdateFrequency , modules ...} 235 {} 236 237 /** 238 * \\brief Constructs a CTRE SwerveDrivetrain using the specified constants. 239 * 240 * This constructs the underlying hardware devices, so users should not construct 241 * the devices themselves. If they need the devices, they can access them 242 * through getters in the classes. 243 * 244 * \\param drivetrainConstants Drivetrain-wide constants for the swerve drive 245 * \\param odometryUpdateFrequency The frequency to run the odometry loop. If 246 * unspecified or set to 0 Hz, this is 250 Hz on 247 * CAN FD, and 100 Hz on CAN 2.0. 248 * \\param odometryStandardDeviation The standard deviation for odometry calculation 249 * in the form [x, y, theta]ᵀ, with units in meters 250 * and radians 251 * \\param visionStandardDeviation The standard deviation for vision calculation 252 * in the form [x, y, theta]ᵀ, with units in meters 253 * and radians 254 * \\param modules Constants for each specific module 255 */ 256 template < std :: same_as < SwerveModuleConstants > ... ModuleConstants > 257 TunerSwerveDrivetrain ( 258 swerve :: SwerveDrivetrainConstants const & driveTrainConstants , 259 units :: hertz_t odometryUpdateFrequency , 260 std :: array < double , 3 > const & odometryStandardDeviation , 261 std :: array < double , 3 > const & visionStandardDeviation , 262 ModuleConstants const & ... modules 263 ) : 264 SwerveDrivetrain { 265 driveTrainConstants , odometryUpdateFrequency , 266 odometryStandardDeviation , visionStandardDeviation , modules ... 267 } 268 {} 269 }; C++ (Source) 1 #include \"generated/TunerConstants.h\" 2 #include \"subsystems/CommandSwerveDrivetrain.h\" 3 4 subsystems :: CommandSwerveDrivetrain TunerConstants::CreateDrivetrain () 5 { 6 return { DrivetrainConstants , FrontLeft , FrontRight , BackLeft , BackRight }; 7 } Python 1 class TunerConstants : 2 \"\"\" 3 Generated by the Tuner X Swerve Project Generator 4 https://v6.docs.ctr-electronics.com/en/stable/docs/tuner/tuner-swerve/index.html 5 \"\"\" 6 7 # Both sets of gains need to be tuned to your individual robot 8 9 # The steer motor uses any SwerveModule.SteerRequestType control request with the 10 # output type specified by SwerveModuleConstants.SteerMotorClosedLoopOutput 11 _steer_gains = ( 12 configs . Slot0Configs () 13 . with_k_p ( 100 ) 14 . with_k_i ( 0 ) 15 . with_k_d ( 0.5 ) 16 . with_k_s ( 0.1 ) 17 . with_k_v ( 1.91 ) 18 . with_k_a ( 0 ) 19 . with_static_feedforward_sign ( signals . StaticFeedforwardSignValue . USE_CLOSED_LOOP_SIGN ) 20 ) 21 # When using closed-loop control, the drive motor uses the control 22 # output type specified by SwerveModuleConstants.DriveMotorClosedLoopOutput 23 _drive_gains = ( 24 configs . Slot0Configs () 25 . with_k_p ( 0.1 ) 26 . with_k_i ( 0 ) 27 . with_k_d ( 0 ) 28 . with_k_s ( 0 ) 29 . with_k_v ( 0.124 ) 30 ) 31 32 # The closed-loop output type to use for the steer motors; 33 # This affects the PID/FF gains for the steer motors 34 _steer_closed_loop_output = swerve . ClosedLoopOutputType . VOLTAGE 35 # The closed-loop output type to use for the drive motors; 36 # This affects the PID/FF gains for the drive motors 37 _drive_closed_loop_output = swerve . ClosedLoopOutputType . VOLTAGE 38 39 # The type of motor used for the drive motor 40 _drive_motor_type = swerve . DriveMotorArrangement . TALON_FX_INTEGRATED 41 # The type of motor used for the drive motor 42 _steer_motor_type = swerve . SteerMotorArrangement . TALON_FX_INTEGRATED 43 44 # The remote sensor feedback type to use for the steer motors; 45 # When not Pro-licensed, Fused*/Sync* automatically fall back to Remote* 46 _steer_feedback_type = swerve . SteerFeedbackType . FUSED_CANCODER 47 48 # The stator current at which the wheels start to slip; 49 # This needs to be tuned to your individual robot 50 _slip_current : units . ampere = 120.0 51 52 # Initial configs for the drive and steer motors and the azimuth encoder; these cannot be null. 53 # Some configs will be overwritten; check the `with_*_initial_configs()` API documentation. 54 _drive_initial_configs = configs . TalonFXConfiguration () 55 _steer_initial_configs = configs . TalonFXConfiguration () . with_current_limits ( 56 configs . CurrentLimitsConfigs () 57 # Swerve azimuth does not require much torque output, so we can set a relatively low 58 # stator current limit to help avoid brownouts without impacting performance. 59 . with_stator_current_limit ( 60.0 ) . with_stator_current_limit_enable ( True ) 60 ) 61 _encoder_initial_configs = configs . CANcoderConfiguration () 62 # Configs for the Pigeon 2; leave this None to skip applying Pigeon 2 configs 63 _pigeon_configs : configs . Pigeon2Configuration | None = None 64 65 # CAN bus that the devices are located on; 66 # All swerve devices must share the same CAN bus 67 canbus = CANBus ( \"canivore\" , \"./logs/example.hoot\" ) 68 69 # Theoretical free speed (m/s) at 12 V applied output; 70 # This needs to be tuned to your individual robot 71 speed_at_12_volts : units . meters_per_second = 4.54 72 73 # Every 1 rotation of the azimuth results in _couple_ratio drive motor turns; 74 # This may need to be tuned to your individual robot 75 _couple_ratio = 3.8181818181818183 76 77 _drive_gear_ratio = 7.363636363636365 78 _steer_gear_ratio = 15.42857142857143 79 _wheel_radius : units . meter = inchesToMeters ( 2.167 ) 80 81 _invert_left_side = False 82 _invert_right_side = True 83 84 _pigeon_id = 1 85 86 # These are only used for simulation 87 _steer_inertia : units . kilogram_square_meter = 0.01 88 _drive_inertia : units . kilogram_square_meter = 0.01 89 # Simulated voltage necessary to overcome friction 90 _steer_friction_voltage : units . volt = 0.2 91 _drive_friction_voltage : units . volt = 0.2 92 93 drivetrain_constants = ( 94 swerve . SwerveDrivetrainConstants () 95 . with_can_bus_name ( canbus . name ) 96 . with_pigeon2_id ( _pigeon_id ) 97 . with_pigeon2_configs ( _pigeon_configs ) 98 ) 99 100 _constants_creator : swerve . SwerveModuleConstantsFactory [ configs . TalonFXConfiguration , configs . TalonFXConfiguration , configs . CANcoderConfiguration ] = ( 101 swerve . SwerveModuleConstantsFactory () 102 . with_drive_motor_gear_ratio ( _drive_gear_ratio ) 103 . with_steer_motor_gear_ratio ( _steer_gear_ratio ) 104 . with_coupling_gear_ratio ( _couple_ratio ) 105 . with_wheel_radius ( _wheel_radius ) 106 . with_steer_motor_gains ( _steer_gains ) 107 . with_drive_motor_gains ( _drive_gains ) 108 . with_steer_motor_closed_loop_output ( _steer_closed_loop_output ) 109 . with_drive_motor_closed_loop_output ( _drive_closed_loop_output ) 110 . with_slip_current ( _slip_current ) 111 . with_speed_at12_volts ( speed_at_12_volts ) 112 . with_drive_motor_type ( _drive_motor_type ) 113 . with_steer_motor_type ( _steer_motor_type ) 114 . with_feedback_source ( _steer_feedback_type ) 115 . with_drive_motor_initial_configs ( _drive_initial_configs ) 116 . with_steer_motor_initial_configs ( _steer_initial_configs ) 117 . with_encoder_initial_configs ( _encoder_initial_configs ) 118 . with_steer_inertia ( _steer_inertia ) 119 . with_drive_inertia ( _drive_inertia ) 120 . with_steer_friction_voltage ( _steer_friction_voltage ) 121 . with_drive_friction_voltage ( _drive_friction_voltage ) 122 ) 123 124 125 # Front Left 126 _front_left_drive_motor_id = 3 127 _front_left_steer_motor_id = 2 128 _front_left_encoder_id = 1 129 _front_left_encoder_offset : units . rotation = 0.15234375 130 _front_left_steer_motor_inverted = True 131 _front_left_encoder_inverted = False 132 133 _front_left_x_pos : units . meter = inchesToMeters ( 10 ) 134 _front_left_y_pos : units . meter = inchesToMeters ( 10 ) 135 136 # Front Right 137 _front_right_drive_motor_id = 1 138 _front_right_steer_motor_id = 0 139 _front_right_encoder_id = 0 140 _front_right_encoder_offset : units . rotation = - 0.4873046875 141 _front_right_steer_motor_inverted = True 142 _front_right_encoder_inverted = False 143 144 _front_right_x_pos : units . meter = inchesToMeters ( 10 ) 145 _front_right_y_pos : units . meter = inchesToMeters ( - 10 ) 146 147 # Back Left 148 _back_left_drive_motor_id = 7 149 _back_left_steer_motor_id = 6 150 _back_left_encoder_id = 3 151 _back_left_encoder_offset : units . rotation = - 0.219482421875 152 _back_left_steer_motor_inverted = True 153 _back_left_encoder_inverted = False 154 155 _back_left_x_pos : units . meter = inchesToMeters ( - 10 ) 156 _back_left_y_pos : units . meter = inchesToMeters ( 10 ) 157 158 # Back Right 159 _back_right_drive_motor_id = 5 160 _back_right_steer_motor_id = 4 161 _back_right_encoder_id = 2 162 _back_right_encoder_offset : units . rotation = 0.17236328125 163 _back_right_steer_motor_inverted = True 164 _back_right_encoder_inverted = False 165 166 _back_right_x_pos : units . meter = inchesToMeters ( - 10 ) 167 _back_right_y_pos : units . meter = inchesToMeters ( - 10 ) 168 169 170 front_left = _constants_creator . create_module_constants ( 171 _front_left_steer_motor_id , 172 _front_left_drive_motor_id , 173 _front_left_encoder_id , 174 _front_left_encoder_offset , 175 _front_left_x_pos , 176 _front_left_y_pos , 177 _invert_left_side , 178 _front_left_steer_motor_inverted , 179 _front_left_encoder_inverted , 180 ) 181 front_right = _constants_creator . create_module_constants ( 182 _front_right_steer_motor_id , 183 _front_right_drive_motor_id , 184 _front_right_encoder_id , 185 _front_right_encoder_offset , 186 _front_right_x_pos , 187 _front_right_y_pos , 188 _invert_right_side , 189 _front_right_steer_motor_inverted , 190 _front_right_encoder_inverted , 191 ) 192 back_left = _constants_creator . create_module_constants ( 193 _back_left_steer_motor_id , 194 _back_left_drive_motor_id , 195 _back_left_encoder_id , 196 _back_left_encoder_offset , 197 _back_left_x_pos , 198 _back_left_y_pos , 199 _invert_left_side , 200 _back_left_steer_motor_inverted , 201 _back_left_encoder_inverted , 202 ) 203 back_right = _constants_creator . create_module_constants ( 204 _back_right_steer_motor_id , 205 _back_right_drive_motor_id , 206 _back_right_encoder_id , 207 _back_right_encoder_offset , 208 _back_right_x_pos , 209 _back_right_y_pos , 210 _invert_right_side , 211 _back_right_steer_motor_inverted , 212 _back_right_encoder_inverted , 213 ) 214 215 @classmethod 216 def create_drivetrain ( cls ) -> CommandSwerveDrivetrain : 217 \"\"\" 218 Creates a CommandSwerveDrivetrain instance. 219 This should only be called once in your robot program. 220 \"\"\" 221 return CommandSwerveDrivetrain ( 222 hardware . TalonFX , 223 hardware . TalonFX , 224 hardware . CANcoder , 225 cls . drivetrain_constants , 226 [ 227 cls . front_left , 228 cls . front_right , 229 cls . back_left , 230 cls . back_right , 231 ], 232 )",
      "content_preview": "Swerve Builder API To simplify the API surface, both builder and factory paradigms are used. Users create a SwerveDrivetrain by first defining the global drivetrain characteristics and then each module characteristics. Note Phoenix 6 supports the Java units library when applicable."
    },
    {
      "url": "https://v6.docs.ctr-electronics.com/en/stable/docs/application-notes/canbus-latency-and-frequency.html",
      "title": "Latency and Frequency",
      "section": "Application Notes",
      "language": "All",
      "content": "Latency and Frequency Authored by Cory A common discussion with CAN-based sensors and actuators is how latency and update frequency affect robot performance. This devblog is meant to expand what these aspects are and how users can mitigate or eliminate them with Phoenix 6/Pro. Frequency Signal frequency largely affects two aspects for robots: Closed loop control Odometry Closed loop control is pretty clear, the slower the frequency, the greater the time gaps and the more you have to dampen a closed loop controller to keep it smooth. This becomes more important the less inertia your system has, such as with a swerve drive azimuth. At the inertia of a full robot, this becomes less important, as the robot can’t change its own heading fast enough for the lower frequency to have much of an impact. Odometry is a little less clear, but the gist is that odometry itself is generally an integration problem. If your data is coming in at a lower frequency, the integration isn’t as accurate, and so you accrue drift and error. This gets worse over time, which is why absolute odometry solutions such as april tag pose are so important at the high level to correct for it. Latency Latency itself isn’t so much an issue, but nondeterministic latency can be. If you aren’t getting data at a steady rate, it can negatively affect the odometry, as the time aspect of the integration problem is no longer constant. You can correct for this with latency compensation if you have the option to, but even that’s not a perfect solution as the latency corrected value may not be exactly correct to the real value at that point in time (although it’s certainly better than nothing). Solutions We (CTR Electronics) recognized these problems in general and wanted to solve them, which is why each of these problems are solved in the new Phoenix 6/Pro library and with CANivore. Fused CANcoder ( Pro ): By fusing in the CANcoder’s position into the Talon FX’s internal position, users ensure the position is always absolute while maintaining 1000hz update frequency and 0 latency for closed loop operations. This feature is improved when used with CANivore, as the CANcoder’s position can be latency-compensated and fused even when the mechanism is moving. Time Synchronization ( Pro & CANivore ): The CANivore provides the ability for Pro devices to synchronize to a common clock, which allows all the devices to sample data at the same time and publish data at the same time. This makes latency of data between devices minimal, and when used with our synchronize API keeps total latency low. Synchronous API ( v6 ): The synchronous API allows users to wait for data to arrive. By waiting for all the key data to arrive, the overall latency is reduced and users can update their robot’s data as soon as new data is available. Time Stamps ( v6 ): Every data is timestamped so users can perform latency compensation. The timestamp information is improved if used with a CANivore, as the CANivore timestamps the data once it arrives over the wire, providing a more accurate timestamp compared to when the RIO does the timestamping. Improved bus utilization ( v6 ): The improved bus utilization with v6 and further improvement with CANivore allow you to pretty easily increase the frequency of your key signals. We think it’s pretty achievable to get 200hz update frequencies (5ms periods) under a full robot. Every component outlined here is used in our SwerveDriveExample . If you’re interested in how to do it for yourself, I’d recommend looking at it and doing something similar.",
      "content_preview": "Latency and Frequency Authored by Cory A common discussion with CAN-based sensors and actuators is how latency and update frequency affect robot performance. This devblog is meant to expand what these aspects are and how users can mitigate or eliminate them with Phoenix 6/Pro."
    },
    {
      "url": "https://v6.docs.ctr-electronics.com/en/stable/docs/tuner/connecting.html",
      "title": "Connecting Tuner",
      "section": "Phoenix Tuner X",
      "language": "All",
      "content": "Connecting Tuner Installed onto the robot controller (either manually or via a robot program) is the Phoenix Diagnostics Server. This program enables communication between Tuner X and the robot controller for managing and setting up devices. Connecting to the Server A dropdown/textbox is available in the upper-left flyout menu. By clicking the arrow, you can change between presets such as: Driver Station – Retrieves the robot IP from the FRC Driver Station if launched roboRIO USB – Defaults to 172.22.11.2 which is the roboRIO IP when connected via USB localhost – Use for simulation or hardware-attached CANivore. Alternatively, the user can manually enter the robot IP into the textbox. Configuring SSH Credentials (non-FRC) When using a non-FRC robot controller (non-roboRIO) with SSH (instead of the default POST), credentials must be configured in Settings for general use. Temporary Diagnostics (FRC) Devices can be configured without a diagnostic server present. This can be useful if the roboRIO has been freshly imaged. Ensure that you are pointed at the roboRIO IP address (usually 10.TE.AM.2 where TE.AM is the team number) and then click the Run Temporary Diagnostic Server . Changing Diagnostics Server Port (non-FRC) The target server port can be changed in the Tuner X Settings page, which is accessed from the flyout menu. Important The default port for diagnostic server is 1250. FRC users should not change this.",
      "content_preview": "Connecting Tuner Installed onto the robot controller (either manually or via a robot program) is the Phoenix Diagnostics Server. This program enables communication between Tuner X and the robot controller for managing and setting up devices."
    },
    {
      "url": "https://v6.docs.ctr-electronics.com/en/stable/docs/api-reference/api-usage/actuator-limits.html",
      "title": "Actuator Limits",
      "section": "API Reference",
      "language": "All",
      "content": "Actuator Limits CTR Electronics actuators, such as the TalonFX, support various kinds of hardware and software limits. Note The TalonFX + Kraken X60 does not support hardware limit switches. Instead, control request limit overrides can be used, or a CANcoder/CANdi™/CANrange can be used as a remote limit switch . Documentation on wiring limit switches can be found here . Retrieving Limit Switch State The state of the forward or reverse limit switch can be retrieved from the API via getForwardLimit() and getReverseLimit() . Additionally, the state of the forward or reverse soft limit can be retrieved from the API via getFault_ForwardSoftLimit() and getFault_ReverseSoftLimit() . Java var forwardLimit = m_motor . getForwardLimit (); if ( forwardLimit . getValue () == ForwardLimitValue . ClosedToGround ) { // do action when forward limit is closed } var forwardSoftLimit = m_motor . getFault_ForwardSoftLimit (); if ( forwardSoftLimit . getValue ()) { // do action when forward soft limit is reached } C++ auto & forwardLimit = m_motor . GetForwardLimit (); if ( forwardLimit . GetValue () == signals :: ForwardLimitValue :: ClosedToGround ) { // do action when forward limit is closed } auto & forwardSoftLimit = m_motor . GetFault_ForwardSoftLimit (); if ( forwardSoftLimit . GetValue ()) { // do action when forward soft limit is reached } Python forward_limit = self . motor . get_forward_limit () if forward_limit . value is signals . ForwardLimitValue . CLOSED_TO_GROUND : # do action when forward limit is closed forward_soft_limit = self . motor . get_fault_forward_soft_limit () if forward_soft_limit . value : # do action when forward soft limit is reached Control Request Limits Many control requests support overriding the limit switch values using LimitForwardMotion and LimitReverseMotion parameters ( Java , C++ , Python ). These allow users to use other limit switch sensors connected to the robot controller. Java final DigitalInput m_forwardLimit = new DigitalInput ( 0 ); final DigitalInput m_reverseLimit = new DigitalInput ( 1 ); final DutyCycleOut m_dutyCycle = new DutyCycleOut ( 0.0 ); m_motor . setControl ( m_dutyCycle . withOutput ( 0.5 ) . withLimitForwardMotion ( m_forwardLimit . get ()) . withLimitReverseMotion ( m_reverseLimit . get ()) ); C++ frc :: DigitalInput m_forwardLimit { 0 }; frc :: DigitalInput m_reverseLimit { 1 }; controls :: DutyCycleOut m_dutyCycle { 0.0 }; m_motor . SetControl ( m_dutyCycle . WithOutput ( 0.5 ) . WithLimitForwardMotion ( m_forwardLimit . Get ()) . WithLimitReverseMotion ( m_reverseLimit . Get ()) ); Python self . forward_limit = wpilib . DigitalInput ( 0 ) self . reverse_limit = wpilib . DigitalInput ( 1 ) self . duty_cycle = controls . DutyCycleOut ( 0.0 ) self . motor . set_control ( self . duty_cycle . with_output ( 0.5 ) . with_limit_forward_motion ( self . forward_limit . get ()) . with_limit_reverse_motion ( self . reverse_limit . get ()) ) Remote Limit Switches Supported devices (TalonFX, CANifier, CANcoder, CANdi™, CANrange) can be utilized as a remote limit switch, disabling actuator outputs when triggers. When utilizing a CANcoder as a remote limit, the limit will trigger when the magnet strength changes from BAD (red) to ADEQUATE (orange) or GOOD (green). When utilizing a CANrange as a remote limit, the limit will trigger when the proximity detect is tripped following the ProximityParamsConfigs ( Java , C++ , Python ). When utilizing a CANdi™ as a remote limit, the limit will trigger when the S1Closed or S2Closed signal is true. The remote limit switch can be selected using the LimitSource and LimitRemoteSensorID configs. Java var limitConfigs = new HardwareLimitSwitchConfigs (); limitConfigs . ForwardLimitSource = ForwardLimitSourceValue . RemoteCANcoder ; limitConfigs . ForwardLimitRemoteSensorID = m_cancoder . getDeviceID (); m_motor . getConfigurator (). apply ( limitConfigs ); C++ configs :: HardwareLimitSwitchConfigs limitConfigs {}; limitConfigs . ForwardLimitSource = signals :: ForwardLimitSourceValue :: RemoteCANcoder ; limitConfigs . ForwardLimitRemoteSensorID = m_cancoder . GetDeviceID (); m_motor . GetConfigurator (). Apply ( limitConfigs ); Python limit_configs = configs . HardwareLimitSwitchConfigs () limit_configs . forward_limit_source = signals . ForwardLimitSourceValue . REMOTE_CANCODER limit_configs . forward_limit_remote_sensor_id = self . cancoder . device_id self . motor . configurator . apply ( limit_configs )",
      "content_preview": "Actuator Limits CTR Electronics actuators, such as the TalonFX, support various kinds of hardware and software limits. Note The TalonFX + Kraken X60 does not support hardware limit switches."
    },
    {
      "url": "https://v6.docs.ctr-electronics.com/en/stable/docs/api-reference/api-usage/signal-logging.html",
      "title": "Signal Logging",
      "section": "API Reference",
      "language": "All",
      "content": "Signal Logging Note Information on how to retrieve and convert hoot files to compatible formats can be found in Extracting Signal Logs . Phoenix 6 comes with a real-time, high-fidelity signal logger. This can be useful for any form of post analysis, including diagnosing issues after a match or using WPILib SysId . The Phoenix 6 signal logger provides the following advantages over alternatives: All status signals are captured automatically with their timestamps from CAN . Status signals are captured as they arrive at their configured update frequency. Logging is not affected by the timing of the main robot loop or Java GC, significantly improving the sensitivity and accuracy of system identification. Signal logging is started automatically during an FRC match by default. Custom user signals can be logged alongside the automatically captured status signals on the same timebase . The highly efficient hoot file format minimizes the size of the log files and the CPU usage of the logger. The signal logging API is available through static functions in the SignalLogger ( Java , C++ , Python ) class. Signal logging is enabled by default whenever it detects an FRC match is currently being played. Users can disable this behavior with SignalLogger.enableAutoLogging(false) ( Java , C++ , Python ). Tip Device status signals can also be viewed live in the Tuner X Plotting page . Setting Log Path The logging directory can optionally be changed using SignalLogger.setPath() ( Java , C++ , Python ). If the specified directory does not exist, SignalLogger.setPath() will return an error code. Setting the path while logging will restart the log. The below example sets the logging path to a ctre-logs folder on the first USB drive found. Java SignalLogger . setPath ( \"/media/sda1/ctre-logs/\" ); C++ SignalLogger :: SetPath ( \"/media/sda1/ctre-logs/\" ); Python SignalLogger . set_path ( \"/media/sda1/ctre-logs/\" ) Note Each CAN bus gets its own dedicated log file. Start/Stop Logging The signal logger can be started and stopped using the Start/Stop functions. Java SignalLogger . start (); SignalLogger . stop (); C++ SignalLogger :: Start (); SignalLogger :: Stop (); Python SignalLogger . start () SignalLogger . stop () Writing Custom Signals Users can write custom signals to the currently opened logs by utilizing the write*() functions. An example application of this is logging your swerve odometry data. The integer and floating-point write*() functions can optionally be supplied a units string to log alongside the data. Additionally, all write*() functions support an optional latency parameter that is subtracted from the current time to get the latency-adjusted timestamp of the signal. This can be useful for logging high-latency data, such as vision measurements. Java // Log the odometry pose as a double array SignalLogger . writeDoubleArray ( \"odometry\" , new double [] { pose . getX (), pose . getY (), pose . getRotation (). getDegrees ()}); // Log the odometry period with units of \"seconds\" SignalLogger . writeDouble ( \"odom period\" , state . OdometryPeriod , \"seconds\" ); // Log the camera pose with calculated latency SignalLogger . writeDoubleArray ( \"camera pose\" , new double [] { camPose . getX (), camPose . getY (), camPose . getRotation (). getDegrees ()}, \"\" , Timer . getFPGATimestamp () - camRes . getTimestampSeconds ()); C++ // Log the odometry pose as a double array SignalLogger :: WriteDoubleArray ( \"odometry\" , std :: array < double , 3 > { pose . X (). value (), pose . Y (). value (), pose . Rotation (). Degrees (). value ()}); // Log the odometry period with units of \"seconds\" SignalLogger :: WriteDouble ( \"odom period\" , state . OdometryPeriod , \"seconds\" ); // Log the camera pose with calculated latency SignalLogger :: WriteDoubleArray ( \"camera pose\" , std :: array < double , 3 > { camPose . X (). value (), camPose . Y (). value (), camPose . Rotation (). Degrees (). value ()}, \"\" , frc :: Timer :: GetFPGATimestamp () - camRes . GetTimestamp ()); Python # Log the odometry pose as a double array SignalLogger . write_double_array ( \"odometry\" , [ pose . X (), pose . Y (), pose . rotation () . degrees ()]) # Log the odometry period with units of \"seconds\" SignalLogger . write_double ( \"odom period\" , state . odometry_period , \"seconds\" ) # Log the camera pose with calculated latency SignalLogger . write_double_array ( \"camera pose\" , [ cam_pose . X (), cam_pose . Y (), cam_pose . rotation () . degrees ()], \"\" , wpilib . Timer . getFPGATimestamp () - cam_res . getTimestamp ()) Free Signals Any log that contains a pro-licensed device will export all signals. Otherwise, the following status signals and all custom signals can be exported for free. Click here to view free signals Common Signals VersionMajor VersionMinor VersionBugfix VersionBuild IsProLicensed SupplyVoltage Fault_UnlicensedFeatureInUse Fault_BootDuringEnable Fault_Hardware Fault_Undervoltage Talon FX SupplyCurrent StatorCurrent MotorVoltage Position Velocity DeviceEnable RobotEnable ConnectedMotor Fault_DeviceTemp Fault_ProcTemp Fault_RemoteSensorDataInvalid Fault_StaticBrakeDisabled Fault_BridgeBrownout Talon FXS SupplyCurrent StatorCurrent MotorVoltage Position Velocity DeviceEnable RobotEnable ConnectedMotor Fault_DeviceTemp Fault_ProcTemp Fault_RemoteSensorDataInvalid Fault_StaticBrakeDisabled Fault_BridgeBrownout Fault_HallSensorMissing Fault_DriveDisabledHallSensor Fault_MotorTempSensorMissing Fault_MotorTempSensorTooHot CANcoder Position Velocity Pigeon 2.0 Yaw AngularVelocityZWorld CANrange DistanceMeters ProximityDetected SignalStrength CANdi™ Pin1State Pin2State S1Closed S2Closed QuadPosition QuadVelocity Pwm1_Position Pwm1_Velocity Pwm2_Position Pwm2_Velocity Overcurrent Fault_5V CANdle® OutputCurrent DeviceTemp MaxSimultaneousAnimationCount Fault_Overvoltage Fault_5VTooHigh Fault_5VTooLow Fault_Thermal Fault_SoftwareFuse Fault_ShortCircuit Low Storage Space Behavior If the target drive (i.e. flash drive or roboRIO internal storage) reaches 50 MB free space, old logs will be deleted, and a warning will be printed. If the target drive reaches 5 MB of free space, logging will be stopped, and an error will be printed. Logging cannot be resumed until more disk space is made available. An example error that may occur if the free space limit is reached is shown below. [phoenix] Signal Logger: Available disk space (3 MB) below 5 MB, stopping log Converting Signal Logs Signal logs can be converted to other common file formats such as WPILOG or MCAP using the Tuner X Log Extractor . Additionally, the owlet CLI tool can be used from a terminal, including on platforms not supported by Tuner X. owlet can be downloaded from the CLI Tools download page . To view a list of available commands, run owlet either with no parameters or with --help . As an example, to convert a hoot file to WPILOG, run: ./owlet -f wpilog \"input.hoot\" \"output.wpilog\"",
      "content_preview": "Signal Logging Note Information on how to retrieve and convert hoot files to compatible formats can be found in Extracting Signal Logs . Phoenix 6 comes with a real-time, high-fidelity signal logger."
    },
    {
      "url": "https://v6.docs.ctr-electronics.com/en/stable/docs/hardware-reference/candi/index.html",
      "title": "CANdi™",
      "section": "General",
      "language": "All",
      "content": "CANdi™ The CTR Electronics’ CANdi™ branded device seamlessly integrates digital signals into existing CAN bus networks, simplifying wiring and allowing multiple devices to share and utilize valuable input data. CANdi™ enables CAN interopability with sensors such as: PWM encoders, Quadrature encoders, beam break sensors, and limit switches. Store Page CAD and purchase instructions. https://store.ctr-electronics.com/products/candi Blink Codes Animation (Click to play) LED State Cause Possible Fix LEDs Off No Power Provide 12V to V+ and V- inputs. Blinking Alternating Red CANdi™ does not have valid CAN. Ensure good connections between CANH and CANL (Yellow and Green) & robot controller is on. Blinking Alternating Green CANdi™ has a good CAN connection. Alternate Red/Orange Damaged Hardware. Use Tuner X Self Test to confirm the LEDs and that the hardware fault is set, then contact CTRE Single LED alternates Green/Orange CANdi™ in bootloader. Field-upgrade device in Tuner X.",
      "content_preview": "CANdi™ The CTR Electronics’ CANdi™ branded device seamlessly integrates digital signals into existing CAN bus networks, simplifying wiring and allowing multiple devices to share and utilize valuable input data."
    },
    {
      "url": "https://v6.docs.ctr-electronics.com/en/stable/docs/tuner/tuner-swerve/index.html",
      "title": "Swerve Project Generator",
      "section": "Phoenix Tuner X",
      "language": "All",
      "content": "Swerve Project Generator Important Full swerve project generation is only available for FRC users. However, non-FRC users can still generate the constants file. Under the Mechanisms page in Tuner X is the Swerve Project Generator. This utility guides the user through configuring their modules, verifying their drivetrain, encoder inverts, drivetrain inverts and more. Note The generated swerve project utilizes the Swerve API . Swerve Requirements Creating your Project Configuring Modules Validating the Drivetrain Generating the Project",
      "content_preview": "Swerve Project Generator Important Full swerve project generation is only available for FRC users. However, non-FRC users can still generate the constants file. Under the Mechanisms page in Tuner X is the Swerve Project Generator."
    },
    {
      "url": "https://v6.docs.ctr-electronics.com/en/stable/docs/api-reference/device-specific/talonfx/motion-magic.html",
      "title": "Motion Magic® Controls",
      "section": "TalonFX",
      "language": "All",
      "content": "Motion Magic® Controls In addition to basic PID control, the Talon FX also supports onboard motion profiling using Motion Magic® controls. Note For more information on feedback and feedforward gains, see Closed-Loop Overview . Motion Magic® Motion Magic® is a control mode that provides the benefit of Motion Profiling without needing to generate motion profile trajectory points. When using Motion Magic®, the motor will move to a target position using a motion profile, while honoring the user specified acceleration, maximum velocity (cruise velocity), and optional jerk. The benefits of this control mode over “simple” PID position closed-looping are: Control of the mechanism throughout the entire motion (as opposed to racing to the end target position) Control of the mechanism’s inertia to ensure smooth transitions between setpoints Improved repeatability despite changes in battery load Improved repeatability despite changes in motor load After gain/settings are determined, the robot controller only needs to periodically set the target position. There is no general requirement to “wait for the profile to finish”. However, the robot application can poll the sensor position and determine when the motion is finished if need be. Motion Magic® functions by generating a trapezoidal/S-Curve velocity profile that does not exceed the specified cruise velocity, acceleration, or jerk. This is done automatically by the motor controller. Note If the remaining sensor distance to travel is small, the velocity may not reach cruise velocity as this would overshoot the target position. This is often referred to as a “triangle profile”. If the Motion Magic® jerk is set to a nonzero value, the generated velocity profile is no longer trapezoidal, but instead is a continuous S-Curve (corner points are smoothed). An S-Curve profile has the following advantaged over a trapezoidal profile: Reducing oscillation of the mechanism. Maneuver is more deliberate and reproducible. Note The jerk control feature, by its nature, will increase the amount of time a movement requires. This can be compensated for by increasing the configured acceleration value. The following parameters must be set when controlling using Motion Magic® Cruise Velocity - peak/cruising velocity of the motion Acceleration - controls acceleration and deceleration rates during the beginning and end of motion Jerk (optional) - controls jerk, which is the derivative of acceleration Using Motion Magic® in API Motion Magic® is currently supported for all base control output types . The units of the output are determined by the control output type. The Motion Magic® jerk, acceleration, and cruise velocity can be configured in code using a MotionMagicConfigs ( Java , C++ , Python ) object. In Motion Magic®, the gains should be configured as follows: \\(K_g\\) - output to overcome gravity (output) \\(K_s\\) - output to overcome static friction (output) \\(K_v\\) - output per unit of target velocity (output/rps) \\(K_a\\) - output per unit of target acceleration (output/(rps/s)) \\(K_p\\) - output per unit of error in position (output/rotation) \\(K_i\\) - output per unit of integrated error in position (output/(rotation*s)) \\(K_d\\) - output per unit of error in velocity (output/rps) Java // in init function var talonFXConfigs = new TalonFXConfiguration (); // set slot 0 gains var slot0Configs = talonFXConfigs . Slot0 ; slot0Configs . kS = 0.25 ; // Add 0.25 V output to overcome static friction slot0Configs . kV = 0.12 ; // A velocity target of 1 rps results in 0.12 V output slot0Configs . kA = 0.01 ; // An acceleration of 1 rps/s requires 0.01 V output slot0Configs . kP = 4.8 ; // A position error of 2.5 rotations results in 12 V output slot0Configs . kI = 0 ; // no output for integrated error slot0Configs . kD = 0.1 ; // A velocity error of 1 rps results in 0.1 V output // set Motion Magic settings var motionMagicConfigs = talonFXConfigs . MotionMagic ; motionMagicConfigs . MotionMagicCruiseVelocity = 80 ; // Target cruise velocity of 80 rps motionMagicConfigs . MotionMagicAcceleration = 160 ; // Target acceleration of 160 rps/s (0.5 seconds) motionMagicConfigs . MotionMagicJerk = 1600 ; // Target jerk of 1600 rps/s/s (0.1 seconds) m_talonFX . getConfigurator (). apply ( talonFXConfigs ); C++ // in init function configs :: TalonFXConfiguration talonFXConfigs {}; // set slot 0 gains auto & slot0Configs = talonFXConfigs . Slot0 ; slot0Configs . kS = 0.25 ; // Add 0.25 V output to overcome static friction slot0Configs . kV = 0.12 ; // A velocity target of 1 rps results in 0.12 V output slot0Configs . kA = 0.01 ; // An acceleration of 1 rps/s requires 0.01 V output slot0Configs . kP = 4.8 ; // A position error of 2.5 rotations results in 12 V output slot0Configs . kI = 0 ; // no output for integrated error slot0Configs . kD = 0.1 ; // A velocity error of 1 rps results in 0.1 V output // set Motion Magic settings auto & motionMagicConfigs = talonFXConfigs . MotionMagic ; motionMagicConfigs . MotionMagicCruiseVelocity = 80 ; // Target cruise velocity of 80 rps motionMagicConfigs . MotionMagicAcceleration = 160 ; // Target acceleration of 160 rps/s (0.5 seconds) motionMagicConfigs . MotionMagicJerk = 1600 ; // Target jerk of 1600 rps/s/s (0.1 seconds) m_talonFX . GetConfigurator (). Apply ( talonFXConfigs ); Python # in init function talonfx_configs = configs . TalonFXConfiguration () # set slot 0 gains slot0_configs = talonfx_configs . slot0 slot0_configs . k_s = 0.25 # Add 0.25 V output to overcome static friction slot0_configs . k_v = 0.12 # A velocity target of 1 rps results in 0.12 V output slot0_configs . k_a = 0.01 # An acceleration of 1 rps/s requires 0.01 V output slot0_configs . k_p = 4.8 # A position error of 2.5 rotations results in 12 V output slot0_configs . k_i = 0 # no output for integrated error slot0_configs . k_d = 0.1 # A velocity error of 1 rps results in 0.1 V output # set Motion Magic settings motion_magic_configs = talonfx_configs . motion_magic motion_magic_configs . motion_magic_cruise_velocity = 80 # Target cruise velocity of 80 rps motion_magic_configs . motion_magic_acceleration = 160 # Target acceleration of 160 rps/s (0.5 seconds) motion_magic_configs . motion_magic_jerk = 1600 # Target jerk of 1600 rps/s/s (0.1 seconds) self . talonfx . configurator . apply ( talonfx_configs ) Tip Motion Magic® supports modifying cruise velocity, acceleration, and jerk on the fly (requires firmware version 24.0.6.0 or newer). Once the gains are configured, the Motion Magic® request can be sent to the TalonFX. The control request object has an optional feedforward term that can be used to add an arbitrary value to the output, which can be useful to account for the effects of gravity. Java // create a Motion Magic request, voltage output final MotionMagicVoltage m_request = new MotionMagicVoltage ( 0 ); // set target position to 100 rotations m_talonFX . setControl ( m_request . withPosition ( 100 )); C++ // create a Motion Magic request, voltage output controls :: MotionMagicVoltage m_request { 0 _tr }; // set target position to 100 rotations m_talonFX . SetControl ( m_request . WithPosition ( 100 _tr )); Python # create a Motion Magic request, voltage output self . request = controls . MotionMagicVoltage ( 0 ) # set target position to 100 rotations self . talonfx . set_control ( self . request . with_position ( 100 )) Dynamic Motion Magic® Important This feature requires the device to be Pro licensed and on a CANivore . When unlicensed, the TalonFX will disable control output and trip the UnlicensedFeatureInUse fault. When using a Pro-licensed Talon FX connected to a CANivore, Dynamic Motion Magic® can be used, allowing for the cruise velocity, acceleration, and jerk to be modified directly in the control request during motion. This can be used to set up different values for acceleration vs deceleration or to speed up and slow down the profile on the fly. The gain slots are configured in the same way as a regular Motion Magic® request. However, the cruise velocity, acceleration, and jerk parameters are set up in the control request, not the Motion Magic® config group. Once the gains are configured, the Dynamic Motion Magic® request can be sent to the TalonFX. The control request object has an optional feedforward term that can be used to add an arbitrary value to the output, which can be useful to account for the effects of gravity. Java // create a Dynamic Motion Magic request, voltage output // default velocity of 80 rps, acceleration of 400 rot/s^2, and jerk of 4000 rot/s^3 final DynamicMotionMagicVoltage m_request = new DynamicMotionMagicVoltage ( 0 , 80 , 400 , 4000 ); if ( m_joy . getAButton ()) { // while the joystick A button is held, use a slower profile m_request . Velocity = 40 ; // rps m_request . Acceleration = 80 ; // rot/s^2 m_request . Jerk = 400 ; // rot/s^3 } else { // otherwise use a faster profile m_request . Velocity = 80 ; // rps m_request . Acceleration = 400 ; // rot/s^2 m_request . Jerk = 4000 ; // rot/s^3 } // set target position to 100 rotations m_talonFX . setControl ( m_request . withPosition ( 100 )); C++ // create a Dynamic Motion Magic request, voltage output // default velocity of 80 rps, acceleration of 400 rot/s^2, and jerk of 4000 rot/s^3 controls :: DynamicMotionMagicVoltage m_request { 0 _tr , 80 _tps , 400 _tr_per_s_sq , 4000 _tr_per_s_cu }; if ( m_joy . GetAButton ()) { // while the joystick A button is held, use a slower profile m_request . Velocity = 40 _tps ; m_request . Acceleration = 80 _tr_per_s_sq ; m_request . Jerk = 400 _tr_per_s_cu ; } else { // otherwise use a faster profile m_request . Velocity = 80 _tps ; m_request . Acceleration = 400 _tr_per_s_sq ; m_request . Jerk = 4000 _tr_per_s_cu ; } // set target position to 100 rotations m_talonFX . SetControl ( m_request . WithPosition ( 100 _tr )); Python # create a Dynamic Motion Magic request, voltage output # default velocity of 80 rps, acceleration of 400 rot/s^2, and jerk of 4000 rot/s^3 self . request = controls . DynamicMotionMagicVoltage ( 0 , 80 , 400 , 4000 ) if self . joy . getAButton (): # while the joystick A button is held, use a slower profile self . request . velocity = 40 # rps self . request . acceleration = 80 # rot/s^2 self . request . jerk = 400 # rot/s^3 else : # otherwise use a faster profile self . request . velocity = 80 # rps self . request . acceleration = 400 # rot/s^2 self . request . jerk = 4000 # rot/s^3 # set target position to 100 rotations self . talonfx . set_control ( self . request . with_position ( 100 )) Motion Magic® Velocity The Talon FX also supports onboard velocity motion profiling using Motion Magic® Velocity. When using Motion Magic® Velocity, the motor will ramp to a target velocity using a trapezoidal acceleration profile that honors the specified acceleration and optional jerk. The benefits of this control mode over “simple” PID velocity closed-looping are: Control of the mechanism throughout the entire motion (as opposed to racing to the end target velocity) Control of the mechanism’s inertia to ensure smooth transitions between setpoints Improved repeatability despite changes in battery load Improved repeatability despite changes in motor load After gain/settings are determined, the robot controller only needs to periodically set the target velocity. The following parameters must be set when controlling using Motion Magic® Velocity Acceleration - controls acceleration and deceleration rates during the beginning and end of motion Jerk (optional) - controls jerk, which is the derivative of acceleration Using Motion Magic® Velocity in API Motion Magic® Velocity is currently supported for all base control output types . The units of the output are determined by the control output type. The Motion Magic® Velocity jerk and acceleration can be configured in code using a MotionMagicConfigs ( Java , C++ , Python ) object. In Motion Magic® Velocity, the gains should be configured as follows: \\(K_g\\) - output to overcome gravity (output) \\(K_s\\) - output to overcome static friction (output) \\(K_v\\) - output per unit of target velocity (output/rps) \\(K_a\\) - output per unit of target acceleration (output/(rps/s)) \\(K_p\\) - output per unit of error in velocity (output/rps) \\(K_i\\) - output per unit of integrated error in velocity (output/rotation) \\(K_d\\) - output per unit of error derivative in velocity (output/(rps/s)) Java // in init function var talonFXConfigs = new TalonFXConfiguration (); // set slot 0 gains var slot0Configs = talonFXConfigs . Slot0 ; slot0Configs . kS = 0.25 ; // Add 0.25 V output to overcome static friction slot0Configs . kV = 0.12 ; // A velocity target of 1 rps results in 0.12 V output slot0Configs . kA = 0.01 ; // An acceleration of 1 rps/s requires 0.01 V output slot0Configs . kP = 0.11 ; // An error of 1 rps results in 0.11 V output slot0Configs . kI = 0 ; // no output for integrated error slot0Configs . kD = 0 ; // no output for error derivative // set Motion Magic Velocity settings var motionMagicConfigs = talonFXConfigs . MotionMagic ; motionMagicConfigs . MotionMagicAcceleration = 400 ; // Target acceleration of 400 rps/s (0.25 seconds to max) motionMagicConfigs . MotionMagicJerk = 4000 ; // Target jerk of 4000 rps/s/s (0.1 seconds) m_talonFX . getConfigurator (). apply ( talonFXConfigs ); C++ // in init function configs :: TalonFXConfiguration talonFXConfigs {}; // set slot 0 gains auto & slot0Configs = talonFXConfigs . Slot0 ; slot0Configs . kS = 0.25 ; // Add 0.25 V output to overcome static friction slot0Configs . kV = 0.12 ; // A velocity target of 1 rps results in 0.12 V output slot0Configs . kA = 0.01 ; // An acceleration of 1 rps/s requires 0.01 V output slot0Configs . kP = 0.11 ; // An error of 1 rps results in 0.11 V output slot0Configs . kI = 0 ; // no output for integrated error slot0Configs . kD = 0 ; // no output for error derivative // set Motion Magic Velocity settings auto & motionMagicConfigs = talonFXConfigs . MotionMagic ; motionMagicConfigs . MotionMagicAcceleration = 400 ; // Target acceleration of 400 rps/s (0.25 seconds to max) motionMagicConfigs . MotionMagicJerk = 4000 ; // Target jerk of 4000 rps/s/s (0.1 seconds) m_talonFX . GetConfigurator (). Apply ( talonFXConfigs ); Python # in init function talonfx_configs = configs . TalonFXConfiguration () # set slot 0 gains slot0_configs = talonfx_configs . slot0 slot0_configs . k_s = 0.25 # Add 0.25 V output to overcome static friction slot0_configs . k_v = 0.12 # A velocity target of 1 rps results in 0.12 V output slot0_configs . k_a = 0.01 # An acceleration of 1 rps/s requires 0.01 V output slot0_configs . k_p = 0.11 # An error of 1 rps results in 0.11 V output slot0_configs . k_i = 0 # no output for integrated error slot0_configs . k_d = 0 # no output for error derivative # set Motion Magic Velocity settings motion_magic_configs = talonfx_configs . motion_magic motion_magic_configs . motion_magic_acceleration = 400 # Target acceleration of 400 rps/s (0.25 seconds to max) motion_magic_configs . motion_magic_jerk = 4000 # Target jerk of 4000 rps/s/s (0.1 seconds) self . talonfx . configurator . apply ( talonfx_configs ) Tip Motion Magic® Velocity supports modifying acceleration and jerk on the fly (requires firmware version 24.0.6.0 or newer). Once the gains are configured, the Motion Magic® Velocity request can be sent to the TalonFX. The Motion Magic® Velocity request has an Acceleration parameter that can be used to override the profile acceleration during motion. If the Acceleration parameter is left 0, the acceleration config will be used instead. The control request object also has an optional feedforward term that can be used to add an arbitrary value to the output, which can be useful to account for the effects of gravity. Java // create a Motion Magic Velocity request, voltage output final MotionMagicVelocityVoltage m_request = new MotionMagicVelocityVoltage ( 0 ); if ( m_joy . getAButton ()) { // while the joystick A button is held, use a slower acceleration m_request . Acceleration = 100 ; // rot/s^2 } else { // otherwise, fall back to the config m_request . Acceleration = 0 ; } // set target velocity to 80 rps m_talonFX . setControl ( m_request . withVelocity ( 80 )); C++ // create a Motion Magic Velocity request, voltage output controls :: MotionMagicVelocityVoltage m_request { 0 _tps }; if ( m_joy . GetAButton ()) { // while the joystick A button is held, use a slower acceleration m_request . Acceleration = 100 _tr_per_s_sq ; } else { // otherwise, fall back to the config m_request . Acceleration = 0 _tr_per_s_sq ; } // set target velocity to 80 rps m_talonFX . SetControl ( m_request . WithVelocity ( 80 _tps )); Python # create a Motion Magic Velocity request, voltage output self . request = controls . MotionMagicVelocityVoltage ( 0 ) if self . joy . getAButton (): # while the joystick A button is held, use a slower acceleration self . request . acceleration = 100 # rot/s^2 else : # otherwise, fall back to the config self . request . acceleration = 0 # set target velocity to 80 rps self . talonfx . set_control ( self . request . with_velocity ( 80 )) Motion Magic® Expo Whereas traditional Motion Magic® generates a trapezoidal or S-Curve profile, Motion Magic® Expo generates an exponential profile. This allows the profile to best match the system dynamics, reducing both overshoot and time to target compared to a trapezoidal profile. Motion Magic® Expo uses the kV and kA characteristics of the system, as well as an optional cruise velocity. The Motion Magic® Expo kV and kA configs are separate from the slot gain configs, as they may use different units and have different behaviors. The Motion Magic® Expo kV represents the voltage required to maintain a given velocity and is in units of Volts/rps. Dividing the supply voltage by kV results in the maximum velocity of the profile. As a result, when supply voltage is fixed, a higher profile kV results in a lower profile velocity . Unlike with gain slots, it is safer to start from a higher kV than what is ideal. The Motion Magic® Expo kA represents the voltage required to apply a given acceleration and is in units of Volts/(rps/s). Dividing the supply voltage by kA results in the maximum acceleration of the profile from 0. As a result, when supply voltage is fixed, a higher profile kA results in a lower profile acceleration . Unlike with gain slots, it is safer to start from a higher kA than what is ideal. If the Motion Magic® cruise velocity is set to a non-zero value, the profile will only accelerate up to the cruise velocity. Otherwise, the profile will accelerate towards the maximum possible velocity based on the profile kV. The following parameters must be set when controlling using Motion Magic® Expo: Expo kV - voltage required to maintain a given velocity, in V/rps Expo kA - voltage required to apply a given acceleration, in V/(rps/s) Cruise Velocity (optional) - peak velocity of the profile; set to 0 to target the system’s max velocity Using Motion Magic® Expo in API Motion Magic® Expo is currently supported for all base control output types . The units of the output are determined by the control output type. The Motion Magic® Expo kV, kA, and cruise velocity can be configured in code using a MotionMagicConfigs ( Java , C++ , Python ) object. Important Unlike the gain slots, the MotionMagicExpo_kV and MotionMagicExpo_kA configs are always in output units of Volts. In Motion Magic® Expo, the gains should be configured as follows: \\(K_g\\) - output to overcome gravity (output) \\(K_s\\) - output to overcome static friction (output) \\(K_v\\) - output per unit of target velocity (output/rps) \\(K_a\\) - output per unit of target acceleration (output/(rps/s)) \\(K_p\\) - output per unit of error in position (output/rotation) \\(K_i\\) - output per unit of integrated error in position (output/(rotation*s)) \\(K_d\\) - output per unit of error in velocity (output/rps) Java // in init function var talonFXConfigs = new TalonFXConfiguration (); // set slot 0 gains var slot0Configs = talonFXConfigs . Slot0 ; slot0Configs . kS = 0.25 ; // Add 0.25 V output to overcome static friction slot0Configs . kV = 0.12 ; // A velocity target of 1 rps results in 0.12 V output slot0Configs . kA = 0.01 ; // An acceleration of 1 rps/s requires 0.01 V output slot0Configs . kP = 4.8 ; // A position error of 2.5 rotations results in 12 V output slot0Configs . kI = 0 ; // no output for integrated error slot0Configs . kD = 0.1 ; // A velocity error of 1 rps results in 0.1 V output // set Motion Magic Expo settings var motionMagicConfigs = talonFXConfigs . MotionMagic ; motionMagicConfigs . MotionMagicCruiseVelocity = 0 ; // Unlimited cruise velocity motionMagicConfigs . MotionMagicExpo_kV = 0.12 ; // kV is around 0.12 V/rps motionMagicConfigs . MotionMagicExpo_kA = 0.1 ; // Use a slower kA of 0.1 V/(rps/s) m_talonFX . getConfigurator (). apply ( talonFXConfigs ); C++ // in init function configs :: TalonFXConfiguration talonFXConfigs {}; // set slot 0 gains auto & slot0Configs = talonFXConfigs . Slot0 ; slot0Configs . kS = 0.25 ; // Add 0.25 V output to overcome static friction slot0Configs . kV = 0.12 ; // A velocity target of 1 rps results in 0.12 V output slot0Configs . kA = 0.01 ; // An acceleration of 1 rps/s requires 0.01 V output slot0Configs . kP = 4.8 ; // A position error of 2.5 rotations results in 12 V output slot0Configs . kI = 0 ; // no output for integrated error slot0Configs . kD = 0.1 ; // A velocity error of 1 rps results in 0.1 V output // set Motion Magic Expo settings auto & motionMagicConfigs = talonFXConfigs . MotionMagic ; motionMagicConfigs . MotionMagicCruiseVelocity = 0 ; // Unlimited cruise velocity motionMagicConfigs . MotionMagicExpo_kV = 0.12 ; // kV is around 0.12 V/rps motionMagicConfigs . MotionMagicExpo_kA = 0.1 ; // Use a slower kA of 0.1 V/(rps/s) m_talonFX . GetConfigurator (). Apply ( talonFXConfigs ); Python # in init function talonfx_configs = configs . TalonFXConfiguration () # set slot 0 gains slot0_configs = talonfx_configs . slot0 slot0_configs . k_s = 0.25 # Add 0.25 V output to overcome static friction slot0_configs . k_v = 0.12 # A velocity target of 1 rps results in 0.12 V output slot0_configs . k_a = 0.01 # An acceleration of 1 rps/s requires 0.01 V output slot0_configs . k_p = 4.8 # A position error of 2.5 rotations results in 12 V output slot0_configs . k_i = 0 # no output for integrated error slot0_configs . k_d = 0.1 # A velocity error of 1 rps results in 0.1 V output # set Motion Magic Expo settings motion_magic_configs = talonfx_configs . motion_magic motion_magic_configs . motion_magic_cruise_velocity = 0 # Unlimited cruise velocity motion_magic_configs . motion_magic_expo_k_v = 0.12 # kV is around 0.12 V/rps motion_magic_configs . motion_magic_expo_k_a = 0.1 # Use a slower kA of 0.1 V/(rps/s) self . talonfx . configurator . apply ( talonfx_configs ) Tip Motion Magic® Expo supports modifying cruise velocity, kV, and kA on the fly. Once the gains are configured, the Motion Magic® Expo request can be sent to the TalonFX. The control request object has an optional feedforward term that can be used to add an arbitrary value to the output, which can be useful to account for the effects of gravity. Java // create a Motion Magic Expo request, voltage output final MotionMagicExpoVoltage m_request = new MotionMagicExpoVoltage ( 0 ) // set target position to 100 rotations m_talonFX . setControl ( m_request . withPosition ( 100 )); C++ // create a Motion Magic Expo request, voltage output controls :: MotionMagicExpoVoltage m_request { 0 _tr } // set target position to 100 rotations m_talonFX . SetControl ( m_request . WithPosition ( 100 _tr )); Python # create a Motion Magic Expo request, voltage output self . request = controls . MotionMagicExpoVoltage ( 0 ) # set target position to 100 rotations self . talonfx . set_control ( self . request . with_position ( 100 ))",
      "content_preview": "Motion Magic® Controls In addition to basic PID control, the Talon FX also supports onboard motion profiling using Motion Magic® controls. Note For more information on feedback and feedforward gains, see Closed-Loop Overview ."
    },
    {
      "url": "https://v6.docs.ctr-electronics.com/en/stable/docs/tuner/pigeon-cal.html",
      "title": "Pigeon 2.0 Calibration",
      "section": "Pigeon 2",
      "language": "All",
      "content": "Pigeon 2.0 Calibration It is recommended that calibration is performed once the Pigeon 2.0 has been mounted to the robot. Calibration will calculate the optimal offsets to apply to ensure that Pose, Pitch and Yaw is 0 when the robot is considered “flat”. Users can access the calibration menu by clicking on the Pigeon 2.0 in Devices and clicking Calibration in the top right. Read through the on-screen instructions and click Begin Mount Calibration .",
      "content_preview": "Pigeon 2.0 Calibration It is recommended that calibration is performed once the Pigeon 2.0 has been mounted to the robot. Calibration will calculate the optimal offsets to apply to ensure that Pose, Pitch and Yaw is 0 when the robot is considered “flat”."
    },
    {
      "url": "https://v6.docs.ctr-electronics.com/en/stable/docs/canivore/canivore-setup.html",
      "title": "CANivore Setup",
      "section": "CANivore",
      "language": "All",
      "content": "CANivore Setup Installing for roboRIO Note Phoenix Tuner X requires a 2023 roboRIO image or newer to configure the CANivore. No additional steps are required. The roboRIO comes with the canivore-usb kernel module pre-installed. Installing for Linux (non-FRC) See CANivore Installation for information on setting up your Linux system for use with a CANivore. Viewing Attached CANivores Attached CANivores can be viewed in Phoenix Tuner X by selecting the CANivores page from the left-hand sidebar. You can specify the target system in the Target IP or Team # text box. Note The Phoenix Diagnostic Server must be running on the target system to use the CANivores page. Tip If you are connecting to CANivores on your local Windows machine, you can enable the CANivore USB toggle and set the target IP to localhost . This runs a diagnostic server within Tuner X so you do not need to run a robot project to communicate with CANivores. Field Upgrading CANivores A CANivore can be field updated using Phoenix Tuner X . Click or tap on the listed CANivore card to open the device details page. The CANivore can then be field upgraded via the dropdown or by manually selected a file: Phoenix Tuner X also allows the user to batch field upgrade CANivores from the list of CANivores in the same manner as batch field upgrading devices . Renaming CANivores CANivores can be given custom names for use within a robot program. This can be configured through Phoenix Tuner X on the specified device card.",
      "content_preview": "CANivore Setup Installing for roboRIO Note Phoenix Tuner X requires a 2023 roboRIO image or newer to configure the CANivore. No additional steps are required. The roboRIO comes with the canivore-usb kernel module pre-installed."
    },
    {
      "url": "https://v6.docs.ctr-electronics.com/en/stable/docs/migration/new-to-phoenix.html",
      "title": "Phoenix 6 Features",
      "section": "General",
      "language": "All",
      "content": "Phoenix 6 Features Phoenix 6 currently offers the following features and will further expand. Phoenix 6 The following features are available for free in the Phoenix 6 API. Comprehensive API Device signal getters return a StatusSignal object, expanding the functionality of status signals. Control devices with an extensive list of flexible, strongly-typed control request objects . Canonical Units Uses the popular C++ units library and standardizes on SI units. Provides overloads using the Java units library . Signals are documented with the unit type and the minimum and maximum values. Improved Device Control New and improved control output types and closed-loop configuration. Improved Motion Magic® with jerk control and support for modifying the profile on the fly. New Motion Magic® Expo control to use an exponential profile following system dynamics, reducing both overshoot and time to target. Kalman-based algorithms to reduce latency while maintaining smooth data. Swerve API High-performance Swerve API using synchronous, latency-compensated odometry. Eliminate the boilerplate from copying swerve template code. Supported in Java, C++, and Python. Minimized GC impact in Java and Python using native C++ implementation. Improved odometry performance with CANivore and Phoenix Pro. Tuner X Swerve Project Generator gets swerve drive up and running quickly. Built-in high-fidelity simulation support. Enhanced Support for CAN FD Improved CAN FD framing further reduces any CAN bus utilization issues. Larger CAN frames allow for the addition of more advanced features. New Tuner X Self Tests and Plotting Detailed and resolute self tests to improve debugging. Plot signals at the configured signal update frequency. Combine multiple signal axes together and customize display of signal plots. Free High-Fidelity Simulation Simulation closely follows the behavior of real hardware. Write unit-tests for your robot code, and make sure the robot works before deploying. Continuous Wrap Mode Takes the shortest path for continuous mechanisms. Ideal for mechanisms such as Swerve Drive Steer. Phoenix Pro Certain Phoenix 6 features require the device or CANivore to be Pro licensed . The list of features that require licensing is available below. Field Oriented Control (FOC) ~15% increase in peak power. Increased torque output; faster acceleration and higher speeds under load. Greater efficiency; the motor draws less current for the same output power, increasing battery life. Support for direct torque control . Time Base Synchronization Using CANivore Timesync , signals from all devices are sampled and published to the CAN bus at the same time. API can synchronously wait for data from multiple devices on a CANivore to arrive. Device timestamps captured when the signal is sampled provides best possible latency compensation. Fused CANcoder Fuse a CANcoder with the motor’s internal rotor, getting absolute data all the time while using the fast internal sensor for closed looping. Real-Time High-Fidelity Signal Logger Log all status signals from every device with timestamps from CAN. Data captured as it arrives at the full update rate of the status signals. Improved sensitivity and accuracy of system identification with WPILib SysId . Automatically starts logging during an FRC match. Support for custom user signals alongside auto-captured data. Efficient hoot logging format minimizes disk space and CPU usage. Export to multiple formats including WPILOG and MCAP. Free users can export a limited set of signals to WPILOG. Replay Hoot Logs Rerun your robot program in simulation using status signals and custom signals from a hoot log generated by the robot. No architecture changes necessary for automatic replay of device status signals. Robot automatically enables in the correct mode and runs through all maneuvers in the hoot log. Test code changes such as odometry improvements or failure condition detection and handling. Support for step timing and changing the speed of playback. Feature Breakdown A full comparison of features between the free Phoenix 6 API and Phoenix Pro is shown below. Feature Phoenix 6 (rio) Phoenix 6 + Pro (rio) Phoenix 6 (CANivore) Phoenix 6 + Pro (CANivore) Canonical Units x x x x Improved Bus Utilization x x x x CANcoder Always Absolute x x x x Kalman-based Velocity x x x x Synchronous Wait for Data x x x x System Timestamps x x x x Limited Signal Logger WPILOG Export x x x x Explicit Control Requests x x x x Motion Magic® x x x x Motion Magic® Velocity x x x x Motion Magic® Expo x x x x Continuous Wrap Mode x x x x Simple Differential Control x x x x Improved Self-Test Snapshot x x x x Improved Tuner X Plotting x x x x CANivore Timestamps x x CAN FD x x Field Oriented Control (FOC) x x Fused CANcoder + TalonFX x x Sync CANcoder + Talon FX x x Full Signal Logger Export x x Signal Logger MCAP Export x x Hoot Log Replay x x Time-Synced Signal Publishing x Device Timestamps x Dynamic Motion Magic® x Full Differential Control x Swerve API + ++ ++ +++ Note + The Swerve API is freely available; however, performance improves when used on a CANivore bus and further improves when used with Pro devices. For more information, see Factors that Impact Odometry .",
      "content_preview": "Phoenix 6 Features Phoenix 6 currently offers the following features and will further expand. Phoenix 6 The following features are available for free in the Phoenix 6 API. Comprehensive API Device signal getters return a StatusSignal object, expanding the functionality of status signals."
    },
    {
      "url": "https://v6.docs.ctr-electronics.com/en/stable/docs/hardware-reference/talonfxs/index.html",
      "title": "Talon FXS",
      "section": "General",
      "language": "All",
      "content": "Talon FXS Talon FXS is a versatile motor controller compatible with the CTRE software ecosystem. This standalone device seamlessly supports both brushless and brushed motors, offering unparalleled flexibility and performance. The Talon FXS supports the CTR Electronics Minion and other third-party motors. Talon FXS also employs methods to reduce hall sensor velocity measurement noise and phase delay - a common problem with similar standalone motor controllers. Phoenix Pro users also benefit with “Advanced Hall Support” which can increase motor peak efficiency as high as an additional 2% percentage points and further reduce velocity measurement noise, making it ideal for velocity closed loop modes. Store Page CAD and purchase instructions. https://store.ctr-electronics.com/products/talon-fxs Supported Motors CTR Electronics Minion Third-party NEO Third-party NEO 550 Third-party NEO Vortex with Solo Adapter Most 3rd party brushed motors Blink Codes Disabled Codes Animation (Click to play) LED State Cause Possible Fix LEDs Off No Power Provide 12V to Red/Black leads. Blinking Alternating Red Talon FXS does not have a valid CAN/PWM signal. Ensure good connections between CANH and CANL (Yellow and Green) & robot controller is on. Blinking Alternating Orange TalonFXS detects CAN but does not see Phoenix running on the robot controller. If Phoenix is running on the robot controller, ensure good connection between the controller and this device. Otherwise, deploy a robot program that uses Phoenix. Blinking Simultaneous Orange Talon FXS has valid CAN signal and is disabled. Phoenix is running in robot controller and Talon FXS has good CAN connection to robot controller. If robot is enabled, ensure a control request is being sent to the Talon FXS. Enabled Codes Both Solid Orange Talon FXS enabled with neutral output. Blinking Simultaneous Red Talon FXS driving in reverse. Rate of blink corresponds to duty cycle applied. Blinking Simultaneous Green Talon FXS driving forward. Rate of blink corresponds to duty cycle applied. Offset Alternating Red/Off Talon FXS limited (hard or soft limit). Direction of offset determines forward/reverse limit. Special Codes Offset Orange/Off Talon FXS in thermal cutoff or temperature measurement is missing. Please see \"Troubleshooting Fault LED\" for potential solutions. Alternate Red/Green Talon FXS driven with Pro-only command while unlicensed. Use non-Pro-only command, or license device for Pro. Alternate Orange/Green Talon FXS driven with no motor selected in motor arrangement. Configure the Talon FXS with the attached motor. Alternate Red/Orange Damaged Hardware. Use Tuner X Self Test to confirm the LEDs and that the hardware fault is set, then contact CTRE Single LED alternates Green/Orange Talon FXS in bootloader. Field-upgrade device in Tuner X. Troubleshooting Fault LED A Talon FXS thermal fault, as indicated with an “Offset Orange/Off” blink code, can be triggered for a variety of reasons. The following list can be used to help identify the reason and a potential solution. Brushless Motor JST is disconnected or damaged. Plug-in the motor JST cable into the JST port and ensure the cable is not damaged. Motor arrangement is incorrect. Please select the correct motor in configs . Talon FXS or motor has reached thermal cut-off. Allow time for the device to cool and consider configuring a Stator Current limit . Brushed Motor Motor arrangement is incorrect. Please select one of the brushed options in configs . Talon FXS has reached thermal cut-off. Allow time for the device to cool and consider configuring a Stator Current limit .",
      "content_preview": "Talon FXS Talon FXS is a versatile motor controller compatible with the CTRE software ecosystem. This standalone device seamlessly supports both brushless and brushed motors, offering unparalleled flexibility and performance."
    },
    {
      "url": "https://v6.docs.ctr-electronics.com/en/stable/docs/application-notes/tuning-canrange.html",
      "title": "Tuning CANrange",
      "section": "Application Notes",
      "language": "All",
      "content": "Tuning CANrange Authored by Cory We’ve had a number of people asking about how to tune their CANrange to identify that a game piece or robot component is being detected. This devblog covers the general strategy for tuning a CANrange. Signal Strength Tuning The first step to detection tuning is to verify that your distance measurement is a valid measurement. This is accomplished by looking at the signal strength, with higher values indicating more confident distance measurements. By default (as of 2025), we specify a minimum signal strength of 2500 to classify a distance measurement as “valid” for the purpose of our “isDetected” signal. Scenarios There are two primary scenarios that affect the signal strength for the CANrange. CANrange looks into open air when nothing is in front of it - This results in low signal strength under “not detected”, and high signal strength with some distance when “detected” CANrange looks at something further away when nothing is in front of it - This typically results in high signal strength regardless of if something is in front of it, but the distance shortens when something is in front of it. The first scenario requires Signal Strength tuning to identify the difference between open air and objects in front of the sensor. The process for tuning is to put an object in front of the CANrange, as if it would happen on the final mechanism, and measure the signal strength. Then, remove that object and measure the signal strength. Do this in as many configurations as is practical for the system and identify a signal strength threshold that will allow all detections when the object is present while disallowing as many of the detections when the object is not present as possible. Typically, in an open-air system this alone is sufficient to classify an object as detected or not. Distance Tuning Distance tuning is essentially the same process as signal strength tuning. Put an object in front of the CANrange, take a measurement, remove it, take a measurement, repeat. Just like in signal strength tuning, you place the distance threshold so that it splits the two scenarios as best as possible. In open air, the distance measurement may be unreliable when the object is not detected, in which case the signal strength should filter it out and reject it. For these cases, just ensure the distance threshold is above the distance when an object is present. Examples Example - Open Air The following is an example of a CANrange being used to detect an object and is otherwise pointing to open air. In the image, the distance measurement is unreliable at signal strengths below 2000, and very reliable when the strength is above 2000. Given that the signal strength alone is sufficient to detect game piece detection, we can specify a large distance threshold without much concern. In this case, I specified a distance threshold of 0.4 meters, despite the measured distance only being 0.11 meters. This results in the following IsDetected result. Which aligns nicely with when an object is placed in front of the CANrange and not. Example - Always Valid measurements The following is an example of a CANrange being used to detect an object when it’s also pointed at a backing material when the object is not present. In this scenario, note that the signal strength is always high, typically larger than 2000. However, the distance measurement is always valid, and we can instead rely on the distance thresholding for detection or not. In this case, a signal strength of 2000 is appropriate, and a distance threshold of 0.15 meters would cleanly identify when an object is detected or not. This results in the following plot. And this, too, aligns nicely when an object is placed in front of the CANrange. Example - Hysteresis In some cases, the object being detected results in a noisy distance measurement, and we want to avoid accidentally declaring an object as no longer detected when it is and vice versa. An increased hysteresis may be appropriate in this circumstance, as it will require the distance measurement to move beyond the threshold to account for this noise. Below is an example of such a case. In this scenario, we want the threshold to be approximately 0.115, however the distance measurement sometimes dips below that threshold when it is not detected and sometimes dips above that threshold when it is detected. In this case, we can place a hysteresis of approximately 0.01 to account for the dips above and below, resulting in the following. And in this scenario, the hysteresis correctly disallows the IsDetected signal from blipping while the distance measured crosses the threshold.",
      "content_preview": "Tuning CANrange Authored by Cory We’ve had a number of people asking about how to tune their CANrange to identify that a game piece or robot component is being detected. This devblog covers the general strategy for tuning a CANrange."
    },
    {
      "url": "https://v6.docs.ctr-electronics.com/en/stable/docs/tuner/device-list.html",
      "title": "Device List",
      "section": "Phoenix Tuner X",
      "language": "All",
      "content": "Device List Card Layout Grid Layout The Devices page is the first page that is shown to the user upon launching the application. The Devices page by default shows a grid of cards, but can be changed to a flat grid view (similar to Phoenix Tuner v1) by clicking on the 4 grid square icon located in the top right corner (not available in Android Tuner X). Card Colors The color of the device cards is helpful as a visual indicator of device state. The meaning of the card color is also shown as text underneath the device title. Color Description Green Device has latest firmware. Purple Device has an unexpected/beta firmware version. Yellow A new firmware version is available. Check the changelog to determine if the new version matters to your application Red Device has a duplicate ID. Blue Failed to retrieve list of available firmware. Clipboard Options & Licensing Phoenix Tuner X provides icons at the bottom right of each card that will allow the user to copy to the clipboard the device details, configs and Self Test. This can be useful for support requests and additional debugging. Devices that support CAN FD are shown via a CAN FD icon in the bottom right of the card. Note The CAN FD icon does not indicate that the device is currently on a CAN FD bus, merely that it supports CAN FD. The other major icon in the bottom right of the device card is the licensing indicator. This showcases the licensing states and when clicked, will open the licensing dialog. Batch Field Upgrade Phoenix Tuner X allows the user to batch field upgrade from the Devices page. The user can either select devices by their checkbox (in the top right corner of their respective card) or by selecting the checkmark icon in the top right. Tip Selecting a device using their checkbox and clicking the checkmark in the top right will select all devices of the same models Step 1 in the above image selects all devices of the same models selected (or all devices if no device is currently check-boxed). Step 2 in the above image opens the field-upgrade dialog. Once the dialog is opened, information detailing the device name, model, ID, and firmware version is presented. There is a year selector in the top-left corner to select the firmware version year. Once the correct firmware year is selected user can begin the upgrade progress by selecting Update to latest . If the user does not want to use the latest firmware version, the Custom year selection allows for the selection of a specific firmware version for each device model. Tip Generally, users should update their devices to the latest available firmware version. If manually selecting a CRF is important, the firmware files are available for download on our GitHub Repo . Important While the user can cancel firmware upgrading using the “X” button in the top-right, this will not cancel the current device in progress. It will finish upgrading the current device and will not upgrade subsequent devices. Typical Tuner X behavior will resume once the current device finishes flashing. Batch Licensing See Batch Activating Licenses",
      "content_preview": "Device List Card Layout Grid Layout The Devices page is the first page that is shown to the user upon launching the application. The Devices page by default shows a grid of cards, but can be changed to a flat grid view (similar to Phoenix Tuner v1) by clicking on the 4 grid square icon located in..."
    },
    {
      "url": "https://v6.docs.ctr-electronics.com/en/stable/docs/api-reference/mechanisms/index.html",
      "title": "Mechanisms",
      "section": "API Reference",
      "language": "All",
      "content": "Mechanisms This section serves to provide API usage of mechanisms supported by Phoenix 6. Swerve Documentation on the Phoenix 6 Swerve API Swerve Overview",
      "content_preview": "Mechanisms This section serves to provide API usage of mechanisms supported by Phoenix 6. Swerve Documentation on the Phoenix 6 Swerve API Swerve Overview"
    },
    {
      "url": "https://v6.docs.ctr-electronics.com/en/stable/docs/migration/canbus-utilization.html",
      "title": "CAN Bus Utilization",
      "section": "General",
      "language": "All",
      "content": "CAN Bus Utilization CTR Electronics goes through great efforts to make our products efficient on CAN bus bandwidth. This article highlights the average default bus utilization of supported Phoenix 6 devices. Users should keep total CAN bus utilization below 90% to prevent any unexpected behavior. Information on changing the default CAN update frequency is available in the status signal and control request documentation. Note Using Phoenix API will automatically start up a diagnostic server which adds a constant 0-5% total CAN bus utilization. Device Phoenix 5 (CAN 2.0) Phoenix 6 (CAN 2.0) Phoenix 5 (CAN FD) Phoenix 6 (CAN FD) [ 1 ] Talon FX 4.7% 4.1% 2.0% 1.8% CANcoder 1.8% 1.7% 0.9% 0.9% Pigeon 2 5.5% 3.1% 2.5% 1.3% [ 1 ] Phoenix 6 devices on CAN FD also increase the default update frequency of many status signals to 100 Hz.",
      "content_preview": "CAN Bus Utilization CTR Electronics goes through great efforts to make our products efficient on CAN bus bandwidth. This article highlights the average default bus utilization of supported Phoenix 6 devices. Users should keep total CAN bus utilization below 90% to prevent any unexpected behavior."
    },
    {
      "url": "https://v6.docs.ctr-electronics.com/en/stable/docs/api-reference/api-usage/status-signals.html",
      "title": "Status Signals",
      "section": "API Reference",
      "language": "All",
      "content": "Status Signals Signals represent live data reported by a device; these can be yaw, position, etc. To make use of the live data, users need to know the value, timestamp, latency, units, and error condition of the data. Additionally, users may need to synchronize with fresh data to minimize latency. Tip A Signal Logging API is available for logging received signals. This can be useful for any form of post analysis, including diagnosing issues after a match or using WPILib SysId . StatusSignal The StatusSignal ( Java , C++ , Python ) is a signal object that provides APIs to address all of the requirements listed above. The device object provides getters for all available signals. Each getter returns a StatusSignal that is typed appropriately for the signal. Note The device getters return a cached StatusSignal . As a result, frequently calling the getter does not influence RAM performance. Java var supplyVoltageSignal = m_device . getSupplyVoltage (); C++ auto & supplyVoltageSignal = m_device . GetSupplyVoltage (); Python supply_voltage_signal = self . device . get_supply_voltage () The value of the signal can be retrieved from the StatusSignal by calling getValue() . Java // get the value as a unit type var supplyVoltage = supplyVoltageSignal . getValue (); // convert the unit type to our desired units double supplyVoltageVolts = supplyVoltage . in ( Volts ); // alternatively, get the value as a double in the documented canonical units double supplyVoltage = supplyVoltageSignal . getValueAsDouble (); C++ // get the value as a unit type auto supplyVoltage = supplyVoltageSignal . GetValue (); // pull out the underlying value from the unit type double supplyVoltageVolts = supplyVoltage . value (); // alternatively, get the value as a double in the documented canonical units double supplyVoltage = supplyVoltageSignal . GetValueAsDouble (); Python supply_voltage = supply_voltage_signal . value Note Phoenix 6 utilizes the Java units library and C++ units library when applicable. Using the Java units library may increase GC overhead. The StatusCode ( Java , C++ , Python ) of the signal can be retrieved by calling getStatus() . This can be used to determine if the device is not present on the CAN bus. Note If a status signal is not available on the CAN bus, an error will be reported to the Driver Station. Refreshing the Signal Value The device StatusSignal getters implicitly refresh the cached signal values. However, if the user application caches the StatusSignal object, the refresh() method must be called to fetch fresh data. Multiple signals can be refreshed in one call using BaseStatusSignal.refreshAll() ( Java , C++ , Python ), which can improve performance compared to individual refreshes. Tip The refresh() method can be method-chained. As a result, you can call refresh() and getValue() on one line. Java // refresh the supply voltage signal supplyVoltageSignal . refresh (); // refresh the position and velocity signals BaseStatusSignal . refreshAll ( positionSignal , velocitySignal ); // refresh an array of differential signals BaseStatusSignal [] signals = { diffPositionSignal , diffVelocitySignal }; BaseStatusSignal . refreshAll ( signals ); C++ // refresh the supply voltage signal supplyVoltageSignal . Refresh (); // refresh the position and velocity signals BaseStatusSignal :: RefreshAll ( positionSignal , velocitySignal ); // refresh a std::array or std::vector of differential signals std :: vector < BaseStatusSignal *> signals { & diffPositionSignal , & diffVelocitySignal }; BaseStatusSignal :: RefreshAll ( signals ); Python # refresh the supply voltage signal supply_voltage_signal . refresh () # refresh the position and velocity signals BaseStatusSignal . refresh_all ( position_signal , velocity_signal ) # refresh a list of differential signals signals = [ diff_position_signal , diff_velocity_signal ] BaseStatusSignal . refresh_all ( signals ) Waiting for Signal Updates Instead of using the latest value, the user can instead opt to synchronously wait for a signal update. StatusSignal provides a waitForUpdate(timeoutSec) method that will block the current robot loop until the signal is retrieved or the timeout has been exceeded. This replaces the need to call refresh() on cached StatusSignal objects. Tip If you want to zero your sensors, you can use this API to ensure the set operation has completed before continuing program flow. Tip The waitForUpdate() method can be method-chained. As a result, you can call waitForUpdate() and getValue() on one line. Java // wait up to 1 robot loop iteration (20ms) for fresh data supplyVoltageSignal . waitForUpdate ( 0.020 ); C++ // wait up to 1 robot loop iteration (20ms) for fresh data supplyVoltageSignal . WaitForUpdate ( 20 _ms ); Python # wait up to 1 robot loop iteration (20ms) for fresh data supply_voltage_signal . wait_for_update ( 0.020 ) Changing Update Frequency All signals can have their update frequency configured via the setUpdateFrequency() method. Additionally, the update frequency of multiple signals can be specified at once using BaseStatusSignal.setUpdateFrequencyForAll() ( Java , C++ , Python ). Warning Increasing signal frequency will also increase CAN bus utilization, which can cause indeterminate behavior at high utilization rates (>90%). This is less of a concern when using CANivore, which uses the higher-bandwidth CAN FD bus. Java // disable supply voltage reporting (0 Hz) supplyVoltageSignal . setUpdateFrequency ( 0 ); // speed up position and velocity reporting to 200 Hz BaseStatusSignal . setUpdateFrequencyForAll ( 200 , positionSignal , velocitySignal ); // speed up array of differential signals to 100 Hz BaseStatusSignal [] signals = { diffPositionSignal , diffVelocitySignal }; BaseStatusSignal . setUpdateFrequencyForAll ( 100 , signals ); C++ // disable supply voltage reporting (0 Hz) supplyVoltageSignal . SetUpdateFrequency ( 0 _Hz ); // speed up position and velocity reporting to 200 Hz BaseStatusSignal :: SetUpdateFrequencyForAll ( 200 _Hz , positionSignal , velocitySignal ); // speed up std::array or std::vector of differential signals to 100 Hz std :: vector < BaseStatusSignal *> signals { & diffPositionSignal , & diffVelocitySignal }; BaseStatusSignal :: SetUpdateFrequencyForAll ( 100 _Hz , signals ); Python # disable supply voltage reporting (0 Hz) supply_voltage_signal . set_update_frequency ( 0 ) # speed up position and velocity reporting to 200 Hz BaseStatusSignal . set_update_frequency_for_all ( 200 , position_signal , velocity_signal ) # speed up list of differential signals to 100 Hz signals = [ diff_position_signal , diff_velocity_signal ] BaseStatusSignal . set_update_frequency_for_all ( 100 , signals ) When different update frequencies are specified for signals that share a status frame, the highest update frequency of all the relevant signals will be applied to the entire frame. Users can get a signal’s applied update frequency using the getAppliedUpdateFrequency() method. Signal update frequencies are automatically reapplied by the robot program on device reset. Optimizing Bus Utilization For users that wish to disable every unused status signal for their devices to reduce bus utilization, device objects have an optimizeBusUtilization() method ( Java , C++ , Python ). Additionally, multiple devices can be optimized at once using ParentDevice.optimizeBusUtilizationForAll() ( Java , C++ , Python ). When optimizing the bus utilization for devices, all status signals that have not been given an update frequency using setUpdateFrequency() will be disabled. This results in an opt-in model for status signals, maximizing the reduction in bus utilization. Tip Instead of disabling all unused status signals, an update frequency can be specified instead to keep them enabled at a slower update rate ( Java , c++ , Python ). This is useful when using Signal Logging . Warning When using followers, the leader motor must keep the DutyCycle , MotorVoltage , and TorqueCurrent status signals enabled. Additionally, remote sensors must keep related status signals enabled (such as position and velocity). Java m_pigeon . optimizeBusUtilization (); ParentDevice . optimizeBusUtilizationForAll ( m_leftMotor , m_rightMotor , m_cancoder ); C++ m_pigeon . OptimizeBusUtilization (); hardware :: ParentDevice :: OptimizeBusUtilizationForAll ( m_leftMotor , m_rightMotor , m_cancoder ); Python self . pigeon . optimize_bus_utilization () hardware . ParentDevice . optimize_bus_utilization_for_all ( self . left_motor , self . right_motor , self . cancoder ) Resetting All to Default The update frequencies of all status signals for a device can be reset to the defaults by calling resetSignalFrequencies() on the device ( Java , C++ , Python ). Additionally, multiple devices can be reset at once using ParentDevice.resetSignalFrequenciesForAll() ( Java , C++ , Python ). Since devices typically maintain their configured status signal update frequencies until they are power cycled, this can be useful to restore everything to the defaults before reconfiguring update frequencies. Java m_pigeon . resetSignalFrequencies (); ParentDevice . resetSignalFrequenciesForAll ( m_leftMotor , m_rightMotor , m_cancoder ); C++ m_pigeon . ResetSignalFrequencies (); hardware :: ParentDevice :: ResetSignalFrequenciesForAll ( m_leftMotor , m_rightMotor , m_cancoder ); Python self . pigeon . reset_signal_frequencies () hardware . ParentDevice . reset_signal_frequencies_for_all ( self . left_motor , self . right_motor , self . cancoder ) Timestamps The timestamps of a StatusSignal can be retrieved by calling getAllTimestamps() , which returns a collection of Timestamp ( Java , C++ , Python ) objects. The Timestamp objects can be used to perform latency compensation math. CANivore Timesync Important CANivore Timesync requires the devices or the CANivore to be Pro licensed . When using CANivore , the attached CAN devices will automatically synchronize their time bases. This allows devices to sample and publish their signals in a synchronized manner. Users can synchronously wait for these signals to update using BaseStatusSignal.waitForAll() ( Java , C++ , Python ). Tip waitForAll() with a timeout of zero matches the behavior of refreshAll() , performing a non-blocking refresh on all signals passed in. Because the devices are synchronized, time-critical signals are sampled and published on the same schedule. This combined with the waitForAll() routine means applications can considerably reduce the latency of the timesync signals. This is particularly useful for multi-device mechanisms, such as swerve odometry. Note When using a non-zero timeout, the signals passed into waitForAll() should have the same update frequency for synchronous data acquisition. This can be done by calling setUpdateFrequency() or by referring to the API documentation. The diagram below demonstrates the benefits of using timesync to synchronously acquire signals from multiple devices. Check the API documentation for information on whether a status signal supports CANivore Timesync. Java var talonFXPositionSignal = m_talonFX . getPosition (); var cancoderPositionSignal = m_cancoder . getPosition (); var pigeon2YawSignal = m_pigeon2 . getYaw (); BaseStatusSignal . waitForAll ( 0.020 , talonFXPositionSignal , cancoderPositionSignal , pigeon2YawSignal ); // can also send down an array of signals BaseStatusSignal [] signals = { talonFXPositionSignal , cancoderPositionSignal , pigeon2YawSignal }; BaseStatusSignal . waitForAll ( 0.020 , signals ); C++ auto & talonFXPositionSignal = m_talonFX . GetPosition (); auto & cancoderPositionSignal = m_cancoder . GetPosition (); auto & pigeon2YawSignal = m_pigeon2 . GetYaw (); BaseStatusSignal :: WaitForAll ( 20 _ms , talonFXPositionSignal , cancoderPositionSignal , pigeon2YawSignal ); // can also send down a std::array or std::vector of signal pointers std :: vector < BaseStatusSignal *> signals { & talonFXPositionSignal , & cancoderPositionSignal , & pigeon2YawSignal }; BaseStatusSignal :: WaitForAll ( 20 _ms , signals ); Python talonfx_position_signal = self . talonfx . get_position () cancoder_position_signal = self . cancoder . get_position () pigeon2_yaw_signal = self . pigeon2 . get_yaw () BaseStatusSignal . wait_for_all ( 0.020 , talonfx_position_signal , cancoder_position_signal , pigeon2_yaw_signal ) # can also send down a list of signals signals = [ talonfx_position_signal , cancoder_position_signal , pigeon2_yaw_signal ] BaseStatusSignal . wait_for_all ( 0.020 , signals ) Latency Compensation Users can perform latency compensation using BaseStatusSignal.getLatencyCompensatedValue() ( Java , C++ , Python ). Important getLatencyCompensatedValue() does not automatically refresh the signals. As a result, the user must ensure the signal and signalSlope parameters are refreshed before retrieving a compensated value. Java double compensatedTurns = BaseStatusSignal . getLatencyCompensatedValue ( m_motor . getPosition (), m_motor . getVelocity ()); C++ auto compensatedTurns = BaseStatusSignal :: GetLatencyCompensatedValue ( m_motor . GetPosition (), m_motor . GetVelocity ()); Python compensated_turns = BaseStatusSignal . get_latency_compensated_value ( self . motor . get_position (), self . motor . get_velocity ()) SignalMeasurement All StatusSignal objects have a getDataCopy() method that returns a new SignalMeasurement ( Java , C++ ) object. SignalMeasurement is a Passive Data Structure that provides all the information about a signal at the time of the getDataCopy() call, which can be useful for data logging. Warning getDataCopy() returns a new SignalMeasurement object every call. Java users should avoid using this API in RAM-constrained applications.",
      "content_preview": "Status Signals Signals represent live data reported by a device; these can be yaw, position, etc. To make use of the live data, users need to know the value, timestamp, latency, units, and error condition of the data. Additionally, users may need to synchronize with fresh data to minimize latency."
    },
    {
      "url": "https://v6.docs.ctr-electronics.com/en/stable/docs/yearly-changes/yearly-changelog.html",
      "title": "New for 2025",
      "section": "General",
      "language": "All",
      "content": "New for 2025 At CTR Electronics, we pride ourselves for taking our customer feedback seriously. The feedback our customers provide to us fosters a healthy and active developer ecosystem. Software changes constantly, as does our customers’ needs. We will continue to invest in our customers’ needs and we are proud to announce our changelog for the 2025 year! Firmware for the 2025 release of Phoenix 6 can be found by selecting “2025” in the firmware selection menu. The API vendordep for 2025 is available under https://maven.ctr-electronics.com/release/com/ctre/phoenix6/latest/Phoenix6-frc2025-latest.json . Users will need to update both firmware and API to make use of these features. Note This changelog is intended to highlight the major additions to the Phoenix 6 API. For a detailed list of changes and bug fixes, visit the API changelog . API Additional Swerve Language Support The implementation of the Swerve API has been moved to C++ to improve portability and performance. These changes result in a substantial performance improvement, as the odometry thread no longer pauses during Java garbage collection when using native Phoenix SwerveRequest calls. Custom swerve request calls are still available and can be composed with native requests (see FieldCentricFacingAngle ); however, their usage may not fully benefit from the performance improvements due to GC overhead. Note The previous Java swerve implementation is still available with the prefix Legacy added to it. With this change, we are also announcing Swerve API and Swerve Project Generator support for all three languages supported in FRC ( Java , C++ , Python ). We recommend all Java users regenerate their swerve projects to pick up new features and various other improvements to the 2025 Swerve API and project generator, including support for Talon FXS and CANdi™. Improved Swerve Requests After further testing, the SysId swerve requests have been improved to output usable gains for both drive and steer motors, as well as the HeadingController used in FieldCentricFacingAngle . ApplyChassisSpeeds has also been renamed to ApplyRobotSpeeds , and ApplyFieldSpeeds has been added to accept a field-centric ChassisSpeeds object. Additionally, ApplyRobotSpeeds and SwerveModule.apply() now optionally accept robot-relative wheel force feedforward vectors ( Java , C++ , Python ). Similarly, ApplyFieldSpeeds optionally accepts field-relative wheel force feedforward vectors. This allows the robot to more closely follow acceleration along autonomous paths. Java Units Support Support for the 2025 WPILib Java units has been added to many APIs. This support includes: Units for status signals Unit overloads for control request parameters (including constructors) Unit overloads for config arguments Swerve API support for units // status signals now return a unit type AngularVelocity velocity = m_motor . getVelocity (). getValue (); // users can alternatively use getValueAsDouble() to get a double value double velocity = m_motor . getVelocity (). getValueAsDouble (); // configs support units using the \"with\" decorators var currentConfigs = new CurrentLimitConfigs (). withStatorCurrentLimit ( Amps . of ( 120 )); // control requests support units for parameters m_motor . setControl ( m_motionMagicPosition . withPosition ( Degrees . of ( 90 ))); Important Users wishing to utilize the primitive double types with status signals can use getValueAsDouble() instead ( Java , C++ , Python ). Hoot Replay Hoot Replay is a new feature that allows users to playback their hoot logs in their robot program. This allows them to view and interact with their devices in simulation using measurements from real world IO. Important Hoot Replay requires the hoot log to have a Pro-licensed device. Currently, only one hoot log may be replayed at a time. Hoot Replay, controlled using the HootReplay class ( Java , C++ , Python ), supports playing back device status signals and custom user signals. Configs and control requests are ignored during replay. During Hoot Replay, the simulated robot will automatically enable and run through all the maneuvers recorded in the hoot log. Additionally, Hoot Replay supports step timing and changing the speed of the playback. Hoot Replay uses a different vendordep, found at https://maven.ctr-electronics.com/release/com/ctre/phoenix6/latest/Phoenix6-replay-frc2025-latest.json . This vendordep replaces Hardware-Attached Simulation with Hoot Replay. Note that only one Phoenix 6 vendordep may be used in the vendordeps folder at a time. Current Limiting Improvements Both supply and stator current limits now apply in TorqueCurrentFOC control. Additionally, supply current limiting is now more responsive and has been reworked to better prevent brownouts. Previously, when SupplyCurrentThreshold and SupplyTimeThreshold were configured, the Talon FX would allow unlimited supply current until it exceeded the SupplyCurrentThreshold for SupplyTimeThreshold , after which the SupplyCurrentLimit takes effect. This was useful to maximize motor performance without tripping breakers. However, it was ineffective at preventing brownouts. As a result, the behavior of the supply current limiter has been changed: The supply current limiter never allows more current draw than the configured SupplyCurrentLimit , preventing brownouts. SupplyCurrentThreshold and SupplyTimeThreshold have been replaced with (optional) SupplyCurrentLowerLimit and SupplyCurrentLowerTime parameters ( Java , C++ , Python ). If supply current has been limited for SupplyCurrentLowerTime , the supply current limit is reduced to the SupplyCurrentLowerLimit until current drops below the lower limit, preventing breaker trips. Additionally, the following default current limits are now in place: Stator current limit of 120 A Supply current limit of 70 A Supply current lower limit of 40 A after limiting (at 70 A) for 1 second Timesync Control For Pro-licensed devices on a CANivore, timesync can now be used with control requests to delay applying the request until a timesync boundary ( Java , C++ , Python ). This eliminates the impact of nondeterministic network delays in exchange for a larger but deterministic control latency. Deprecations/Removals Deprecated Pigeon2::getAngle() and Pigeon2::getRate() Deprecated TalonFX::setInverted() Removed SupplyCurrentThreshold and SupplyTimeThreshold Replaced the AbsoluteSensorRange config with AbsoluteSensorDiscontinuityPoint ( Java , C++ , Python ) TalonFX no longer directly implements MotorController The APIs associated with MotorController are still available, but this gives us the flexibility to make QOL adjustments to the API (such as returning StatusCodes) Miscellaneous API Improvements C++: Configs now use the C++ units library C++: Configs are now constexpr Python: Added WPILib integrations to device classes The CANBus API is now instantiable ( Java , C++ , Python ), and device constructors now have an overload accepting a CANBus object ( Java , C++ , Python ) Added an overload to device status signal getters to pull out the StatusSignal without refreshing ( Java , C++ , Python ) Added device object resetSignalFrequencies and ParentDevice.resetSignalFrequenciesForAll ( Java , C++ , Python ) to reset all status signal update frequencies to the defaults for all the provided devices Added IgnoreHardwareLimits to control requests ( Java , C++ , Python ); when enabled, the device will ignore hardware limit switches and the LimitForwardMotion / LimitReverseMotion parameters, instead allowing motor output Added Utils.fpgaToCurrentTime() helper function ( Java , C++ , Python ) to convert an FPGA timestamp to the timebase of Utils.getCurrentTimeSeconds() Robot state (teleop/auton/etc.) is now automatically logged in hoot files Simulation: Improved performance and fixed frequent stale frame warnings Simulation: Added support for simulating Pigeon 2 angular velocities ( Java , C++ , Python ) Improved API documentation of several configs, controls, and status signals Phoenix Tuner X Windows: https://apps.microsoft.com/detail/9NVV4PWDW27Z Android: https://play.google.com/store/apps/details?id=com.ctre.phoenix_tuner&hl=en_US macOS & iOS: https://apps.apple.com/us/app/phoenix-tuner-x/id6502530040 iOS and macOS Support Added support for iOS and macOS. The application is available for a one-time cost to offset Apple development costs. We are actively investigating making iOS and macOS Tuner X free for season pass licensed teams but we cannot offer a timeline at this time. Enhanced Plotting Plotting has been redone from the ground up to maximize accuracy, performance, and usability. Users can zoom and pan individual axes, and the entire plot. Explicit points have been added to indicate if there are gaps in retrieved data. Signals are plotted at their specified update frequency, ensuring there is no data lost. Plotter has been benchmarked for millions of points, maximizing plot performance. Clicking on the plot will bring up a selection box that will indicate the X/Y range of the provided selection. Hovering on the plot will highlight and show the value of the nearest point for all signals. Users can export the current enabled signals as a CSV. Added a new signal analysis tab (accessed at the bottom of the device page). Users can customize the visualization of their signals, specifying point markers, colors, min/max, grid lines, or reset zoom on an individual series Statistics tab shows real time statistics for the currently selected series Signals can be grouped together by adding a new group, then dragging the signals in them. Grouped signals will share minimum and maximum, and scale for all plot zoom and pan operations. QR Code Hot-Launch QR codes for a given device can be generated on desktop platforms. Individuals can scan the QR code on their mobile phone to launch Tuner navigating to the provided device. Notification Support Tuner X for Android and iOS supports notifications. Get notified when critical firmware or API releases are available. Miscellaneous Tuner Improvements Up to an 88% improvement in device navigation speed. Renamed the “Device History” tab to “Tuner History”, which contains both “Device History” and “Network History”. Network history highlights all previous robot networks that the Tuner has connected to. Added support for POST diagnostic requests, improving portability and performance. Added support for dynamically downloading the necessary version of Owlet for hoot. Added a changelog flyout in Tuner. Click on the bell icon at the bottom right to view the latest changes in Tuner, API, or firmware. Tuner Configs indicate if the current config value is not the default config value. Tuner Configs indicate if the current config value is not within the acceptable minimum and maximum range of the config. Added tooltips for enums and configs in Tuner. Invert is no longer a boolean config, but instead an enum which matches API. Infrastructure and Tooling We now publish an RSS feed at https://api.ctr-electronics.com/rss/rss.xml Additionally, there is now a webpage for downloading various CTR Electronics CLI utilities. These utilities include Owlet, Passerine, Phoenix Diagnostics Server, and Caniv. Please see the webpage for a description on what these tools are and how to download them. https://docs.ctr-electronics.com/cli-tools",
      "content_preview": "New for 2025 At CTR Electronics, we pride ourselves for taking our customer feedback seriously. The feedback our customers provide to us fosters a healthy and active developer ecosystem. Software changes constantly, as does our customers’ needs."
    },
    {
      "url": "https://v6.docs.ctr-electronics.com/en/stable/docs/tuner/controlling-devices.html",
      "title": "Controlling Devices",
      "section": "Phoenix Tuner X",
      "language": "All",
      "content": "Controlling Devices Tuner X can be used to directly control devices outside a robot program. When combined with Plotting , it can be an excellent tool for calculating closed loop gains or isolating mechanical issues. Devices can be controlled by clicking on the red “DISABLED” button, switching it to “ENABLED”. Important FRC users must enable the robot in Driver Station while using Tuner X control. During this time, the output can be adjusted using the sliders or the text entries below it. Control modes can be changed using the dropdown below the disable/enable button. FRC Locked The “lock” icon next to the “DISABLED” button indicates that this device is FRC locked. This means the FRC Driver Station must also be enabled for the device to actuate. For more information, see FRC Lock .",
      "content_preview": "Controlling Devices Tuner X can be used to directly control devices outside a robot program. When combined with Plotting , it can be an excellent tool for calculating closed loop gains or isolating mechanical issues."
    },
    {
      "url": "https://v6.docs.ctr-electronics.com/en/stable/docs/licensing/licensing.html",
      "title": "Device Licensing",
      "section": "General",
      "language": "All",
      "content": "Device Licensing Note Users utilizing season pass must attach a team number before continuing. See Attaching a Team Number to Season Pass for more information. All Phoenix 6 supported devices support device licensing. Additionally, CANivore is supported for licensing. When a CANivore is licensed, all devices on that bus are Pro enabled without additional activation. Important All license activation and verification features are only available in Phoenix Tuner X . Phoenix Tuner v1 does not support licensing actions. Purchasing a License Licenses can be purchased in the licensing section on the CTR Electronics store. Click here to purchase a license. Once a license has been purchased, you will receive an email confirmation confirming your purchase. Once this email is received, the license should be visible in the list of licenses in Tuner X. Activating a License Licenses are activated by first clicking on the LIC icon in the bottom right corner of the device card. This will open up a screen which displays a list of currently attached licenses for that device. Click on the Activate a new license button on the bottom of the popup. A list of purchased (but unattached) license seats are shown here. Click on the license you would like to redeem and press the Activate Selected License button to confirm redemption of that seat. Warning Users should be aware that license activation is permanent and irreversible Once the activation is complete, the license will be downloaded to the device. In the event that Tuner X disconnects from the internet or from the robot before this completes, the license is still activated and available for download the next time Tuner X is connected to the internet/robot. Batch Activating Licenses Tuner X also supports batch activating licenses from the Devices page. The user can either select devices by their checkbox (in the top right corner of their respective card) or by selecting the checkmark icon in the top right. Tip Selecting a device using their checkbox and clicking the checkmark in the top right will select all devices of the same models Step 1 in the above image selects all devices of the same models selected (or all devices if no device is currently check-boxed). Step 2 in the above image opens the batch licensing dialog. Once the dialog is opened, select a license from the dropdown at the top of the popup. The first list contains devices that will be batch licensed, while the second list contains devices that are ineligible due to one of the following: Device is not running Phoenix 6 firmware that supports licensing Device does not support the selected license Device is already licensed with the selected license The License devices button at the bottom of the popup shows the number of device licenses that will be applied and the number of seats currently available. After confirming that everything looks correct, press the License devices button to apply the licenses. Activating a License without a Robot Devices that have been seen by Tuner X at least once will be available in Device History . This can be useful for licensing a device when disconnected from the robot. Verifying Activation State An icon displaying the license state of your device is located in the bottom right of the device card. The below table can be used to determine your device license state for troubleshooting. State Image Description Licensed Device is licensed for the current version of the Phoenix 6 API. CANivore contains Licenses CANivore contains at least one bus license, which it will use to remote-license all compliant CAN devices. Pro Licensing Error Device is licensed and there was an error communicating license state. Licensing Error Device is not licensed and there was an error communicating license state. Not Licensed Device is not licensed for this version of the Phoenix 6 API. Licensing Not Supported Icon not present Device does not support licensing or is using an incompatible firmware for device licensing. Additionally, users can perform a Self Test to verify that the device has a valid license. Troubleshooting Did you activate a license for this device? Clicking on the icon will show licenses that are attached to this device Is the latest diagnostic server running? Check the version at the bottom of Tuner X’s devices page. Latest version details can be found in the changelog under the latest Phoenix-6/Libs version. Confirm the vendordep in your robot project is the latest version. Alternatively, you can deploy the temporary diagnostic server . Is the latest Phoenix 6 firmware flashed onto the device? FRC Only : If using Season Pass, is the roboRIO configured with the correct team number ?",
      "content_preview": "Device Licensing Note Users utilizing season pass must attach a team number before continuing. See Attaching a Team Number to Season Pass for more information. All Phoenix 6 supported devices support device licensing. Additionally, CANivore is supported for licensing."
    },
    {
      "url": "https://v6.docs.ctr-electronics.com/en/stable/docs/canivore/canivore-hardware-attached.html",
      "title": "Hardware",
      "section": "CANivore",
      "language": "All",
      "content": "Hardware-Attached Simulation CANivore supports hardware-attached simulation when used in an FRC robot program . This allows a CANivore to be used with real devices on supported host operating systems. The below video showcases controlling a real Falcon 500 in a robot program using hardware-attached simulation. To utilize hardware-attached simulation, ensure the CANivore is connected directly via USB to the machine running the simulation. All devices on the CANivore CAN Bus should be independently powered, as the CANivore does not provide power. In the robot program, the CANivore name or * must be specified in the device constructor. Important Any motors/actuators that have been connected to a roboRIO CAN Bus at any time must be factory defaulted due to them being FRC Locked . Factory defaulting can be done in Tuner X and should be done when the CANivore is not connected to a roboRIO. Java TalonFX m_motor = new TalonFX ( 0 , \"mycanivore\" ); C++ hardware :: TalonFX m_motor { 0 , \"mycanivore\" }; Python self . motor = hardware . TalonFX ( 0 , \"mycanivore\" ) Java/C++ In VS Code, select the 3 dots in the top-right, then select Hardware Sim Robot Code A message in the console should appear that the CAN Bus is connected. ********** Robot program startup complete ********** [phoenix] CANbus Connected: uno (WinUSB, 2B189E633353385320202034383803FF) [phoenix] CANbus Network Up: uno (WinUSB, 2B189E633353385320202034383803FF) [phoenix] Library initialization is complete. Python Simulation can be started using python -m robotpy sim Users may notice the robot program is using simulated devices by default. This is the default behavior if the host platform supports simulation (see requirements for a full list of supported platforms). In order for the robot program to communicate with physical devices (on platforms that support both simulation and hardware), the CTR_TARGET environment variable must be set. Examples of this are shown below. Windows $env:CTR_TARGET = \"Hardware\" # Set the environment variable, which will persist for the duration of this powershell instance. Linux export CTR_TARGET = Hardware # Export the environment variable so it's persistent in the shell Or CTR_TARGET = Hardware python3 application.py # Set the environment variable only for the python call",
      "content_preview": "Hardware-Attached Simulation CANivore supports hardware-attached simulation when used in an FRC robot program . This allows a CANivore to be used with real devices on supported host operating systems."
    },
    {
      "url": "https://v6.docs.ctr-electronics.com/en/stable/docs/tuner/tuner-history.html",
      "title": "Tuner History",
      "section": "Phoenix Tuner X",
      "language": "All",
      "content": "Tuner History Tuner history provides insight on past connected devices and robot networks. Device History allows teams to view previously connected devices and license them without being directly connected to them. Users may wish to license previously connected devices due to a lack of internet connection while being connected to them. Network History indicates a list of past connected robot networks. Users can access a list of past devices connected to Tuner X and license them via the Device History page. This is accessible from the left-hand sidebar. This list is not automatically refreshed, but users can refresh it by pressing the refresh icon in the top-right of the page. Licensing from Device History Users can activate a license for a disconnected device by clicking on the device in the Grid. Then, select the “PRO” icon at the bottom right of the device card. From there, the user can activate a license for the device like normal. Once the device license has been activated, the user still needs to connect Tuner X to the robot to transfer the activated license to the device. The “PRO” icon may be replaced with a greyed “LIC” icon in the following situations: The device is on Phoenix 5 firmware and actively connected to Tuner X The device is not a Phoenix 6 compatible device Users who license an eligible Phoenix 6 device running Phoenix 5 firmware must update the device firmware to v6 compatible firmware to utilize licensed features.",
      "content_preview": "Tuner History Tuner history provides insight on past connected devices and robot networks. Device History allows teams to view previously connected devices and license them without being directly connected to them."
    },
    {
      "url": "https://v6.docs.ctr-electronics.com/en/stable/docs/tuner/plotting.html",
      "title": "Plotting",
      "section": "Phoenix Tuner X",
      "language": "All",
      "content": "Plotting Phoenix Tuner X supports an accurate and highly performant real-time plotter. Users can plot and manipulate multiple signals simultaneously. Plotter has undergone strenuous stress testing to ensure hours of plotting operation. This can be used in conjunction with configs and control for tasks like tuning PID loops. Tuner supports plotting signals as they arrive, ensuring that every visible point is a signal update that has been sent by a device. Users can zoom in and hover over points for a tooltip highlighting the exact value of the datapoint. Adding a Signal Signals can be added from the right-side menu. Manipulating the Plot Horizontal Stretch Vertical Stretch Panning Box Selection The plot can be manipulated in a variety of ways: Click + Drag to pan around the plot Scroll over the X-axis or the plot to horizontally stretch the timescale Shift + Scroll over a signal’s Y-axis to vertically stretch that signal Shift + Scroll over the plot to vertically stretch all visible signals’ Y-axis Ctrl + Drag to pan across all signals’ Y-axis Additional Customizations The topbar of plotter contains a variety of options used for controlling data collection. Play : Play/Pauses the plotter. Points are not collected when the plotter is paused. Horizontal Tracking : Whether the horizontal axis should be locked to the most recent point. This automatically turns off when pan operations occur. Users can click this checkbox to keep their current Y-axis min/max but resume seeking at the beginning. Timespan : How long points should be kept before being discarded. Increasing this value will result in increased memory usage. Update Rate : How often to fetch points from the diagnostic server. Update rates larger than 100ms may result in lost points and lower update rates will result in increased CPU utilization. Export : Export currently visible signals to CSV. Clear Point : Remove all points and reset the plot back to its default state. Reset Zoom : Keep current points but reset horizontal and vertical zoom to its defaults A plot customization tab is available at the bottom of the device view. This tab allows users to group signals together (create a group with the Plus icon, and then drag signals over the group name), customize the color of the signal, explicitly set min/max, etc. Additionally, statistics for a signal can be viewed under Statistics .",
      "content_preview": "Plotting Phoenix Tuner X supports an accurate and highly performant real-time plotter. Users can plot and manipulate multiple signals simultaneously. Plotter has undergone strenuous stress testing to ensure hours of plotting operation."
    },
    {
      "url": "https://v6.docs.ctr-electronics.com/en/stable/docs/api-reference/simulation/index.html",
      "title": "Simulation",
      "section": "API Reference",
      "language": "All",
      "content": "Simulation Phoenix 6 supports comprehensive simulation support. All hardware features are available in simulation, including configs, control requests, simulated CAN bus timing, and Phoenix Tuner X support. Introduction to Simulation",
      "content_preview": "Simulation Phoenix 6 supports comprehensive simulation support. All hardware features are available in simulation, including configs, control requests, simulated CAN bus timing, and Phoenix Tuner X support. Introduction to Simulation"
    },
    {
      "url": "https://v6.docs.ctr-electronics.com/en/stable/docs/api-reference/api-usage/control-requests.html",
      "title": "Control Requests",
      "section": "API Reference",
      "language": "All",
      "content": "Control Requests Control Requests represent the output of a device. A list of control requests can be found in the API docs ( Java , C++ , Python ). Note Phoenix 6 utilizes the C++ units library and, optionally, the Java units library when applicable. Using the Java units library may increase GC overhead. Applying a Control Request Control requests can be applied by calling setControl() on the device object. setControl() returns a StatusCode ( Java , C++ , Python ) enum that represents success state. A successful request will return StatusCode.OK . Java // Command m_motor to 100% of duty cycle m_motor . setControl ( new DutyCycleOut ( 1.0 )); C++ // Command m_motor to 100% of duty cycle m_motor . SetControl ( controls :: DutyCycleOut { 1.0 }); Python # Command m_motor to 100% of duty cycle self . motor . set_control ( controls . DutyCycleOut ( 1.0 )) Modifying a Control Request Control requests are mutable, so they can be saved in a member variable and reused. For example, DutyCycleOut ( Java , C++ , Python ) has an Output member variable that can be manipulated, thus changing the output DutyCycle (proportion of supply voltage). Note Java users should reuse control requests to prevent excessive invocation of the Garbage Collector. Java final DutyCycleOut m_motorRequest = new DutyCycleOut ( 0.0 ); m_motorRequest . Output = 1.0 ; m_motor . setControl ( m_motorRequest ); C++ controls :: DutyCycleOut m_motorRequest { 0.0 }; m_motorRequest . Output = 1.0 ; m_motor . SetControl ( m_motorRequest ); Python self . motor_request = controls . DutyCycleOut ( 0.0 ) self . motor_request . output = 1.0 self . motor . set_control ( self . motor_request ) Method Chaining API Control requests also supports modification using method chaining. This can be useful for mutating multiple values of a control request. In Java, this can also be used to provide a unit type. Java // initialize torque current FOC request with 0 amps final TorqueCurrentFOC m_motorRequest = new TorqueCurrentFOC ( 0 ); // mutate request with output of 10 amps and max duty cycle 0.5 m_motor . setControl ( m_motorRequest . withOutput ( Amps . of ( 10 )). withMaxAbsDutyCycle ( 0.5 )); C++ // initialize torque current FOC request with 0 amps controls :: TorqueCurrentFOC m_motorRequest { 0 _A }; // mutate request with output of 10 amps and max duty cycle 0.5 m_motor . SetControl ( m_motorRequest . WithOutput ( 10 _A ). WithMaxAbsDutyCycle ( 0.5 )); Python # initialize torque current FOC request with 0 amps self . motor_request = controls . TorqueCurrentFOC ( 0 ) # mutate request with output of 10 amps and max duty cycle 0.5 self . motor . set_control ( self . motor_request . with_output ( 10 ) . with_max_abs_duty_cycle ( 0.5 )) Changing Update Frequency Control requests are automatically transmitted at a fixed update frequency. This update frequency can be modified by changing the UpdateFreqHz ( Java , C++ , Python ) field of the control request before sending it to the device. Java // create a duty cycle request final DutyCycleOut m_motorRequest = new DutyCycleOut ( 0 ); // reduce the update frequency to 50 Hz m_motorRequest . UpdateFreqHz = 50 ; C++ // create a duty cycle request controls :: DutyCycleOut m_motorRequest { 0 }; // reduce the update frequency to 50 Hz m_motorRequest . UpdateFreqHz = 50 ; Python # create a duty cycle request self . motor_request = controls . DutyCycleOut ( 0 ) # reduce the update frequency to 50 Hz self . motor_request . update_freq_hz = 50 Tip UpdateFreqHz can be set to 0 Hz to synchronously one-shot the control request. In this case, users must ensure the control request is sent periodically in their robot code. Therefore, we recommend users call setControl no slower than 20 Hz (50 ms) when the control is one-shot.",
      "content_preview": "Control Requests Control Requests represent the output of a device. A list of control requests can be found in the API docs ( Java , C++ , Python ). Note Phoenix 6 utilizes the C++ units library and, optionally, the Java units library when applicable."
    },
    {
      "url": "https://v6.docs.ctr-electronics.com/en/stable/docs/api-reference/device-specific/index.html",
      "title": "Device API",
      "section": "API Reference",
      "language": "All",
      "content": "Device API This section is intended to highlight any device-specific API functionality. This include features such as the TalonFX + CANcoder fusion, details on using TalonFX Control Requests , and more. TalonFX Introduction to TalonFX Control Open-Loop Control Closed-Loop Overview Basic PID and Profiling Motion Magic® Controls TalonFX Remote Sensors",
      "content_preview": "Device API This section is intended to highlight any device-specific API functionality. This include features such as the TalonFX + CANcoder fusion, details on using TalonFX Control Requests , and more."
    },
    {
      "url": "https://v6.docs.ctr-electronics.com/en/stable/docs/migration/migration-guide/index.html",
      "title": "API Migration",
      "section": "General",
      "language": "All",
      "content": "API Migration This section serves as a “cheat sheet” of commonly-used functions in Phoenix 5 and their equivalents in Phoenix 6. API Structure General structure of the Phoenix 6 namespaces and packages Configuration Configuring device configs in robot code Status Signals Using status signals to retrieve sensor data from devices Control Requests Using control requests to control the functionality of actuators, such as the TalonFX Closed-Loop Control Configuring and using closed-loop control requests Feature Replacements Other features replaced or improved upon in Phoenix 6",
      "content_preview": "API Migration This section serves as a “cheat sheet” of commonly-used functions in Phoenix 5 and their equivalents in Phoenix 6. API Structure General structure of the Phoenix 6 namespaces and packages Configuration Configuring device configs in robot code Status Signals Using status signals to..."
    },
    {
      "url": "https://v6.docs.ctr-electronics.com/en/stable/docs/hardware-reference/canrange/index.html",
      "title": "CANrange",
      "section": "General",
      "language": "All",
      "content": "CANrange CANrange is a CAN-enabled Time-of-Flight distance measurement sensor. This product uses laser measurements to calculate precise distance to a surface parallel to the sensor. Users can also configure the CANrange to act as a limit switch or beam break sensor in the Device Configs . Store Page CAD and purchase instructions. https://store.ctr-electronics.com/products/canrange Hardware User Manual https://ctre.download/files/user-manual/CANrange%20User’s%20Guide.pdf Blink Codes Animation (Click to play) LED State Cause Possible Fix LEDs Off No Power Provide 12V to V+ and V- inputs. Blinking Alternating Red CANrange does not have valid CAN. Ensure good connections between CANH and CANL (Yellow and Green) & robot controller is on. Blinking Alternating Orange CANrange has a good CAN connection. Measured distance is not within detection threshold. Blinking Alternating Green CANrange has a good CAN connection. Measured distance is within detection threshold. Alternate Red/Orange Damaged Hardware. Use Tuner X Self Test to confirm the LEDs and that the hardware fault is set, then contact CTRE Single LED alternates Green/Orange CANrange in bootloader. Field-upgrade device in Tuner X. The rate at which the LED is blinking can be used as a rough indicator of measured distance. For example, the below LED shows that the detected distance is close to the CANrange. Animation (Click to play)",
      "content_preview": "CANrange CANrange is a CAN-enabled Time-of-Flight distance measurement sensor. This product uses laser measurements to calculate precise distance to a surface parallel to the sensor. Users can also configure the CANrange to act as a limit switch or beam break sensor in the Device Configs ."
    },
    {
      "url": "https://v6.docs.ctr-electronics.com/en/stable/docs/api-reference/mechanisms/swerve/swerve-requests.html",
      "title": "Swerve Requests",
      "section": "API Reference",
      "language": "All",
      "content": "Swerve Requests Controlling the drivetrain is done using setControl(SwerveRequest) ( Java , C++ , Python ) which takes a given SwerveRequest ( Java , C++ , Python ). There are multiple pre-defined SwerveRequest implementations that cover the majority of use cases. In some advanced scenarios, users can also define their own. Applying a Request Requests are instantiated once and then mutated using various withX functions. In the example below, a FieldCentric ( Java , C++ , Python ) request is created and given values from a joystick. Java private double MaxSpeed = TunerConstants . kSpeedAt12Volts . in ( MetersPerSecond ); private double MaxAngularRate = RotationsPerSecond . of ( 0.75 ). in ( RadiansPerSecond ); private final SwerveRequest . FieldCentric m_driveRequest = new SwerveRequest . FieldCentric () . withDeadband ( MaxSpeed * 0.1 ). withRotationalDeadband ( MaxAngularRate * 0.1 ) // Add a 10% deadband . withDriveRequestType ( DriveRequestType . OpenLoopVoltage ) . withSteerRequestType ( SteerRequestType . MotionMagicExpo ); private final XboxController m_joystick = new XboxController ( 0 ); public final TunerSwerveDrivetrain drivetrain = TunerConstants . createDrivetrain (); @Override public void teleopPeriodic () { // Note that X is defined as forward according to WPILib convention, // and Y is defined as to the left according to WPILib convention. drivetrain . setControl ( m_driveRequest . withVelocityX ( - joystick . getLeftY () * MaxSpeed ) . withVelocityY ( - joystick . getLeftX () * MaxSpeed ) . withRotationalRate ( - joystick . getRightX () * MaxAngularRate ) ); } C++ private : units :: meters_per_second_t MaxSpeed = TunerConstants :: kSpeedAt12Volts ; units :: radians_per_second_t MaxAngularRate = 0.75 _tps ; swerve :: requests :: FieldCentric m_driveRequest = swerve :: requests :: FieldCentric {} . WithDeadband ( MaxSpeed * 0.1 ). WithRotationalDeadband ( MaxAngularRate * 0.1 ) // Add a 10% deadband . WithDriveRequestType ( swerve :: DriveRequestType :: OpenLoopVoltage ) . WithSteerRequestType ( swerve :: SteerRequestType :: MotionMagicExpo ); frc :: XboxController m_joystick { 0 }; public : TunerSwerveDrivetrain drivetrain { TunerConstants :: CreateDrivetrain ()}; void TeleopPeriodic () override { // Note that X is defined as forward according to WPILib convention, // and Y is defined as to the left according to WPILib convention. drivetrain . SetControl ( m_driveRequest . WithVelocityX ( - joystick . GetLeftY () * MaxSpeed ) . WithVelocityY ( - joystick . GetLeftX () * MaxSpeed ) . WithRotationalRate ( - joystick . GetRightX () * MaxAngularRate ) ); } Python self . _max_speed = ( TunerConstants . speed_at_12_volts ) self . _max_angular_rate = rotationsToRadians ( 0.75 ) self . _drive_request = ( swerve . requests . FieldCentric () . with_deadband ( self . _max_speed * 0.1 ) . with_rotational_deadband ( self . _max_angular_rate * 0.1 ) # Add a 10% deadband . with_drive_request_type ( swerve . SwerveModule . DriveRequestType . OPEN_LOOP_VOLTAGE ) . with_steer_request_type ( swerve . SwerveModule . SteerRequestType . MOTION_MAGIC_EXPO ) ) self . _joystick = XboxController ( 0 ) self . drivetrain = TunerConstants . create_drivetrain () def teleopPeriodic (): # Note that X is defined as forward according to WPILib convention, # and Y is defined as to the left according to WPILib convention. self . drivetrain . set_control ( self . _drive_request . with_velocity_x ( - self . _joystick . getLeftY () * self . _max_speed ) . with_velocity_y ( - self . _joystick . getLeftX () * self . _max_speed ) . with_rotational_rate ( - self . _joystick . getRightX () * self . _max_angular_rate ) ) Command-Based When using the command-based CommandSwerveDrivetrain generated by Tuner X, the applyRequest(Supplier<SwerveRequest>) method can instead be used to get a command that periodically applies the SwerveRequest returned by the lambda. Java private double MaxSpeed = TunerConstants . kSpeedAt12Volts . in ( MetersPerSecond ); private double MaxAngularRate = RotationsPerSecond . of ( 0.75 ). in ( RadiansPerSecond ); private final SwerveRequest . FieldCentric m_driveRequest = new SwerveRequest . FieldCentric () . withDeadband ( MaxSpeed * 0.1 ). withRotationalDeadband ( MaxAngularRate * 0.1 ) // Add a 10% deadband . withDriveRequestType ( DriveRequestType . OpenLoopVoltage ) . withSteerRequestType ( SteerRequestType . MotionMagicExpo ); private final CommandXboxController m_joystick = new CommandXboxController ( 0 ); public final CommandSwerveDrivetrain drivetrain = TunerConstants . createDrivetrain (); public void configureBindings () { // Note that X is defined as forward according to WPILib convention, // and Y is defined as to the left according to WPILib convention. drivetrain . setDefaultCommand ( // Drivetrain will execute this command periodically drivetrain . applyRequest (() -> m_driveRequest . withVelocityX ( - joystick . getLeftY () * MaxSpeed ) . withVelocityY ( - joystick . getLeftX () * MaxSpeed ) . withRotationalRate ( - joystick . getRightX () * MaxAngularRate ) ) ); // Idle while the robot is disabled. This ensures the configured // neutral mode is applied to the drive motors while disabled. final var idle = new SwerveRequest . Idle (); RobotModeTriggers . disabled (). whileTrue ( drivetrain . applyRequest (() -> idle ). ignoringDisable ( true ) ); } C++ private : units :: meters_per_second_t MaxSpeed = TunerConstants :: kSpeedAt12Volts ; units :: radians_per_second_t MaxAngularRate = 0.75 _tps ; swerve :: requests :: FieldCentric m_driveRequest = swerve :: requests :: FieldCentric {} . WithDeadband ( MaxSpeed * 0.1 ). WithRotationalDeadband ( MaxAngularRate * 0.1 ) // Add a 10% deadband . WithDriveRequestType ( swerve :: DriveRequestType :: OpenLoopVoltage ) . WithSteerRequestType ( swerve :: SteerRequestType :: MotionMagicExpo ); frc :: XboxController m_joystick { 0 }; public : subsystems :: CommandSwerveDrivetrain drivetrain { TunerConstants :: CreateDrivetrain ()}; void ConfigureBindings () { // Note that X is defined as forward according to WPILib convention, // and Y is defined as to the left according to WPILib convention. drivetrain . SetDefaultCommand ( // Drivetrain will execute this command periodically drivetrain . ApplyRequest ([ this ]() -> auto && { return m_driveRequest . WithVelocityX ( - joystick . GetLeftY () * MaxSpeed ) . WithVelocityY ( - joystick . GetLeftX () * MaxSpeed ) . WithRotationalRate ( - joystick . GetRightX () * MaxAngularRate ); }) ); // Idle while the robot is disabled. This ensures the configured // neutral mode is applied to the drive motors while disabled. frc2 :: RobotModeTriggers :: Disabled (). WhileTrue ( drivetrain . ApplyRequest ([] { return swerve :: requests :: Idle {}; }). IgnoringDisable ( true ) ); } Python self . _max_speed = ( TunerConstants . speed_at_12_volts ) self . _max_angular_rate = rotationsToRadians ( 0.75 ) self . _drive_request = ( swerve . requests . FieldCentric () . with_deadband ( self . _max_speed * 0.1 ) . with_rotational_deadband ( self . _max_angular_rate * 0.1 ) # Add a 10% deadband . with_drive_request_type ( swerve . SwerveModule . DriveRequestType . OPEN_LOOP_VOLTAGE ) . with_steer_request_type ( swerve . SwerveModule . SteerRequestType . MOTION_MAGIC_EXPO ) ) self . _joystick = CommandXboxController ( 0 ) self . drivetrain = TunerConstants . create_drivetrain () def configureButtonBindings () -> None : # Note that X is defined as forward according to WPILib convention, # and Y is defined as to the left according to WPILib convention. self . drivetrain . setDefaultCommand ( # Drivetrain will execute this command periodically self . drivetrain . apply_request ( lambda : ( self . _drive_request . with_velocity_x ( - self . _joystick . getLeftY () * self . _max_speed ) # Drive forward with negative Y (forward) . with_velocity_y ( - self . _joystick . getLeftX () * self . _max_speed ) # Drive left with negative X (left) . with_rotational_rate ( - self . _joystick . getRightX () * self . _max_angular_rate ) # Drive counterclockwise with negative X (left) ) ) ) # Idle while the robot is disabled. This ensures the configured # neutral mode is applied to the drive motors while disabled. idle = swerve . requests . Idle () Trigger ( DriverStation . isDisabled ) . whileTrue ( self . drivetrain . apply_request ( lambda : idle ) . ignoringDisable ( True ) ) Custom Swerve Requests In many cases, advanced control logic can live in the command applying the swerve request. For example, path following is typically implemented using a WPILib Command factory in the subsystem. Most path planning libraries generate the path setpoints in the main robot loop, and PID on the Pose2d must be run inline with setpoint generation. However, there are some advanced cases where it is beneficial to run some of the control logic at the higher update frequency of the odometry thread. To accomplish that, users can define custom swerve requests by implementing the SwerveRequest interface. In a custom swerve request, the control logic lives in the apply(...) method, which is called by the odometry thread. Important Custom swerve requests can have a performance cost compared to the native implementations. Additionally, the apply(...) method must be fast to avoid blocking odometry updates. Swerve Requests with Composition To maximize performance and minimize duplicate code, most custom swerve requests should be built on top of existing ones. For example, the built-in FieldCentricFacingAngle ( Java , C++ , Python ) request uses a regular FieldCentric request under the hood, as demonstrated below. Java private final FieldCentric m_fieldCentric = new FieldCentric (); @Override public StatusCode apply ( SwerveControlParameters parameters , SwerveModule <? , ? , ?> ... modulesToApply ) { Rotation2d angleToFace = TargetDirection ; if ( ForwardPerspective == ForwardPerspectiveValue . OperatorPerspective ) { /* If we're operator perspective, rotate the direction we want to face by the angle */ angleToFace = angleToFace . rotateBy ( parameters . operatorForwardDirection ); } double toApplyOmega = TargetRateFeedforward + HeadingController . calculate ( parameters . currentPose . getRotation (). getRadians (), angleToFace . getRadians (), parameters . timestamp ); /* The rest of the logic is the same as FieldCentric, so * set up and call FieldCentric's apply() method */ return m_fieldCentric . withVelocityX ( VelocityX ) . withVelocityY ( VelocityY ) . withRotationalRate ( toApplyOmega ) . withDeadband ( Deadband ) . withRotationalDeadband ( RotationalDeadband ) . withCenterOfRotation ( CenterOfRotation ) . withDriveRequestType ( DriveRequestType ) . withSteerRequestType ( SteerRequestType ) . withDesaturateWheelSpeeds ( DesaturateWheelSpeeds ) . withForwardPerspective ( ForwardPerspective ) . apply ( parameters , modulesToApply ); } C++ ctre :: phoenix :: StatusCode Apply ( swerve :: requests :: SwerveRequest :: ControlParameters const & parameters , std :: vector < std :: unique_ptr < swerve :: impl :: SwerveModuleImpl >> const & modulesToApply ) override { swerve :: Rotation2d angleToFace = TargetDirection ; if ( ForwardPerspective == swerve :: requests :: ForwardPerspectiveValue :: OperatorPerspective ) { /* If we're operator perspective, rotate the direction we want to face by the angle */ angleToFace = angleToFace . RotateBy ( parameters . operatorForwardDirection ); } units :: radians_per_second_t toApplyOmega = TargetRateFeedforward + units :: radians_per_second_t { HeadingController . Calculate ( parameters . currentPose . Rotation (). Radians (). value (), angleToFace . Radians (). value (), parameters . timestamp )}; /* The rest of the logic is the same as FieldCentric, so * set up and call FieldCentric's Apply() method */ return swerve :: requests :: FieldCentric {} . WithVelocityX ( VelocityX ) . WithVelocityY ( VelocityY ) . WithRotationalRate ( toApplyOmega ) . WithDeadband ( Deadband ) . WithRotationalDeadband ( RotationalDeadband ) . WithCenterOfRotation ( CenterOfRotation ) . WithDriveRequestType ( DriveRequestType ) . WithSteerRequestType ( SteerRequestType ) . WithDesaturateWheelSpeeds ( DesaturateWheelSpeeds ) . WithForwardPerspective ( ForwardPerspective ) . Apply ( parameters , modulesToApply ); } Python def __init__ ( self ): # ... self . __field_centric = FieldCentric () def apply ( self , parameters : swerve . SwerveControlParameters , modules_to_apply : list [ swerve . SwerveModule ] ) -> StatusCode : angle_to_face = self . target_direction if self . forward_perspective is swerve . requests . ForwardPerspectiveValue . OPERATOR_PERSPECTIVE : # If we're operator perspective, rotate the direction we want to face by the angle angle_to_face = angle_to_face . rotateBy ( parameters . operator_forward_direction ) to_apply_omega = self . target_rate_feedforward + self . heading_controller . calculate ( parameters . current_pose . rotation () . radians (), angle_to_face . radians (), parameters . timestamp ) # The rest of the logic is the same as FieldCentric, so # set up and call FieldCentric's apply() method return ( self . __field_centric . with_velocity_x ( self . velocity_x ) . with_velocity_y ( self . velocity_y ) . with_rotational_rate ( to_apply_omega ) . with_deadband ( self . deadband ) . with_rotational_deadband ( self . rotational_deadband ) . with_center_of_rotation ( self . center_of_rotation ) . with_drive_request_type ( self . drive_request_type ) . with_steer_request_type ( self . steer_request_type ) . with_desaturate_wheel_speeds ( self . desaturate_wheel_speeds ) . with_forward_perspective ( self . forward_perspective ) . apply ( parameters , modules_to_apply ) ) Swerve Requests with Module Targets In a few cases, none of the existing swerve request implementations may be suitable for the desired request. For example, there is no built-in swerve request that directly accepts an array of SwerveModuleState instances. In that situation, the custom swerve request can call apply(SwerveModule.ModuleRequest) ( Java , C++ , Python ) on each SwerveModule instance provided to the apply(...) method. Note, however, that this can negatively impact performance of the robot, both in terms of loop times and control accuracy, compared to reusing the built-in requests. As a result, we recommend converting to supported types, such as ChassisSpeeds , and reusing existing swerve requests, such as ApplyFieldSpeeds ( Java , C++ , Python ), whenever possible. Warning We recommend against using a custom swerve request for the WPILib SwerveControllerCommand , as it does not follow modern WPILib best practices. Instead, the command can be reimplemented as a command factory using ApplyFieldSpeeds to maximize performance. Java public class ApplyModuleStates implements SwerveRequest { public SwerveModuleState [] ModuleStates = new SwerveModuleState [ 0 ] ; @Override public StatusCode apply ( SwerveControlParameters parameters , SwerveModule <? , ? , ?> ... modulesToApply ) { var moduleRequest = new SwerveModule . ModuleRequest () . withUpdatePeriod ( parameters . updatePeriod ); for ( int i = 0 ; i < modulesToApply . length && i < ModuleStates . length ; ++ i ) { /* apply the SwerveModuleState to the module */ modulesToApply [ i ] . apply ( moduleRequest . withState ( ModuleStates [ i ] )); } } } C++ struct ApplyModuleStates : public swerve :: requests :: SwerveRequest { std :: vector < SwerveModuleState > ModuleStates ; ctre :: phoenix :: StatusCode Apply ( swerve :: requests :: SwerveRequest :: ControlParameters const & parameters , std :: vector < std :: unique_ptr < swerve :: impl :: SwerveModuleImpl >> const & modulesToApply ) override { auto moduleRequest = impl :: SwerveModuleImpl :: ModuleRequest {} . WithUpdatePeriod ( parameters . updatePeriod ); for ( size_t i = 0 ; i < modulesToApply . size () && i < ModuleStates . size (); ++ i ) { /* apply the SwerveModuleState to the module */ modulesToApply [ i ] -> Apply ( moduleRequest . WithState ( ModuleStates [ i ])); } } }; Python class ApplyModuleStates ( swerve . requests . SwerveRequest ): def __init__ ( self ): self . module_states : list [ SwerveModuleState ] = [] def apply ( self , parameters : swerve . SwerveControlParameters , modules_to_apply : list [ swerve . SwerveModule ] ) -> StatusCode : module_request = ( SwerveModule . ModuleRequest () . with_update_period ( parameters . update_period ) ) for ( module , state ) in zip ( modules_to_apply , self . module_states ): # apply the SwerveModuleState to the module module . apply ( module_request . with_state ( state )) } } Swerve Requests with Direct Control Swerve modules by default have some built-in control optimizations and support a limited set of control types. However, for something like the built-in SysId swerve requests, such high-level control may not be desirable. As a result, SwerveModule also has apply(ControlRequest drive, ControlRequest steer) ( Java , C++ , Python ) to directly apply control requests to the drive and steer motors. For example, the built-in SysIdSwerveSteerGains ( Java , C++ , Python ) request directly applies a CoastOut to the drive motor and a VoltageOut to the steer motor. Important We recommend against using this strategy in competition code, as it does not benefit from the built-in control optimizations. Java private final CoastOut m_driveRequest = new CoastOut (); private final VoltageOut m_steerRequest = new VoltageOut ( 0 ); @Override public StatusCode apply ( SwerveControlParameters parameters , SwerveModule <? , ? , ?> ... modulesToApply ) { for ( int i = 0 ; i < modulesToApply . length ; ++ i ) { /* directly apply the control requests to the drive and steer motors */ modulesToApply [ i ] . apply ( m_driveRequest , m_steerRequest . withOutput ( VoltsToApply )); } return StatusCode . OK ; } C++ ctre :: phoenix :: StatusCode Apply ( SwerveRequest :: ControlParameters const & parameters , std :: vector < std :: unique_ptr < impl :: SwerveModuleImpl >> const & modulesToApply ) override { for ( size_t i = 0 ; i < modulesToApply . size (); ++ i ) { /* directly apply the control requests to the drive and steer motors */ modulesToApply [ i ] -> Apply ( controls :: CoastOut {}, controls :: VoltageOut { VoltsToApply }); } return ctre :: phoenix :: StatusCode :: OK ; } Python def __init__ ( self ): # ... self . __drive_request = CoastOut () self . __steer_request = VoltageOut ( 0 ) def apply ( self , parameters : swerve . SwerveControlParameters , modules_to_apply : list [ swerve . SwerveModule ] ) -> StatusCode : for module in modules_to_apply : # directly apply the control requests to the drive and steer motors module . apply ( self . __drive_request , self . __steer_request . with_output ( self . volts_to_apply ) ) return StatusCode . OK",
      "content_preview": "Swerve Requests Controlling the drivetrain is done using setControl(SwerveRequest) ( Java , C++ , Python ) which takes a given SwerveRequest ( Java , C++ , Python ). There are multiple pre-defined SwerveRequest implementations that cover the majority of use cases."
    },
    {
      "url": "https://v6.docs.ctr-electronics.com/en/stable/docs/api-reference/api-usage/enabling-actuators.html",
      "title": "Enabling Actuators",
      "section": "API Reference",
      "language": "All",
      "content": "Enabling Actuators CTR Electronics supported actuators have a safety feature where they will automatically disable output if they have not recently received an enable signal. FRC Applications In FRC applications, the enable signal is automatically sent to devices based on the Driver Station enable signal. This includes controlling devices in Phoenix Tuner X. Warning The device FRC Lock must be cleared to control devices in hardware-attached simulation. Non-FRC Applications In non-FRC applications, Unmanaged.feedEnable() must be called periodically to enable actuators. Warning The device FRC Lock must be cleared to control devices. Java // feed the enable signal, timeout after 100ms Unmanaged . feedEnable ( 100 ); C++ // feed the enable signal, timeout after 100ms unmanaged :: FeedEnable ( 100 ); Python # feed the enable signal, timeout after 100ms phoenix6 . unmanaged . feed_enable ( 0.100 ) This must also be called to control devices in Phoenix Tuner X. Tip The Tuner X CANivore USB server automatically calls Unmanaged.feedEnable() when control is enabled. FRC Lock When a device is connected to a roboRIO for use in FRC, the device becomes FRC-locked and will require the Driver Station enable signal for actuation. The device FRC lock can be reset by factory-defaulting the device in Phoenix Tuner X .",
      "content_preview": "Enabling Actuators CTR Electronics supported actuators have a safety feature where they will automatically disable output if they have not recently received an enable signal."
    },
    {
      "url": "https://v6.docs.ctr-electronics.com/en/stable/docs/troubleshooting/running-diagnostics.html",
      "title": "Running the Diagnostic Server",
      "section": "General",
      "language": "All",
      "content": "Running the Diagnostic Server Phoenix Tuner utilizes an on-device HTTP server called Phoenix Diagnostic Server to communicate with the device. The user can run the diagnostic server through one of two ways. 1: Deploying a Robot Program Phoenix Diagnostics will automatically run assuming you have instantiated a CTR Electronics device in your robot program. This can be as simple as having a motor declared somewhere in your program. Note The ID of the device does not need to be valid to run diagnostics. Java private TalonFX m_motor = new TalonFX ( 0 ); C++ hardware :: TalonFX m_talonFX { 0 }; When the program runs, it will print text to the console similar to the below Note WPILib users will see this text in the Driver Station or RioLog [phoenix] Starting Standalone Diagnostics Server (23.1.0-Jun 2 2023,23:17:09) [phoenix-diagnostics] Server 2023.1.0 (Jun 2 2023, 23:17:56) running on port: 1250 2: Running Temporary Diagnostic Server Alternatively, users can run a temporary diagnostic server in Tuner X. The temporary diagnostic server will only run until the next reboot of the target system.",
      "content_preview": "Running the Diagnostic Server Phoenix Tuner utilizes an on-device HTTP server called Phoenix Diagnostic Server to communicate with the device. The user can run the diagnostic server through one of two ways."
    },
    {
      "url": "https://v6.docs.ctr-electronics.com/en/stable/docs/tuner/tools/chrp-converter.html",
      "title": "CHRP Converter",
      "section": "Phoenix Tuner X",
      "language": "All",
      "content": "CHRP Converter Orchestra uses CHRP files to play music using compatible Talon FX motors. Tuner offers the ability to convert MIDI soundtracks to compatible CHRPs. Simply follow the on-screen instructions and press Import MIDI .",
      "content_preview": "CHRP Converter Orchestra uses CHRP files to play music using compatible Talon FX motors. Tuner offers the ability to convert MIDI soundtracks to compatible CHRPs. Simply follow the on-screen instructions and press Import MIDI ."
    },
    {
      "url": "https://v6.docs.ctr-electronics.com/en/stable/docs/canivore/canivore-intro.html",
      "title": "CANivore Intro",
      "section": "CANivore",
      "language": "All",
      "content": "CANivore Intro The CANivore is a multipurpose USB-to-CAN FD device. The CANivore: Adds a secondary CAN FD bus to the roboRIO CAN FD improves upon CAN with increased device bandwidth and transfer speed. Allows the control of CTR Electronics devices on Supported Devices . Important Details on licensing your CANivore is available on the licensing page. Initial Setup Setting up a CANivore for robot projects and desktop development. CANivore Setup API Usage Using the CANivore with devices in API. CANivore API Hardware-Attached Simulation Using a CANivore with hardware devices in a desktop environment. Hardware-Attached Simulation Advanced Configuration Advanced configuration options for the CANivore. Advanced Configuration",
      "content_preview": "CANivore Intro The CANivore is a multipurpose USB-to-CAN FD device. The CANivore: Adds a secondary CAN FD bus to the roboRIO CAN FD improves upon CAN with increased device bandwidth and transfer speed. Allows the control of CTR Electronics devices on Supported Devices ."
    },
    {
      "url": "https://v6.docs.ctr-electronics.com/en/stable/docs/api-reference/mechanisms/swerve/swerve-simulation.html",
      "title": "Swerve Simulation",
      "section": "API Reference",
      "language": "All",
      "content": "Swerve Simulation Important Swerve simulation is only supported for FRC users. The API supports a functionality focused simulation. This means that the simulation API assumes that the swerve drive is perfect (no scrub and no wheel slip). Additionally, it assumes a constant drive motor inertia regardless of the type of motion. To update the simulated swerve robot state, ensure drivetrain.updateSimState(...) ( Java , C++ , Python ) is called in simulationPeriodic() . The typical update rate of a robot project is 20 ms (0.020 seconds), and RobotController.getBatteryVoltage() ( Java , C++ , Python ) can be used to get the simulated battery voltage. The behavior of the simulated drivetrain can be improved to more closely match hardware by running the simulation logic at a faster update rate, such as by using a WPILib Notifier as demonstrated below. Important When using CommandSwerveDrivetrain from our examples or Tuner X, this is already handled by the subsystem. Java private static final double kSimLoopPeriod = 0.004 ; // 4 ms private Notifier m_simNotifier = null ; private double m_lastSimTime ; @Override public void simulationInit () { m_lastSimTime = Utils . getCurrentTimeSeconds (); /* Run simulation at a faster rate so PID gains behave more reasonably */ m_simNotifier = new Notifier (() -> { final double currentTime = Utils . getCurrentTimeSeconds (); double deltaTime = currentTime - m_lastSimTime ; m_lastSimTime = currentTime ; /* Use the measured time delta, get battery voltage from WPILib */ drivetrain . updateSimState ( deltaTime , RobotController . getBatteryVoltage ()); }); m_simNotifier . startPeriodic ( kSimLoopPeriod ); } C++ private : static constexpr units :: second_t kSimLoopPeriod = 4 _ms ; std :: unique_ptr < frc :: Notifier > m_simNotifier ; units :: second_t m_lastSimTime ; public : void SimulationInit () override { m_lastSimTime = utils :: GetCurrentTime (); /* Run simulation at a faster rate so PID gains behave more reasonably */ m_simNotifier = std :: make_unique < frc :: Notifier > ([ this ] { units :: second_t const currentTime = utils :: GetCurrentTime (); auto const deltaTime = currentTime - m_lastSimTime ; m_lastSimTime = currentTime ; /* Use the measured time delta, get battery voltage from WPILib */ drivetrain . UpdateSimState ( deltaTime , frc :: RobotController :: GetBatteryVoltage ()); }); m_simNotifier -> StartPeriodic ( kSimLoopPeriod ); } Python _SIM_LOOP_PERIOD : units . second = 0.004 # 4 ms def __init__ ( self ): self . _sim_notifier : Notifier | None = None self . _last_sim_time : units . second = 0.0 # ... def simulationInit ( self ): def _sim_periodic (): current_time = utils . get_current_time_seconds () delta_time = current_time - self . _last_sim_time self . _last_sim_time = current_time # Use the measured time delta, get battery voltage from WPILib self . drivetrain . update_sim_state ( delta_time , RobotController . getBatteryVoltage ()) # Run simulation at a faster rate so PID gains behave more reasonably self . _last_sim_time = utils . get_current_time_seconds () self . _sim_notifier = Notifier ( _sim_periodic ) self . _sim_notifier . startPeriodic ( self . _SIM_LOOP_PERIOD ) Simulation FAQ Q: My robot does not move in simulation A: Verify that all gains are non-zero and that the steer/drive inertia is non-zero. Q: My robot drifts a bit when driving while rotating A: Azimuth inertia and control latency is simulated. As a result, simulated swerve modules match the behavior of hardware in lagging behind the module targets, which can be improved by tuning the steer PID gains.",
      "content_preview": "Swerve Simulation Important Swerve simulation is only supported for FRC users. The API supports a functionality focused simulation. This means that the simulation API assumes that the swerve drive is perfect (no scrub and no wheel slip)."
    },
    {
      "url": "https://v6.docs.ctr-electronics.com/en/stable/docs/licensing/what-is-licensing.html",
      "title": "What is Licensing",
      "section": "General",
      "language": "All",
      "content": "What is Licensing All supported Phoenix 6 devices can freely use the Phoenix 6 API. Licensing a device can enable additional features that can enhance performance or user experience. A breakdown of the features offered by licensing your device is available at Feature Breakdown . Licenses will enable Phoenix Pro features on hardware when the device firmware and API versions match the license year. For example, a 2023 license enables Pro when used with 23.X firmware and 23.X Phoenix 6 API. A 2024 license would enable Pro features when used with 24.X firmware and 24.X API. Note Using Phoenix 6 simulation with Pro features does not require licensing. Types of Licenses Season Pass (FRC Teams Only) A single purchase that allows FRC Teams to license the team’s devices for Phoenix Pro. Season Pass generated licenses are equivalent to Single Device licenses but are tied to the team number assigned to the Season Pass after purchase. Season Pass Licensing Single Device A single device license can be activated and installed individually per device. Each purchase licenses exactly one compatible CAN bus device to use Phoenix Pro features. This may be preferred for systems with a small number of devices that need to utilize Pro features, or when used in a benchtop application. Device Licensing CANivore Bus This license is activated and installed onto the CANivore, and enables Phoenix Pro features for every CAN-connected device. This means that every compatible device that is attached to a licensed CANivore via CAN bus will be able to use Phoenix Pro features. This license type is advantageous if there are a large number of devices and eliminates the need to license additional devices in the event of a replacement. Device Licensing",
      "content_preview": "What is Licensing All supported Phoenix 6 devices can freely use the Phoenix 6 API. Licensing a device can enable additional features that can enhance performance or user experience. A breakdown of the features offered by licensing your device is available at Feature Breakdown ."
    },
    {
      "url": "https://v6.docs.ctr-electronics.com/en/stable/docs/troubleshooting/canbus-troubleshooting.html",
      "title": "CAN Bus Troubleshooting",
      "section": "General",
      "language": "All",
      "content": "CAN Bus Troubleshooting There are typically two failure modes that must be resolved: There are same-model devices on the bus with the same device ID (devices have a default device ID of ‘0’). CAN bus is not wired correctly or robustly During hardware validation, you will likely have to isolate each device to assign a unique device ID. Note CTRE software has the ability to resolve device ID conflicts without device isolation, and CAN bus is capable of reporting the health of the CAN bus (see Driver Station lightening tab). However, the problem is when both root-causes are occurring at the same time, this can confuse students who have no experience with CAN bus systems. Note Many teams will pre-assign and update devices (Talon SRXs for example) long before the robot takes form. This is also a great task for new students who need to start learning the control system (with the appropriate mentor oversight to ensure hardware does not get damaged). Identifying Duplicate IDs Tip Label the devices appropriately so there is no guessing which device ID is what. Don’t have a label maker? Use tape and/or Sharpie (sharpie marks can be removed with alcohol). Phoenix Tuner X will report when there are multiple devices of the same model with the same ID. This is shown when the device card is RED and there is a message in the middle of the device card. Users seeing this should iteratively configure IDs on the device(s). Check your wiring Specific wiring instructions can be found in the user manual of each product, but there are common steps that must be followed for all devices: If connectors are used for CAN bus, tug-test each individual crimped wire one at a time. Bad crimps/connection points are the most common cause of intermittent connection issues. Confirm red and black are not flipped. Confirm battery voltage is adequate (through Driver Station or through voltmeter). Manually inspect and confirm that green-connects-to-green and yellow-connects-to-yellow at every connection point. Flipping/mixing green and yellow is a common failure point during hardware bring up . Confirm breakers are installed in the PDP where appropriate. Measure resistance between CANH and CANL when system is not powered (should measure ~60Ω). If the measurement is 120Ω, then confirm both RIO and PDP are in circuit, and PDP jumper is in the correct location. LEDs are red - now what? We need to rule out same-ID versus bad-bus-wiring. There are two approaches: Approach 1 will help troubleshoot bad wiring and common IDs. Approach 2 will only be effective in troubleshooting common IDs, but this method is noteworthy because it is simple/quick (no wiring changes, just pull breakers). The specific instructions for changing device ID are in the next section. Review this if needed. Approach 1 (best) Physically connect CAN bus from roboRIO to one device only. Circumvent your wiring if need be. Power boot robot/bench setup. Open Phoenix Tuner X and wait for connection (roboRIO may take ~30 seconds to boot) Open the Devices page Confirm that CAN device appears Use Tuner X to change the device ID Label the new ID on the physical device Repeat this procedure for every device, one at a time If you find a particular device where communication is not possible, scrutinize device’s power and CAN connection to the system. Make the test setup so simple that the only failure mode possible is within the device itself. Note Typically, there must be two 120- \\(\\Omega\\) termination resistors at each end of the bus. CTR Electronics integrates termination resistors into the PDP and the CANivore. The roboRIO also has an integrated termination resistor. During bring-up, if you keep your harness short (such as the CAN pigtail leads from a single TalonFX) then a single resistor is adequate for testing purposes. Approach 2 (easier) Leave CAN bus wiring as is Pull breakers and PCM fuse from PDP Disconnect CAN bus pigtail from PDP Pick the first device to power up and restore breaker/fuse/pigtail so that only this CAN device is powered Power boot robot/bench setup Open Phoenix Tuner X and wait for connection (roboRIO may take ~30 seconds to boot) Open the Devices page Confirm that CAN device appears If device does not appear, scrutinize device’s power and CAN connection to the system Use Tuner X to change the device ID Label the new ID on the physical device Repeat this procedure for every device If you find a particular device or section of devices where communication is not possible, then the CAN bus wiring needs to be re-inspected. Remember to “flick” / “shake” / “jostle” the CAN wiring in various sections to attempt to reproduce red LED blips. This is a sure sign of loose contact points. If you are able to detect and change device ID on your devices individually, begin piecing your CAN bus together. Start with either roboRIO <—-> device <—> PDP, or CANivore <—-> device <—> 120 \\(\\Omega\\) resistor, to ensure termination exists at both ends. Then introduce the remaining devices until a failure is observed or until all devices are in-circuit. If introducing a new device creates a failure symptom, scrutinize that device by replacing it, inspecting common wires, and inspecting power. At the end of this section, all devices should appear (notwithstanding the above notes) and device LEDs should not be red. TalonFX and Pigeon2 typically blink orange when they are healthy and not controlled, and CANcoder rapid-blinks brightly. PDP may be orange or green depending on its sticky faults.",
      "content_preview": "CAN Bus Troubleshooting There are typically two failure modes that must be resolved: There are same-model devices on the bus with the same device ID (devices have a default device ID of ‘0’)."
    },
    {
      "url": "https://v6.docs.ctr-electronics.com/en/stable/docs/tuner/device-details-page.html",
      "title": "Device Details",
      "section": "Phoenix Tuner X",
      "language": "All",
      "content": "Device Details The Device Details page can be accessed by clicking on the device card (or clicking on View more details… when in grid view). This view allows you to access detailed device actions such as: Device Details (Name, ID, Firmware Version, Model, Serial No, etc.) Blinking LEDs Field Upgrading Licensing Details (by clicking on the LIC/PRO icon) Configs Control Self Tests Plotting Pigeon 2 Mount Calibration Blinking All CTR Electronics devices can be blinked (rapidly flash the LEDs). This can be useful for handling whenever you have duplicate devices using the same ID on the CAN bus. Verifying Device Details This screen highlights information such as (1) Device Name, (2) Device Model, (3) Firmware Version. Tip Clicking in the blank space outside the detail frames will bring the user back to the devices page. Configuring Name & IDs All devices can have their Name and ID configured via their respective textbox. IDs are limited to the range of 0 to 62 (inclusive). After inputting the ID or name, press the Set button to save the changes to the device. Field-Upgrade Firmware Version Tuner X has improved firmware upgrading functionality by automatically downloading and caching firmware. Upon initial Tuner X launch, the latest firmware for all devices will automatically be downloaded in the background (takes <10s on most internet connections). The individual device page allows you to select specific firmware versions for your device via the firmware dropdown. Batch firmware can also be completed via the batch field upgrade pop-up . Important Users should ensure they select Phoenix 6 firmware when using Phoenix 6 API, and Phoenix 5 firmware when using Phoenix 5 API. A single robot project may use both APIs simultaneously. Users can switch between firmware release years by selecting from the dropdown above the firmware selection. Note The toggle between firmware years only affects the firmware versions downloaded by Tuner X. Files selected using the “Browse” button are not affected.",
      "content_preview": "Device Details The Device Details page can be accessed by clicking on the device card (or clicking on View more details… when in grid view). This view allows you to access detailed device actions such as: Device Details (Name, ID, Firmware Version, Model, Serial No, etc.) Blinking LEDs Field..."
    },
    {
      "url": "https://v6.docs.ctr-electronics.com/en/stable/docs/api-reference/mechanisms/swerve/swerve-overview.html",
      "title": "Swerve Overview",
      "section": "API Reference",
      "language": "All",
      "content": "Swerve Overview Important Some swerve features, such as simulation support, are only available for FRC users. Phoenix 6 incorporates a high performance swerve API supported in Java, C++, and Python. This API simplifies the boilerplate necessary for swerve and maximizes performance. Tip Tuner X supports a swerve project creator that greatly simplifies the setup process and eliminates common error cases. Small API surface, easily debuggable Build robot characteristics using SwerveModuleConstants ( Java , C++ , Python ) and SwerveDrivetrainConstants ( Java , C++ , Python ). Integrates cleanly into the WPILib command-based framework using CommandSwerveDrivetrain (from our examples or Tuner X). Provide a lambda to telemetrize directly in the odometry loop using registerTelemetry(...) ( Java , C++ , Python ). Extensible and powerful control of the drivetrain via SwerveRequest ( Java , C++ , Python ). Built-in requests tuned for both autonomous and teleoperated robot-centric, field-centric and field-centric facing angle control. Supports common scenarios such as X brake (point all modules toward the center of the robot). Simulation Test your autonomous paths and pose estimation without a physical robot. Simply call updateSimState(...) ( Java , C++ , Python ) in simulationPeriodic() or on a separate thread. Performance Odometry is updated synchronously with the motor controllers. Odometry is received as fast as possible using a separate thread. Control is run inline with odometry updates. Combine with Phoenix Pro and a CANivore with timesync for improved performance. Tip Simulation boilerplate is automatically handled when generating a robot project using Tuner X. Hardware Requirements Utilizing the swerve API requires that the robot drivetrain is composed of supported Phoenix 6 devices. At a minimum, these requirements are: 4 Talon FX or Talon FXS drive motor controllers 4 Talon FX or Talon FXS steer motor controllers 1 Pigeon 2.0 4 encoders (must all be one of the following) 4 CANcoders 4 PWM absolute encoders connected to at least 2 CANdi 4 PWM absolute encoders connected to their corresponding steer Talon FXS Note All drive motor controllers must be of the same type, and all steer motor controllers must be of the same type. However, the drive and steer motor controllers can be different types from each other. For example, you can utilize 4 Talon FXS connected to a Minion for steer and 4 Kraken X60 for drive. Overview on the API Simple usage is comprised of 5 core APIs: SwerveDrivetrainConstants ( Java , C++ , Python ) This class handles characteristics of the robot that are not module specific. e.g. CAN bus, Pigeon 2 ID, whether FD is enabled or not. SwerveModuleConstantsFactory ( Java , C++ , Python ) Factory class with common constants used to instantiate SwerveModuleConstants for each module on the robot. SwerveModuleConstants ( Java , C++ , Python ) Represents the characteristics for a given module. SwerveDrivetrain ( Java , C++ , Python ) Created using SwerveDrivetrainConstants and a SwerveModuleConstants for each module, this is used to control the swerve drivetrain. SwerveRequest ( Java , C++ , Python ) Controls the drivetrain, such as driving field-centric. Usage of these classes is available in the following articles in this section. Swerve Builder API Swerve Requests Swerve Simulation",
      "content_preview": "Swerve Overview Important Some swerve features, such as simulation support, are only available for FRC users. Phoenix 6 incorporates a high performance swerve API supported in Java, C++, and Python. This API simplifies the boilerplate necessary for swerve and maximizes performance."
    },
    {
      "url": "https://v6.docs.ctr-electronics.com/en/stable/docs/api-reference/device-specific/talonfx/basic-pid-control.html",
      "title": "Basic PID and Profiling",
      "section": "TalonFX",
      "language": "All",
      "content": "Basic PID and Profiling The Talon FX supports basic PID control and motion profiling for position and velocity. Note For more information on feedback and feedforward gains, see Closed-Loop Overview . Position Control A Position closed loop can be used to target a specified motor position (in rotations). Position closed loop is currently supported for all base control output types . The units of the output are determined by the control output type. In a Position closed loop, the gains should be configured as follows: \\(K_g\\) - output to overcome gravity (output) \\(K_s\\) - Velocity Sign: unused; Closed-Loop Sign: output to overcome static friction (output) \\(K_v\\) - unused, as there is no target velocity \\(K_a\\) - unused, as there is no target acceleration \\(K_p\\) - output per unit of error in position (output/rotation) \\(K_i\\) - output per unit of integrated error in position (output/(rotation*s)) \\(K_d\\) - output per unit of error derivative in position (output/rps) Java // in init function, set slot 0 gains var slot0Configs = new Slot0Configs (); slot0Configs . kP = 2.4 ; // An error of 1 rotation results in 2.4 V output slot0Configs . kI = 0 ; // no output for integrated error slot0Configs . kD = 0.1 ; // A velocity of 1 rps results in 0.1 V output m_talonFX . getConfigurator (). apply ( slot0Configs ); C++ // in init function, set slot 0 gains configs :: Slot0Configs slot0Configs {}; slot0Configs . kP = 2.4 ; // An error of 1 rotation results in 2.4 V output slot0Configs . kI = 0 ; // no output for integrated error slot0Configs . kD = 0.1 ; // A velocity of 1 rps results in 0.1 V output m_talonFX . GetConfigurator (). Apply ( slot0Configs ); Python # in init function, set slot 0 gains slot0_configs = configs . Slot0Configs () slot0_configs . k_p = 2.4 # An error of 1 rotation results in 2.4 V output slot0_configs . k_i = 0 # no output for integrated error slot0_configs . k_d = 0.1 # A velocity of 1 rps results in 0.1 V output self . talonfx . configurator . apply ( slot0_configs ) Once the gains are configured, the Position closed loop control request can be sent to the TalonFX. The control request object has an optional feedforward term that can be used to add an arbitrary value to the output, which can be useful to account for the effects of gravity or friction. Java // create a position closed-loop request, voltage output, slot 0 configs final PositionVoltage m_request = new PositionVoltage ( 0 ). withSlot ( 0 ); // set position to 10 rotations m_talonFX . setControl ( m_request . withPosition ( 10 )); C++ // create a position closed-loop request, voltage output, slot 0 configs controls :: PositionVoltage m_request = controls :: PositionVoltage { 0 _tr }. WithSlot ( 0 ); // set position to 10 rotations m_talonFX . SetControl ( m_request . WithPosition ( 10 _tr )); Python # create a position closed-loop request, voltage output, slot 0 configs self . request = controls . PositionVoltage ( 0 ) . with_slot ( 0 ) # set position to 10 rotations self . talonfx . set_control ( self . request . with_position ( 10 )) Velocity Control A Velocity closed loop can be used to maintain a target velocity (in rotations per second). This can be useful for controlling flywheels, where a velocity needs to be maintained for accurate shooting. Velocity closed loop is currently supported for all base control output types . The units of the output are determined by the control output type. In a Velocity closed loop, the gains should be configured as follows: \\(K_g\\) - output to overcome gravity (output) \\(K_s\\) - output to overcome static friction (output) \\(K_v\\) - output per unit of requested velocity (output/rps) \\(K_a\\) - unused, as there is no target acceleration \\(K_p\\) - output per unit of error in velocity (output/rps) \\(K_i\\) - output per unit of integrated error in velocity (output/rotation) \\(K_d\\) - output per unit of error derivative in velocity (output/(rps/s)) Java // in init function, set slot 0 gains var slot0Configs = new Slot0Configs (); slot0Configs . kS = 0.1 ; // Add 0.1 V output to overcome static friction slot0Configs . kV = 0.12 ; // A velocity target of 1 rps results in 0.12 V output slot0Configs . kP = 0.11 ; // An error of 1 rps results in 0.11 V output slot0Configs . kI = 0 ; // no output for integrated error slot0Configs . kD = 0 ; // no output for error derivative m_talonFX . getConfigurator (). apply ( slot0Configs ); C++ // in init function, set slot 0 gains configs :: Slot0Configs slot0Configs {}; slot0Configs . kS = 0.1 ; // Add 0.1 V output to overcome static friction slot0Configs . kV = 0.12 ; // A velocity target of 1 rps results in 0.12 V output slot0Configs . kP = 0.11 ; // An error of 1 rps results in 0.11 V output slot0Configs . kI = 0 ; // no output for integrated error slot0Configs . kD = 0 ; // no output for error derivative m_talonFX . GetConfigurator (). Apply ( slot0Configs ); Python slot0_configs = configs . Slot0Configs () slot0_configs . k_s = 0.1 # Add 0.1 V output to overcome static friction slot0_configs . k_v = 0.12 # A velocity target of 1 rps results in 0.12 V output slot0_configs . k_p = 0.11 # An error of 1 rps results in 0.11 V output slot0_configs . k_i = 0 # no output for integrated error slot0_configs . k_d = 0 # no output for error derivative self . talonfx . configurator . apply ( slot0_configs ) Once the gains are configured, the Velocity closed loop control request can be sent to the TalonFX. The control request object has an optional feedforward term that can be used to add an arbitrary value to the output, which can be useful to account for the effects of gravity. Java // create a velocity closed-loop request, voltage output, slot 0 configs final VelocityVoltage m_request = new VelocityVoltage ( 0 ). withSlot ( 0 ); // set velocity to 8 rps, add 0.5 V to overcome gravity m_talonFX . setControl ( m_request . withVelocity ( 8 ). withFeedForward ( 0.5 )); C++ // create a velocity closed-loop request, voltage output, slot 0 configs controls :: VelocityVoltage m_request = controls :: VelocityVoltage { 0 _tps }. WithSlot ( 0 ); // set velocity to 8 rps, add 0.5 V to overcome gravity m_talonFX . SetControl ( m_request . WithVelocity ( 8 _tps ). WithFeedForward ( 0.5 _V )); Python # create a velocity closed-loop request, voltage output, slot 0 configs self . request = controls . VelocityVoltage ( 0 ) . with_slot ( 0 ) # set velocity to 8 rps, add 0.5 V to overcome gravity self . talonfx . set_control ( self . request . with_velocity ( 8 ) . with_feed_forward ( 0.5 )) Motion Profiling The Position and Velocity closed-loop requests can be used to run a motion profile generated by the robot controller. Tip The Talon FX supports several onboard motion profiles using Motion Magic® . Position In a Position motion profile, the gains should be configured as follows: \\(K_g\\) - output to overcome gravity (output) \\(K_s\\) - output to overcome static friction (output) \\(K_v\\) - output per unit of requested velocity (output/rps) \\(K_a\\) - unused, as there is no target acceleration \\(K_p\\) - output per unit of error in position (output/rotation) \\(K_i\\) - output per unit of integrated error in position (output/(rotation*s)) \\(K_d\\) - output per unit of error derivative in position (output/rps) Java // in init function, set slot 0 gains var slot0Configs = new Slot0Configs (); slot0Configs . kS = 0.25 ; // Add 0.25 V output to overcome static friction slot0Configs . kV = 0.12 ; // A velocity target of 1 rps results in 0.12 V output slot0Configs . kP = 4.8 ; // A position error of 2.5 rotations results in 12 V output slot0Configs . kI = 0 ; // no output for integrated error slot0Configs . kD = 0.1 ; // A velocity error of 1 rps results in 0.1 V output m_talonFX . getConfigurator (). apply ( slot0Configs ); C++ // in init function, set slot 0 gains configs :: Slot0Configs slot0Configs {}; slot0Configs . kS = 0.25 ; // Add 0.25 V output to overcome static friction slot0Configs . kV = 0.12 ; // A velocity target of 1 rps results in 0.12 V output slot0Configs . kP = 4.8 ; // A position error of 2.5 rotations results in 12 V output slot0Configs . kI = 0 ; // no output for integrated error slot0Configs . kD = 0.1 ; // A velocity error of 1 rps results in 0.1 V output m_talonFX . GetConfigurator (). Apply ( slot0Configs ); Python # in init function, set slot 0 gains slot0_configs = configs . Slot0Configs () slot0_configs . k_s = 0.25 # Add 0.25 V output to overcome static friction slot0_configs . k_v = 0.12 # A velocity target of 1 rps results in 0.12 V output slot0_configs . k_p = 4.8 # A position error of 2.5 rotations results in 12 V output slot0_configs . k_i = 0 # no output for integrated error slot0_configs . k_d = 0.1 # A velocity error of 1 rps results in 0.1 V output self . talonfx . configurator . apply ( slot0_configs ) Once the gains are configured, the Position closed-loop control request can be sent to the TalonFX. The Velocity parameter is used to specify the current setpoint velocity of the motion profile. The control request object has an optional feedforward term that can be used to add an arbitrary value to the output, which can be useful to account for the effects of gravity or friction. Java // Trapezoid profile with max velocity 80 rps, max accel 160 rps/s final TrapezoidProfile m_profile = new TrapezoidProfile ( new TrapezoidProfile . Constraints ( 80 , 160 ) ); // Final target of 200 rot, 0 rps TrapezoidProfile . State m_goal = new TrapezoidProfile . State ( 200 , 0 ); TrapezoidProfile . State m_setpoint = new TrapezoidProfile . State (); // create a position closed-loop request, voltage output, slot 0 configs final PositionVoltage m_request = new PositionVoltage ( 0 ). withSlot ( 0 ); // calculate the next profile setpoint m_setpoint = m_profile . calculate ( 0.020 , m_setpoint , m_goal ); // send the request to the device m_request . Position = m_setpoint . position ; m_request . Velocity = m_setpoint . velocity ; m_talonFX . setControl ( m_request ); C++ // Trapezoid profile with max velocity 80 rps, max accel 160 rps/s frc :: TrapezoidProfile < units :: turn_t > m_profile {{ 80 _tps , 160 _tr_per_s_sq }}; // Final target of 200 rot, 0 rps frc :: TrapezoidProfile < units :: turn_t >:: State m_goal { 200 _tr , 0 _tps }; frc :: TrapezoidProfile < units :: turn_t >:: State m_setpoint {}; // create a position closed-loop request, voltage output, slot 0 configs controls :: PositionVoltage m_request = controls :: PositionVoltage { 0 _tr }. WithSlot ( 0 ); // calculate the next profile setpoint m_setpoint = m_profile . Calculate ( 20 _ms , m_setpoint , m_goal ); // send the request to the device m_request . Position = m_setpoint . position ; m_request . Velocity = m_setpoint . velocity ; m_talonFX . SetControl ( m_request ); Python # Trapezoid profile with max velocity 80 rps, max accel 160 rps/s self . profile = TrapezoidProfile ( TrapezoidProfile . Constraints ( 80 , 160 ) ) # Final target of 200 rot, 0 rps self . goal = TrapezoidProfile . State ( 200 , 0 ) self . setpoint = TrapezoidProfile . State () # create a position closed-loop request, voltage output, slot 0 configs self . request = controls . PositionVoltage ( 0 ) . with_slot ( 0 ) # calculate the next profile setpoint self . setpoint = self . profile . calculate ( 0.020 , self . setpoint , self . goal ) # send the request to the device self . request . position = self . setpoint . position self . request . velocity = self . setpoint . velocity self . talonfx . set_control ( self . request ) Velocity In a Velocity motion profile, the gains should be configured as follows: \\(K_g\\) - output to overcome gravity (output) \\(K_s\\) - output to overcome static friction (output) \\(K_v\\) - output per unit of requested velocity (output/rps) \\(K_a\\) - output per unit of requested acceleration (output/(rps/s)) \\(K_p\\) - output per unit of error in velocity (output/rps) \\(K_i\\) - output per unit of integrated error in velocity (output/rotation) \\(K_d\\) - output per unit of error derivative in velocity (output/(rps/s)) Java // in init function, set slot 0 gains var slot0Configs = new Slot0Configs (); slot0Configs . kS = 0.25 ; // Add 0.25 V output to overcome static friction slot0Configs . kV = 0.12 ; // A velocity target of 1 rps results in 0.12 V output slot0Configs . kA = 0.01 ; // An acceleration of 1 rps/s requires 0.01 V output slot0Configs . kP = 0.11 ; // An error of 1 rps results in 0.11 V output slot0Configs . kI = 0 ; // no output for integrated error slot0Configs . kD = 0 ; // no output for error derivative m_talonFX . getConfigurator (). apply ( slot0Configs ); C++ // in init function, set slot 0 gains configs :: Slot0Configs slot0Configs {}; slot0Configs . kS = 0.25 ; // Add 0.25 V output to overcome static friction slot0Configs . kV = 0.12 ; // A velocity target of 1 rps results in 0.12 V output slot0Configs . kA = 0.01 ; // An acceleration of 1 rps/s requires 0.01 V output slot0Configs . kP = 0.11 ; // An error of 1 rps results in 0.11 V output slot0Configs . kI = 0 ; // no output for integrated error slot0Configs . kD = 0 ; // no output for error derivative m_talonFX . GetConfigurator (). Apply ( slot0Configs ); Python # in init function, set slot 0 gains slot0_configs = configs . Slot0Configs () slot0_configs . k_s = 0.25 # Add 0.25 V output to overcome static friction slot0_configs . k_v = 0.12 # A velocity target of 1 rps results in 0.12 V output slot0_configs . k_a = 0.01 # An acceleration of 1 rps/s requires 0.01 V output slot0_configs . k_p = 0.11 # An error of 1 rps results in 0.11 V output slot0_configs . k_i = 0 # no output for integrated error slot0_configs . k_d = 0 # no output for error derivative self . talonfx . configurator . apply ( slot0_configs ) Once the gains are configured, the Velocity closed-loop control request can be sent to the TalonFX. The Acceleration parameter is used to specify the current setpoint acceleration of the motion profile. The control request object has an optional feedforward term that can be used to add an arbitrary value to the output, which can be useful to account for the effects of gravity or friction. Java // Trapezoid profile with max acceleration 400 rot/s^2, max jerk 4000 rot/s^3 final TrapezoidProfile m_profile = new TrapezoidProfile ( new TrapezoidProfile . Constraints ( 400 , 4000 ) ); // Final target of 80 rps, 0 rps/s TrapezoidProfile . State m_goal = new TrapezoidProfile . State ( 80 , 0 ); TrapezoidProfile . State m_setpoint = new TrapezoidProfile . State (); // create a velocity closed-loop request, voltage output, slot 0 configs final VelocityVoltage m_request = new VelocityVoltage ( 0 ). withSlot ( 0 ); // calculate the next profile setpoint m_setpoint = m_profile . calculate ( 0.020 , m_setpoint , m_goal ); // send the request to the device // note: \"position\" is velocity, and \"velocity\" is acceleration m_request . Velocity = m_setpoint . position ; m_request . Acceleration = m_setpoint . velocity ; m_talonFX . setControl ( m_request ); C++ // Trapezoid profile with max acceleration 400 rot/s^2, max jerk 4000 rot/s^3 frc :: TrapezoidProfile < units :: turns_per_second_t > m_profile {{ 400 _tr_per_s_sq , 4000 _tr_per_s_cu }}; // Final target of 80 rps, 0 rot/s^2 frc :: TrapezoidProfile < units :: turns_per_second_t >:: State m_goal { 80 _tps , 0 _tr_per_s_sq }; frc :: TrapezoidProfile < units :: turns_per_second_t >:: State m_setpoint {}; // create a velocity closed-loop request, voltage output, slot 0 configs controls :: VelocityVoltage m_request = controls :: VelocityVoltage { 0 _tps }. WithSlot ( 0 ); // calculate the next profile setpoint m_setpoint = m_profile . Calculate ( 20 _ms , m_setpoint , m_goal ); // send the request to the device // note: \"position\" is velocity, and \"velocity\" is acceleration m_positionControl . Velocity = m_setpoint . position ; m_positionControl . Acceleration = m_setpoint . velocity ; m_talonFX . SetControl ( m_request ); Python # Trapezoid profile with max acceleration 400 rot/s^2, max jerk 4000 rot/s^3 self . profile = TrapezoidProfile ( TrapezoidProfile . Constraints ( 400 , 4000 ) ) # Final target of 80 rps, 0 rot/s^2 self . goal = TrapezoidProfile . State ( 80 , 0 ) self . setpoint = TrapezoidProfile . State () # create a velocity closed-loop request, voltage output, slot 0 configs self . request = controls . VelocityVoltage ( 0 ) . with_slot ( 0 ) # calculate the next profile setpoint self . setpoint = self . profile . calculate ( 0.020 , self . setpoint , self . goal ) # send the request to the device # note: \"position\" is velocity, and \"velocity\" is acceleration self . request . velocity = self . setpoint . position self . request . acceleration = self . setpoint . velocity self . talonfx . set_control ( self . request )",
      "content_preview": "Basic PID and Profiling The Talon FX supports basic PID control and motion profiling for position and velocity. Note For more information on feedback and feedforward gains, see Closed-Loop Overview ."
    },
    {
      "url": "https://v6.docs.ctr-electronics.com/en/stable/docs/api-reference/wpilib-integration/sysid-integration/index.html",
      "title": "SysId Integration",
      "section": "API Reference",
      "language": "All",
      "content": "SysId Integration System Identification, or commonly referred to as SysId, is the process of identifying the characteristics of a given system . This identification usually consists of: Mechanism testing In FRC, two tests are performed: Quasistatic and Dynamic. Data collection Position , Velocity , and MotorOutput samples are collected while the tests are running. Data analysis Collected data is analyzed to calculate constants such as PID gains, slip current (maximum stator current), maximum robot velocity, etc. Note This documentation assumes that the user is utilizing a command-based robot program . Advantages of SignalLogger over DataLog When collecting data for analysis, it’s important to take into account several factors, such as: Impact of CAN latency Signals sent faster than the 20ms main robot loop Language data collection issues (such as Java garbage collection causing pauses in the log) When users utilize the Phoenix 6 signal logging API , these issues are eliminated. This section guides the user through characterizing a motor, converting hoot logs to a WPILib WPILOG for data analysis, and integrating gains for control. This section can also be used as a characterizing other mechanisms such as a swerve azimuth and drive motors. Characterization begins with a functioning robot program. Users should have basic code for the mechanism already put together, and all configs in the FeedbackConfigs group should be applied. Any changes to the gear ratios and sensor source in FeedbackConfigs may require the user to recharacterize their mechanism. Get started: Plumbing & Running SysId",
      "content_preview": "SysId Integration System Identification, or commonly referred to as SysId, is the process of identifying the characteristics of a given system . This identification usually consists of: Mechanism testing In FRC, two tests are performed: Quasistatic and Dynamic."
    },
    {
      "url": "https://v6.docs.ctr-electronics.com/en/stable/docs/installation/installation-frc.html",
      "title": "Installing Phoenix 6 (FRC)",
      "section": "General",
      "language": "All",
      "content": "Installing Phoenix 6 (FRC) Java/C++ Offline Download the Phoenix Framework Installer Navigate through the installer, ensuring applicable options are selected Apply the vendordep via WPILib VS Code Adding Offline Libraries Online Users can install Phoenix without an installer using WPILib’s Install New Libraries functionality in VS Code. This requires the user to have an installation of WPILib on their machine. To begin, open WPILib VS Code and click on the WPILib icon in the top right. Then type Manage Vendor Libraries and click on the menu option that appears. Click Install new libraries (online) and a textbox should appear. Follow the remaining instructions below on pasting the correct link into the textbox. Paste the following URL in WPILib VS Code Install new libraries (online) : https://maven.ctr-electronics.com/release/com/ctre/phoenix6/latest/Phoenix6-frc2025-latest.json Additionally, v5 can safely installed alongside it by installing the v5 vendordep. https://maven.ctr-electronics.com/release/com/ctre/phoenix/Phoenix5-frc2025-latest.json Alternatively, the Hoot Replay version of the vendordep can be installed, as well as the v5 Replay-compatible vendordep: https://maven.ctr-electronics.com/release/com/ctre/phoenix6/latest/Phoenix6-replay-frc2025-latest.json https://maven.ctr-electronics.com/release/com/ctre/phoenix/Phoenix5-replay-frc2025-latest.json Important Users utilizing only v5 devices still need the v6 vendordep added to their robot project. Python First, make sure to install RobotPy . From there, installation of Phoenix 6 is available through PyPI . py -3 -m pip install phoenix6 LabVIEW Download the Phoenix Offline Installer from the Latest GitHub Release , and install it on the computer (with the LabVIEW component checked). This will put the Phoenix LabVIEW VIs into the “WPI Robotics Library -> Third Party -> CTRE” pallette for LabVIEW development. To deploy robot projects with Phoenix, you need to first download the Phoenix Libraries to the roboRIO. This can be done one of two ways: Phoenix Tuner X under “Settings -> FRC Advanced -> Install LabVIEW” LabVIEW under “Tools -> FIRST Robotics Tools -> Download CTRE Phoenix Libs”. After the libraries are downloaded, hard deploy (run as startup) a LabVIEW program and restart the roboRIO. Note Currently only Phoenix 5 is supported in LabVIEW. A Phoenix 6 LabVIEW alpha is in development, teams that are interested in this may contact us directly at support @ ctr-electronics . com .",
      "content_preview": "Installing Phoenix 6 (FRC) Java/C++ Offline Download the Phoenix Framework Installer Navigate through the installer, ensuring applicable options are selected Apply the vendordep via WPILib VS Code Adding Offline Libraries Online Users can install Phoenix without an installer using WPILib’s Install..."
    },
    {
      "url": "https://v6.docs.ctr-electronics.com/en/stable/docs/api-reference/api-usage/orchestra.html",
      "title": "Orchestra",
      "section": "API Reference",
      "language": "All",
      "content": "Orchestra Compatible motors powered by Talon FX have the ability to produce audible output through the MusicTone ( Java , C++ , Python ) control request. The Orchestra API extends this ability and orchestrates multiple motors to play music. To get started, construct an Orchestra ( Java , C++ , Python ) object with an instrument and CHRP. Ensure that addInstrument() and loadMusic() are not called periodically, as they are blocking functions. Note For information on converting MIDI to CHRP, see CHRP Converter . Java Orchestra m_orchestra = new Orchestra (); // Add a single device to the orchestra m_orchestra . addInstrument ( m_motor ); // Attempt to load the chrp var status = m_orchestra . loadMusic ( \"track.chrp\" ); if ( ! status . isOK ()) { // log error } C++ Orchestra m_orchestra ; // Add a single device to the orchestra m_orchestra . addInstrument ( m_motor ); // Attempt to load the chrp auto status = m_orchestra . loadMusic ( \"track.chrp\" ); if ( ! status . IsOK ()) { // log error } Python self . orchestra = Orchestra () self . orchestra . add_instrument ( self . motor ); status = self . orchestra . load_music ( \"track.chrp\" ) if not status . is_ok (): # log error Once the track has been loaded, play/pause/stop can be used to manage the track. play() only needs to be called once. Java m_orchestra . play (); C++ m_orchestra . Play (); Python self . orchestra . play () Playback While Disabled (FRC) Playback can be safely enabled during robot disable by enabling the Allow Music Dur Disable ( Java , C++ , Python ) config.",
      "content_preview": "Orchestra Compatible motors powered by Talon FX have the ability to produce audible output through the MusicTone ( Java , C++ , Python ) control request. The Orchestra API extends this ability and orchestrates multiple motors to play music."
    },
    {
      "url": "https://v6.docs.ctr-electronics.com/en/stable/docs/api-reference/wpilib-integration/motorcontroller-integration.html",
      "title": "MotorController Integration",
      "section": "API Reference",
      "language": "All",
      "content": "MotorController Integration Phoenix 6 motor controller classes such as TalonFX ( Java , C++ , Python ) implement many APIs from the MotorController ( Java , C++ ) interface. This allows Phoenix 6 motor controllers to more easily be used in WPILib drivetrain classes such as DifferentialDrive . Java // instantiate motor controllers final TalonFX m_motorLeft = new TalonFX ( 0 ); final TalonFX m_motorRight = new TalonFX ( 1 ); // create DifferentialDrive object for robot control final DifferentialDrive m_diffDrive = new DifferentialDrive ( m_motorLeft :: set , m_motorRight :: set ); // instantiate joystick final XboxController m_driverJoy = new XboxController ( 0 ); public void teleopPeriodic () { var forward = - m_driverJoy . getLeftY (); var rot = - m_driverJoy . getRightX (); m_diffDrive . arcadeDrive ( forward , rot ); } C++ (Source) void Robot::TeleopPeriodic () { auto forward = - m_driverJoy . GetLeftY (); auto rot = - m_driverJoy . GetRightX (); m_diffDrive . ArcadeDrive ( forward , rot ); } C++ (Header) // instantiate motor controllers hardware :: TalonFX m_motorLeft { 0 }; hardware :: TalonFX m_motorRight { 1 }; // create differentialdrive object for robot control frc :: DifferentialDrive m_diffDrive { [ this ]( double output ) { m_motorLeft . Set ( output ); }, [ this ]( double output ) { m_motorRight . Set ( output ); } }; // instantiate joystick frc :: XboxController m_driverJoy { 0 }; Python def __init__ ( self ): # instantiate motor controllers self . motor_left = hardware . TalonFX ( 0 ) self . motor_right = hardware . TalonFX ( 1 ) # create DifferentialDrive object for robot control self . diff_drive = wpilib . drive . DifferentialDrive ( self . motor_left . set , self . motor_right . set ) # instantiate joystick self . driver_joy = wpilib . XboxController ( 0 ) def teleopPeriodic ( self ): forward = - self . driver_joy . getLeftY () rot = - self . driver_joy . getRightX () self . diff_drive . arcadeDrive ( forward , rot ) Motor Safety CTR Electronics supported actuators implement WPILib Motor Safety . In additional to the normal enable signal of CTR Electronics actuators, Motor Safety will automatically disable the device according to the WPILib Motor Safety implementation. Simulation It’s recommended that users set supply voltage to RobotController.getBatteryVoltage() ( Java , C++ ) to take advantage of WPILib’s BatterySim ( Java , C++ ) API. Additionally, the simulated device state is shown in the simulation Other Devices menu.",
      "content_preview": "MotorController Integration Phoenix 6 motor controller classes such as TalonFX ( Java , C++ , Python ) implement many APIs from the MotorController ( Java , C++ ) interface. This allows Phoenix 6 motor controllers to more easily be used in WPILib drivetrain classes such as DifferentialDrive ."
    },
    {
      "url": "https://v6.docs.ctr-electronics.com/en/stable/docs/tuner/self-test.html",
      "title": "Self Test Snapshot",
      "section": "Phoenix Tuner X",
      "language": "All",
      "content": "Self Test Snapshot Self Test Snapshot is a diagnostic feature of all supported devices that will show the immediate state of the device. This is extremely useful for troubleshooting and ensuring the device is working properly. Phoenix 6 with Phoenix Tuner X improves upon Self Test by showing the information in clean tables, animations and detailed units. Self Test also includes four buttons: Refresh , Clear Faults , Copy Self Test , and Share to Support . Refresh will refresh the Self Test information, Clear faults` will blink the device and clear any faults on the device. Copy Self Test will copy the Self Test information to your clipboard. Share to Support will open the default email client with an email to CTR Electronics support. Viewing Status LEDs Phoenix 6 devices report status LEDs as an animated GIF in Phoenix Tuner X. This can be useful for diagnosing a device when it’s buried in a robot.",
      "content_preview": "Self Test Snapshot Self Test Snapshot is a diagnostic feature of all supported devices that will show the immediate state of the device. This is extremely useful for troubleshooting and ensuring the device is working properly."
    },
    {
      "url": "https://v6.docs.ctr-electronics.com/en/stable/docs/api-reference/wpilib-integration/sysid-integration/plumbing-and-running-sysid.html",
      "title": "Plumbing & Running SysId",
      "section": "API Reference",
      "language": "All",
      "content": "Plumbing & Running SysId For the purpose of this documentation, we focus on the integration of Phoenix 6 and WPILib’s SysId API to characterize common mechanisms. Detailed documentation on the SysId routines can be found here . To get started, users must construct a SysIdRoutine that defines a Config and Mechanism . The Config constructor allows the users to define the voltage ramp rate, dynamic step voltage, characterization timeout, and a lambda that accepts the SysIdRoutineLog.State for logging. The lambda needs to be overridden to log the State string using the Phoenix 6 Signal Logger . The Mechanism constructor takes a lambda accepts a Measure<Voltage> . This lambda is used to apply the voltage request to the motors during characterization, which can be done using a VoltageOut request. The second argument to the constructor is a logging callback; this is left null when using the Signal Logger, as all signals are logged automatically. The last parameter is a reference to this Subsystem . Putting this all together results in the example shown below. Java private final TalonFX m_motor = new TalonFX ( 0 ); private final VoltageOut m_voltReq = new VoltageOut ( 0.0 ); private final SysIdRoutine m_sysIdRoutine = new SysIdRoutine ( new SysIdRoutine . Config ( null , // Use default ramp rate (1 V/s) Volts . of ( 4 ), // Reduce dynamic step voltage to 4 to prevent brownout null , // Use default timeout (10 s) // Log state with Phoenix SignalLogger class ( state ) -> SignalLogger . writeString ( \"state\" , state . toString ()) ), new SysIdRoutine . Mechanism ( ( volts ) -> m_motor . setControl ( m_voltReq . withOutput ( volts . in ( Volts ))), null , this ) ); C++ hardware :: TalonFX m_motor { 0 }; controls :: VoltageOut m_voltReq { 0 _V }; frc2 :: sysid :: SysIdRoutine m_sysIdRoutine { frc2 :: sysid :: Config { std :: nullopt , // Use default ramp rate (1 V/s) 4 _V , // Reduce dynamic step voltage to 4 to prevent brownout std :: nullopt , // Use default timeout (10 s) // Log state with Phoenix SignalLogger class []( frc :: sysid :: State state ) { SignalLogger :: WriteString ( \"state\" , frc :: sysid :: SysIdRoutineLog :: StateEnumToString ( state )); } }, frc2 :: sysid :: Mechanism { [ this ]( units :: volt_t volts ) { m_motor . SetControl ( m_voltReq . WithOutput ( volts )); }, []( auto ) {}, this } }; Python self . motor = hardware . TalonFX ( 0 ) self . voltage_req = controls . VoltageOut ( 0 ) self . sys_id_routine = SysIdRoutine ( SysIdRoutine . Config ( # Use default ramp rate (1 V/s) and timeout (10 s) # Reduce dynamic voltage to 4 to prevent brownout stepVoltage = 4.0 , # Log state with Phoenix SignalLogger class recordState = lambda state : SignalLogger . write_string ( \"state\" , SysIdRoutineLog . stateEnumToString ( state )) ), SysIdRoutine . Mechanism ( lambda volts : self . motor . set_control ( self . voltage_req . with_output ( volts )), lambda log : None , self ) ) Now that the routine has been plumbed, the characterization commands need to be exposed from the subsystem. Java public Command sysIdQuasistatic ( SysIdRoutine . Direction direction ) { return m_sysIdRoutine . quasistatic ( direction ); } public Command sysIdDynamic ( SysIdRoutine . Direction direction ) { return m_sysIdRoutine . dynamic ( direction ); } C++ frc2 :: CommandPtr SysIdQuasistatic ( frc2 :: sysid :: Direction direction ) { return m_sysIdRoutine . Quasistatic ( direction ); } frc2 :: CommandPtr SysIdDynamic ( frc2 :: sysid :: Direction direction ) { return m_sysIdRoutine . Dynamic ( direction ); } Python def sys_id_quasistatic ( self , direction : SysIdRoutine . Direction ) -> Command : return self . sys_id_routine . quasistatic ( direction ) def sys_id_dynamic ( self , direction : SysIdRoutine . Direction ) -> Command : return self . sys_id_routine . dynamic ( direction ) From there, the program can bind buttons to these commands in RobotContainer . Java m_joystick . leftBumper (). onTrue ( Commands . runOnce ( SignalLogger :: start )); m_joystick . rightBumper (). onTrue ( Commands . runOnce ( SignalLogger :: stop )); /* * Joystick Y = quasistatic forward * Joystick A = quasistatic reverse * Joystick B = dynamic forward * Joystick X = dyanmic reverse */ m_joystick . y (). whileTrue ( m_mechanism . sysIdQuasistatic ( SysIdRoutine . Direction . kForward )); m_joystick . a (). whileTrue ( m_mechanism . sysIdQuasistatic ( SysIdRoutine . Direction . kReverse )); m_joystick . b (). whileTrue ( m_mechanism . sysIdDynamic ( SysIdRoutine . Direction . kForward )); m_joystick . x (). whileTrue ( m_mechanism . sysIdDynamic ( SysIdRoutine . Direction . kReverse )); C++ m_joystick . LeftBumper (). OnTrue ( frc2 :: cmd :: RunOnce ( SignalLogger :: Start )); m_joystick . RightBumper (). OnTrue ( frc2 :: cmd :: RunOnce ( SignalLogger :: Stop )); /* * Joystick Y = quasistatic forward * Joystick A = quasistatic reverse * Joystick B = dynamic forward * Joystick X = dynamic reverse */ m_joystick . Y (). WhileTrue ( m_mechanism . SysIdQuasistatic ( frc2 :: sysid :: Direction :: kForward )); m_joystick . A (). WhileTrue ( m_mechanism . SysIdQuasistatic ( frc2 :: sysid :: Direction :: kReverse )); m_joystick . B (). WhileTrue ( m_mechanism . SysIdDynamic ( frc2 :: sysid :: Direction :: kForward )); m_joystick . X (). WhileTrue ( m_mechanism . SysIdDynamic ( frc2 :: sysid :: Direction :: kReverse )); Python self . joystick . leftBumper () . onTrue ( cmd . runOnce ( SignalLogger . start )) self . joystick . rightBumper () . onTrue ( cmd . runOnce ( SignalLogger . stop )) # Joystick Y = quasistatic forward # Joystick A = quasistatic reverse # Joystick B = dynamic forward # Joystick X = dynamic reverse self . joystick . y () . whileTrue ( self . mechanism . sys_id_quasistatic ( SysIdRoutine . Direction . kForward )) self . joystick . a () . whileTrue ( self . mechanism . sys_id_quasistatic ( SysIdRoutine . Direction . kReverse )) self . joystick . b () . whileTrue ( self . mechanism . sys_id_dynamic ( SysIdRoutine . Direction . kForward )) self . joystick . x () . whileTrue ( self . mechanism . sys_id_dynamic ( SysIdRoutine . Direction . kReverse )) All four tests must be run and captured in a single log file. As a result, it is important that the user starts the Signal Logger before running the tests and stops the Signal Logger after all tests have been completed. This will ensure the log is not cluttered with data from other actions such as driving the robot to an open area. Note Consult the WPILib documentation for additional details on mechanism characterization. Before Characterization There are a couple of important things to consider before running the characterization tests. Characterization Can Be Dangerous: Danger Always use caution when mechanisms are moving and ensure that the robot can be disabled swiftly at any time! Since characterization applies a scaling (quasistatic) or constant (dynamic) voltage to the motor, it can very easily hit a wall (drivetrain) or break the mechanism (elevator) if unprepared. Ensure that the ramp rate is set appropriately and adequate space is given (15m recommended for drivetrain) for the tests. Ensure Adequate Space If the mechanism is continuous (swerve azimuth or a flywheel), then this is not an issue. However, mechanisms such as a drivetrain or elevator have a limited degree of movement. Ensure the configuration parameters match what is possible, and be prepared to disable the robot early. Only Run Each Test Once Limitations of the SysId desktop utility prevent multiple of the same tests to be properly analyzed. Ensure each test is run exactly once. Running Characterization The quasistatic test will slowly ramp up voltage until the button has been released or a timeout has been hit. It is always safe to end the tests early, but at least ~3-5 seconds of data is necessary. Ensure ramp rate is configured such that this can be accomplished. The dynamic test will immediately run the mechanism at the target voltage. This voltage may need to be adjusted if there is not sufficient room for the test. With the routines configured and buttons set up, the characterization tests can be performed. To keep things simple and debuggable, perform tests in the following order. Quasistatic forward Quasistatic reverse Dynamic forward Dynamic reverse Ensure each test is ran once, and only once. If a test is accidentally started multiple times, stop and restart the Signal Logger and try again. Once you have a log with all the tests, you can use Tuner X or the owlet CLI tool to extract the hoot log to WPILOG . The exported WPILOG can then be loaded into SysId for analysis using the Talon FX Position , Velocity , and MotorVoltage signals. Important We recommend users do not use third-party tools to export a hoot log to WPILOG. Doing so may result in a lossy conversion that impacts the quality of the SysId analysis. This is particularly true in simulation, where a lossy export can result in SysId failing to analyze the data.",
      "content_preview": "Plumbing & Running SysId For the purpose of this documentation, we focus on the integration of Phoenix 6 and WPILib’s SysId API to characterize common mechanisms. Detailed documentation on the SysId routines can be found here ."
    },
    {
      "url": "https://v6.docs.ctr-electronics.com/en/stable/docs/migration/migration-guide/feature-replacements-guide.html",
      "title": "Feature Replacements",
      "section": "General",
      "language": "All",
      "content": "Feature Replacements In addition to the changes shown in the other sections, several other Phoenix 5 features have been replaced or improved upon in Phoenix 6. Motor Invert In Phoenix 6, motor invert is now a persistent config ( Java , C++ ) instead of a control signal. Warning Since invert is a persistent config, getting and setting motor inverts are now blocking API calls. We recommend that users only set the invert once at program startup. Neutral Mode In Phoenix 6, Neutral mode is now available in API as a config ( Java , C++ ). Many control requests also have the ability to override the neutral mode to either force braking ( Java , C++ ) or force coasting ( Java , C++ ). Nominal Output The Talon FX forward and reverse Nominal Output configs have been removed in Phoenix 6. The typical use case of the nominal output configs is to overcome friction in closed-loop control modes, which can now be achieved using the kS feedforward parameter ( Java , C++ ). Sensor Phase The Talon FX setSensorPhase() method has been removed in Phoenix 6. The Talon FX integrated sensor is always in phase, so the method does nothing in Phoenix 5. When using a remote sensor, you can invert the remote sensor to bring it in phase with the Talon FX. Sensor Initialization Strategy The Talon FX and CANcoder sensors are always initialized to their absolute position in Phoenix 6. Clear Position on Limit In Phoenix 5, users could configure the TalonFX to clear its sensor position (i.e. set to 0) when a limit switch is triggered. In Phoenix 6, this feature has been improved to allow users to specify the applied sensor position when a limit switch is triggered. This can be configured using the *LimitAutosetPositionValue configs ( Java , C++ ). Velocity Measurement Period/Window In Phoenix 6, the velocity rolling average window in Talon FX and CANcoder has been replaced with a Kalman filter, resulting in a less noisy velocity signal with a minimal impact on latency (~1 ms). As a result, the velocity measurement period/window configs are no longer necessary in Phoenix 6 and have been removed. Integral Zone and Max Integral Accumulator Phoenix 6 automatically prevents integral windup in closed-loop controls. As a result, the Integral Zone and Max Integral Accumulator configs are no longer necessary and have been removed. CANcoder Sensor Coefficient and Units In Phoenix 6, CANcoder does not support setting a custom sensor coefficient, unit string, and sensor time base. Instead, the CANcoder uses canonical units of rotations and rotations per second using the C++ units library . Features to Be Implemented The following Phoenix 5 features are not implemented in the current release of Phoenix 6 but are planned to be implemented in the future. Feature Status CANdle Support Normal priority Features Omitted The following Phoenix 5 features have been omitted from Phoenix 6. While there are no plans for these features to be added, if there is customer demand for these features, they may be considered for addition in the future. Feedback is welcome at feedback @ ctr-electronics . com . Motion Profile Executor Control requests have been improved to cover many of the use cases of the Motion Profile Executor. Allowable Closed-Loop Error",
      "content_preview": "Feature Replacements In addition to the changes shown in the other sections, several other Phoenix 5 features have been replaced or improved upon in Phoenix 6. Motor Invert In Phoenix 6, motor invert is now a persistent config ( Java , C++ ) instead of a control signal."
    },
    {
      "url": "https://v6.docs.ctr-electronics.com/en/stable/docs/api-reference/wpilib-integration/unit-testing.html",
      "title": "Unit Testing",
      "section": "API Reference",
      "language": "All",
      "content": "Unit Testing High-fidelity simulation with CTR Electronics devices can be used for unit testing robot applications. When writing unit tests, the regular device APIs should be used to control devices and read status signals. Just like in simulation, the device SimState API can be used to update the simulated state of the device. Additionally, users must ensure the robot is enabled prior to controlling actuators. This can be accomplished in WPILib by calling DriverStationSim.setEnabled(true) ( Java , C++ ), followed by DriverStation.notifyNewData() to apply the change ( Java , C++ ). Important There may be a short delay between enabling the robot and the simulated actuators being enabled. Unit tests should delay for ~100ms after constructing all devices and enabling the robot to account for this delay. In unit tests, users should utilize the StatusSignal.waitForUpdate() and BaseStatusSignal.waitForAll() APIs to wait for fresh data after sending a control request or modifying the simulated device state. Important There may be a short delay between sending a control request and the simulated device applying the control. Unit tests should delay for ~20ms after sending a control request to account for this delay. Below is an example unit test that verifies the robot is enabled and verifies that the device responds to a control request. Java public class TalonFXTest implements AutoCloseable { static final double DELTA = 1e-3 ; // acceptable deviation range static final double kGearRatio = 10.0 ; TalonFX m_fx ; TalonFXSimState m_fxSim ; DCMotorSim m_motorSim ; @Override public void close () { /* destroy our TalonFX object */ m_fx . close (); } @BeforeEach public void constructDevices () { assert HAL . initialize ( 500 , 0 ); /* create the TalonFX */ m_fx = new TalonFX ( 0 ); m_fxSim = m_fx . getSimState (); /* create the simulated DC motor */ var gearbox = DCMotor . getKrakenX60Foc ( 1 ); m_motorSim = new DCMotorSim ( LinearSystemId . createDCMotorSystem ( gearbox , 0.001 , kGearRatio ), gearbox ); /* enable the robot */ DriverStationSim . setEnabled ( true ); DriverStationSim . notifyNewData (); /* delay ~100ms so the devices can start up and enable */ Timer . delay ( 0.100 ); } @AfterEach void shutdown () { close (); } @Test public void robotIsEnabled () { /* verify that the robot is enabled */ assertTrue ( DriverStation . isEnabled ()); } @Test public void motorDrives () { /* set the voltage supplied by the battery */ m_fxSim . setSupplyVoltage ( RobotController . getBatteryVoltage ()); var dutyCycle = m_fx . getDutyCycle (); /* wait for a fresh duty cycle signal */ dutyCycle . waitForUpdate ( 0.100 ); /* verify that the motor output is zero */ assertEquals ( dutyCycle . getValueAsDouble (), 0.0 , DELTA ); /* request 100% output */ m_fx . setControl ( new DutyCycleOut ( 1.0 )); /* wait for the control to apply and the motor to accelerate */ for ( int i = 0 ; i < 10 ; ++ i ) { Timer . delay ( 0.020 ); m_motorSim . setInputVoltage ( m_fxSim . getMotorVoltage ()); m_motorSim . update ( 0.020 ); m_fxSim . setRawRotorPosition ( m_motorSim . getAngularPosition (). times ( kGearRatio )); m_fxSim . setRotorVelocity ( m_motorSim . getAngularVelocity (). times ( kGearRatio )); } /* wait for a new duty cycle signal */ dutyCycle . waitForUpdate ( 0.100 ); /* verify that the motor output is 1.0 */ assertEquals ( dutyCycle . getValueAsDouble (), 1.0 , DELTA ); } } C++ class TalonFXTest : public testing :: Test { protected : static constexpr double kGearRatio = 10.0 ; /* create the TalonFX */ hardware :: TalonFX m_fx { 0 }; sim :: TalonFXSimState & m_fxSim { m_fx . GetSimState ()}; /* create the simulated DC motor */ frc :: sim :: DCMotorSim m_motorSim { frc :: LinearSystemId :: DCMotorSystem { frc :: DCMotor :: KrakenX60FOC ( 1 ), 0.001 _kg_sq_m , kGearRatio }, frc :: DCMotor :: KrakenX60FOC ( 1 ) }; void SetUp () override { /* enable the robot */ frc :: sim :: DriverStationSim :: SetEnabled ( true ); frc :: sim :: DriverStationSim :: NotifyNewData (); /* delay ~100ms so the devices can start up and enable */ std :: this_thread :: sleep_for ( std :: chrono :: milliseconds { 100 }); } }; TEST_F ( TalonFXTest , RobotIsEnabled ) { /* verify that the robot is enabled */ EXPECT_TRUE ( frc :: DriverStation :: IsEnabled ()); } TEST_F ( TalonFXTest , MotorDrives ) { /* set the voltage supplied by the battery */ m_fxSim . SetSupplyVoltage ( frc :: RobotController :: GetBatteryVoltage ()); auto & dutyCycle = m_fx . GetDutyCycle (); /* wait for a fresh duty cycle signal */ dutyCycle . WaitForUpdate ( 100 _ms ); /* verify that the motor output is zero */ EXPECT_DOUBLE_EQ ( dutyCycle . GetValue (), 0.0 ); /* request 100% output */ m_fx . SetControl ( controls :: DutyCycleOut { 1.0 }); /* wait for the control to apply and the motor to accelerate */ for ( int i = 0 ; i < 10 ; ++ i ) { std :: this_thread :: sleep_for ( std :: chrono :: milliseconds { 20 }); m_motorSim . SetInputVoltage ( m_fxSim . GetMotorVoltage ()); m_motorSim . Update ( 20 _ms ); m_fxSim . SetRawRotorPosition ( kGearRatio * m_motorSim . GetAngularPosition ()); m_fxSim . SetRotorVelocity ( kGearRatio * m_motorSim . GetAngularVelocity ()); } /* wait for a new duty cycle signal */ dutyCycle . WaitForUpdate ( 100 _ms ); /* verify that the motor output is 1.0 */ EXPECT_DOUBLE_EQ ( dutyCycle . GetValue (), 1.0 ); }",
      "content_preview": "Unit Testing High-fidelity simulation with CTR Electronics devices can be used for unit testing robot applications. When writing unit tests, the regular device APIs should be used to control devices and read status signals."
    },
    {
      "url": "https://v6.docs.ctr-electronics.com/en/stable/docs/hardware-reference/pigeon2/pigeon-issues.html",
      "title": "Pigeon 2 Troubleshooting",
      "section": "Pigeon 2",
      "language": "All",
      "content": "Pigeon 2 Troubleshooting A functional limitation was discovered in Pigeon 2s manufactured in September of 2022. When used on a CANivore (CAN FD) Bus, the Pigeon 2 may not transmit CAN FD frames correctly. As a result, you may find that all CAN device LEDs go red when the Pigeon 2 is in-circuit and powered. A firmware fix has been published, to update the firmware of an affected Pigeon 2, one of the below options can be used. Option 1: Workaround with Tuner X Note If you do not see the below option, then Tuner X is likely older than version 2023.1.5.0 . A new section in Tuner X Settings labeled Pigeon 2 Workaround has been added. When the Execute Pigeon 2 workaround button is pressed, all CANivores will enter a special mode that allows them to see the offending Pigeon 2s. This mode is reverted when the CANivore is power cycled. Once the workaround has been applied, the device will show up in the Devices menu and the LED should be alternating green/orange. Field-upgrade the firmware version and power cycle the CANivore. Option 2: Connect to the roboRIO Bus Connect the Pigeon 2 to the roboRIO CAN Bus and field-upgrade the firmware version. Note We recommend power cycling Pigeon after moving CAN bus leads from CANivore to roboRIO CAN bus to ensure a clean transition.",
      "content_preview": "Pigeon 2 Troubleshooting A functional limitation was discovered in Pigeon 2s manufactured in September of 2022. When used on a CANivore (CAN FD) Bus, the Pigeon 2 may not transmit CAN FD frames correctly."
    },
    {
      "url": "https://v6.docs.ctr-electronics.com/en/stable/docs/api-reference/device-specific/talonfx/index.html",
      "title": "TalonFX",
      "section": "TalonFX",
      "language": "All",
      "content": "TalonFX Introduction to TalonFX Control Open-Loop Control Closed-Loop Overview Basic PID and Profiling Motion Magic® Controls TalonFX Remote Sensors",
      "content_preview": "TalonFX Introduction to TalonFX Control Open-Loop Control Closed-Loop Overview Basic PID and Profiling Motion Magic® Controls TalonFX Remote Sensors"
    },
    {
      "url": "https://v6.docs.ctr-electronics.com/en/stable/docs/support.html",
      "title": "Support",
      "section": "General",
      "language": "All",
      "content": "Support CTR Electronics prides itself on excellent customer service. Our contact information can be found on our website .",
      "content_preview": "Support CTR Electronics prides itself on excellent customer service. Our contact information can be found on our website ."
    },
    {
      "url": "https://v6.docs.ctr-electronics.com/en/stable/docs/application-notes/update-frequency-impact.html",
      "title": "Factors that Impact Odometry",
      "section": "Application Notes",
      "language": "All",
      "content": "Factors that Impact Odometry Authored by Cory Often we’ve been asked what the impact higher frequencies, time synchronization, and synchronous API have on critical robot features, such as drivetrain odometry. This devblog will go into detail on the theoretical and practical impact they have. Note This doesn’t cover all the factors that impact odometry, but it includes some of the major ones that contribute significantly to odometry error. Update Frequencies Update frequency has a direct impact on the accuracy of your localization through odometry, as it is an integration problem. The less frequent the odometry is called, the more time error can accrue before being updated to the present state of the robot. This can be seen graphically, the desmos session below shows the error in position, and how the error decreases as the update frequency increases. https://www.desmos.com/calculator/vdgebi9s4t Note This desmos graph shows a Forward Euler discretization of a simple odometry case. The odometry solution provided by WPILib are discretized using the Pose Exponential, which is more accurate than Forward Euler. Discretization error at 50 Hz Discretization error at 250 Hz Synchronous API and Time Synchronization Synchronous API and Time Synchronization will further improve the performance of odometry. The two do this by reducing the overall latency of the signals and reducing the random distribution of latency involved in each signal. Further explanation of this is available in the Time Synchronization . Latency reduces the accuracy of the data being used in the odometry, and with lower accuracy going into the odometry, the result will be less accurate as well ( garbage in, garbage out concept). We can add this into our desmos session, including the effect of latency and variable latency to our error calculation. https://www.desmos.com/calculator/rytssjj158 Discretization error at 50 Hz with latency Discretization error at 250 Hz with latency Practical Results With the theory out of the way, we can see what kind of impact this has on the odometry of a real robot performing real maneuvers. We took a swerve drive robot and, using our Swerve API, drove it around the office. Attached on the robot is a limelight pointing straight up to our ceiling, which has April Tags at regular points. This allows the Limelight to know the absolute position of the robot throughout the motion. The Limelight is configured for a high resolution capture to reduce the error of its pose estimation, at the cost of less frequent pose calculations. This is acceptable, because as the robot performs its maneuvers, it will come to a rest at key points, and when it’s at rest, we can do our comparisons between the Limelight pose and the dead-reckoning from the odometry. As we performed the maneuvers, we logged the pose of the robot as reported by the odometry and the Limelight for use in playback. The “real” robot pose is the odometry-driven pose, and the ghost is the Limelight reported pose. It can be assumed the limelight pose is the “true” pose while the robot is at rest. Note The Limelight pose measurements are not latency-compensated, so they will lag behind the odometry pose. The focus of this experiment is to see the difference in pose between the two methods while the robot is relatively still, so that this lag due to latency is not a factor. The same maneuver was teleop-driven under the following circumstances, with the results below: CANivore CAN bus at 250 Hz (top left, measured at 45% CAN bus utilization) CANivore CAN bus at 50 Hz (top right, measured at 16% CAN bus utilization) RIO CAN bus at 250 Hz (bottom left, measured at 88% CAN bus utilization) RIO CAN bus at 50 Hz (bottom right, measured at 45% CAN bus utilization) Final States CANivore 250 Hz end position CANivore 50 Hz end position RIO 250 Hz end position RIO 50 Hz end position As can be seen, going from the RIO bus to the CANivore bus, or from 50 Hz to 250 Hz improves the accuracy of the odometry, and by a noticeable amount. Based on this, utilizing faster update frequencies and time synchronization from the CANivore should result in more accurate odometry, even for the “short” movements as shown in the gif. Data on the pose location is available for download: OdometryData.xlsx . After-Test Data Roughly 2 weeks after this initial data was collected and the blog post written, we went back and re-verified the data for the CANivore 250 Hz and RIO 250 Hz cases to further test the impact of time synchronization. These tests were ran in autonomous a total of 20 times (10 for CANivore, 10 for RIO), measuring the error of the odometry against the Limelight data. The results are below: RIO CANivore 0.52 0.14 0.33 0.28 0.47 0.56 0.23 0.22 0.51 0.32 0.23 0.18 0.22 0.30 0.59 0.26 0.15 0.33 0.11 0.25 This resulted in the following average and standard deviation of error: RIO CANivore Average 0.336 0.284 Standard Deviation 0.173 0.114",
      "content_preview": "Factors that Impact Odometry Authored by Cory Often we’ve been asked what the impact higher frequencies, time synchronization, and synchronous API have on critical robot features, such as drivetrain odometry. This devblog will go into detail on the theoretical and practical impact they have."
    },
    {
      "url": "https://v6.docs.ctr-electronics.com/en/stable/docs/tuner/tools.html",
      "title": "Tools",
      "section": "Phoenix Tuner X",
      "language": "All",
      "content": "Tools Tuner offers additional, miscellaneous functionality in the form of tool pages. Extracting Signal Logs CHRP Converter",
      "content_preview": "Tools Tuner offers additional, miscellaneous functionality in the form of tool pages. Extracting Signal Logs CHRP Converter"
    },
    {
      "url": "https://v6.docs.ctr-electronics.com/en/stable/docs/migration/migration-guide/configuration-guide.html",
      "title": "Configuration",
      "section": "General",
      "language": "All",
      "content": "Configuration Phoenix 6 simplifies the configuration process through the use of device-specific Configuration classes, as well as configuration groups. Note For more information about configuration in Phoenix 6, see Configuration . Applying Configs v5 Java // set slot 0 gains // 50 ms timeout on each config call m_motor . config_kF ( 0 , 0.05 , 50 ); m_motor . config_kP ( 0 , 0.046 , 50 ); m_motor . config_kI ( 0 , 0.0002 , 50 ); m_motor . config_kD ( 0 , 0.42 , 50 ); C++ // set slot 0 gains // 50 ms timeout on each config call m_motor . Config_kF ( 0 , 0.05 , 50 ); m_motor . Config_kP ( 0 , 0.046 , 50 ); m_motor . Config_kI ( 0 , 0.0002 , 50 ); m_motor . Config_kD ( 0 , 0.42 , 50 ); v6 Java var talonFXConfigs = new TalonFXConfiguration (); // set slot 0 gains and leave every other config factory-default var slot0Configs = talonFXConfigs . Slot0 ; slot0Configs . kV = 0.12 ; slot0Configs . kP = 0.11 ; slot0Configs . kI = 0.5 ; slot0Configs . kD = 0.001 ; // apply all configs, 50 ms total timeout m_talonFX . getConfigurator (). apply ( talonFXConfigs , 0.050 ); C++ configs :: TalonFXConfiguration talonFXConfigs {}; // set slot 0 gains and leave every other config factory-default configs :: Slot0Configs & slot0Configs = talonFXConfigs . Slot0 ; slot0Configs . kV = 0.12 ; slot0Configs . kP = 0.11 ; slot0Configs . kI = 0.5 ; slot0Configs . kD = 0.001 ; // apply all configs, 50 ms total timeout m_talonFX . GetConfigurator (). Apply ( talonFXConfigs , 50 _ms ); Factory Defaulting Configs v5 Java // user must remember to explicitly factory default if they configure devices in code m_motor . configFactoryDefault (); C++ // user must remember to explicitly factory default if they configure devices in code m_motor . ConfigFactoryDefault (); v6 Java // Any unmodified configs in a configuration object are *automatically* factory-defaulted. // As a result, factory-defaulting before applying configs is *unnecessary* when using a // full device configuration object, such as TalonFXConfiguration. // Users can perform a full factory default by passing a new device configuration object. m_motor . getConfigurator (). apply ( new TalonFXConfiguration ()); C++ // Any unmodified configs in a configuration object are *automatically* factory-defaulted; // As a result, factory-defaulting before applying configs is *unnecessary* when using a // full device configuration object, such as TalonFXConfiguration. // Users can perform a full factory default by passing a new device configuration object. m_motor . GetConfigurator (). Apply ( configs :: TalonFXConfiguration {}); Retrieving Configs v5 Java // a limited number of configs have configGet* methods; // for example, you can get the supply current limits var supplyCurLim = new SupplyCurrentLimitConfiguration (); m_motor . configGetSupplyCurrentLimit ( supplyCurLim ); C++ // a limited number of configs have ConfigGet* methods; // for example, you can get the supply current limits SupplyCurrentLimitConfiguration supplyCurLim {}; m_motor . ConfigGetSupplyCurrentLimit ( supplyCurLim ); v6 Java var fx_cfg = new TalonFXConfiguration (); // fetch *all* configs currently applied to the device m_motor . getConfigurator (). refresh ( fx_cfg ); C++ configs :: TalonFXConfiguration fx_cfg {}; // fetch *all* configs currently applied to the device m_motor . GetConfigurator (). Refresh ( fx_cfg );",
      "content_preview": "Configuration Phoenix 6 simplifies the configuration process through the use of device-specific Configuration classes, as well as configuration groups. Note For more information about configuration in Phoenix 6, see Configuration ."
    },
    {
      "url": "https://v6.docs.ctr-electronics.com/en/stable/docs/api-reference/api-usage/index.html",
      "title": "General API Usage",
      "section": "API Reference",
      "language": "All",
      "content": "General API Usage This section serves to provide general API usage for the Phoenix 6 API. For full details, please visit the API docs ( Java , C++ , Python ). Important While Phoenix 6 and Phoenix 5 devices may exist on the same CAN bus and same robot project, each robot project must use the API tied to the device firmware version. This means Phoenix 5 devices must use the Phoenix 5 API, and Phoenix 6 devices must use the Phoenix 6 API. There are three major components to the Phoenix 6 API: Configs Configs represent a persistent configuration for a device. For example, closed-loop gains. Configuration Control Requests Control Requests represent the output of a device, typically a motor controller. Control Requests Signals Signals represent data retrieved from a device. This can be velocity, position, yaw, pitch, roll, temperature, etc. Status Signals TalonFX Quickstart Quickstart on controlling a TalonFX with open loop control requests and a Joystick. Open-Loop Control API Overview Details a high level overview of what makes up the Phoenix 6 API. Configuration Describes configuring device configs via code. Control Requests Highlights using control requests to control the output of actuators such as the TalonFX. Status Signals Details using status signals to retrieve sensor data from devices. Signal Logging Information on the signal logging API used for capturing signal traffic on the bus. Hoot Replay Highlights playing back captured signals from a hoot log to test robot program changes. Device Faults Documents how faults are used to indicate device hardware status. Enabling Actuators Information on the FRC Lock safety feature and enabling actuators. Actuator Limits Documents how to retrieve and configure software and hardware actuator limits. Orchestra Information on playing music and sounds using the Orchestra API.",
      "content_preview": "General API Usage This section serves to provide general API usage for the Phoenix 6 API. For full details, please visit the API docs ( Java , C++ , Python )."
    },
    {
      "url": "https://v6.docs.ctr-electronics.com/en/stable/docs/migration/migration-guide/control-requests-guide.html",
      "title": "Control Requests",
      "section": "General",
      "language": "All",
      "content": "Control Requests Phoenix 6 provides an extensive list of flexible control modes through the use of strongly-typed control requests. Note For more information about control requests in Phoenix 6, see Control Requests . Using Control Requests v5 Java // robot init, set voltage compensation to 12 V m_motor . configVoltageComSaturation ( 12 ); m_motor . enableVoltageCompensation ( true ); // main robot code, command 12 V output m_motor . set ( ControlMode . PercentOutput , 1.0 ); C++ // robot init, set voltage compensation to 12 V m_motor . ConfigVoltageComSaturation ( 12 ); m_motor . EnableVoltageCompensation ( true ); // main robot code, command 12 V output m_motor . Set ( ControlMode :: PercentOutput , 1.0 ); v6 Java // class member variable final VoltageOut m_request = new VoltageOut ( 0 ); // main robot code, command 12 V output m_motor . setControl ( m_request . withOutput ( 12.0 )); // the control request `with` methods also accept unit types m_motor . setControl ( m_request . withOutput ( Volts . of ( 12.0 ))); C++ // class member variable controls :: VoltageOut m_request { 0 _V }; // main robot code, command 12 V output m_motor . SetControl ( m_request . WithOutput ( 12 _V )); Follower Motors v5 Java // robot init, set m_follower to follow m_leader m_follower . follow ( m_leader ); // m_follower should NOT oppose m_leader m_follower . setInverted ( TalonFXInvertType . FollowMaster ); // set m_strictFollower to follow m_leader m_strictFollower . follow ( m_leader ); // set m_strictFollower to ignore m_leader invert and use its own m_strictFollower . setInverted ( TalonFXInvertType . CounterClockwise ); // main robot code, command 100% output for m_leader m_leader . set ( ControlMode . PercentOutput , 1.0 ); // - m_follower and m_strictFollower will also run at 100% output // - m_follower will follow m_leader's invert, while m_strictFollower // ignores it and uses its own // NOTE: if set(), neutralOutput(), or disable() is ever called on // the followers, they will stop following C++ // robot init, set m_follower to follow m_leader m_follower . Follow ( m_leader ); // m_follower should NOT oppose m_leader m_follower . SetInverted ( TalonFXInvertType :: FollowMaster ); // set m_strictFollower to follow m_leader m_strictFollower . Follow ( m_leader ); // set m_strictFollower to ignore m_leader invert and use its own m_strictFollower . SetInverted ( TalonFXInvertType :: CounterClockwise ); // main robot code, command 100% output for m_leader m_leader . Set ( ControlMode :: PercentOutput , 1.0 ); // - m_follower and m_strictFollower will also run at 100% output // - m_follower will follow m_leader's invert, while m_strictFollower // ignores it and uses its own // NOTE: if Set(), NeutralOutput(), or Disable() is ever called on // the followers, they will stop following v6 Java // class member variables final DutyCycleOut m_request = new DutyCycleOut ( 0 ); // robot init, set m_follower to follow m_leader // m_follower should NOT oppose leader m_follower . setControl ( new Follower ( m_leader . getDeviceID (), false )); // set m_strictFollower to strict-follow m_leader // strict followers ignore the leader's invert and use their own m_strictFollower . setControl ( new StrictFollower ( m_leader . getDeviceID ())); // main robot code, command 100% output for m_leader m_motor . setControl ( m_request . withOutput ( 1.0 )); // - m_follower and m_strictFollower will also run at 100% output // - m_follower will follow m_leader's invert, while m_strictFollower // ignores it and uses its own C++ // class member variables controls :: DutyCycleOut m_request { 0 }; // robot init, set m_follower to follow m_leader // m_follower should NOT oppose leader m_follower . SetControl ( controls :: Follower { m_leader . GetDeviceID (), false }); // set m_strictFollower to strict-follow m_leader // strict followers ignore the leader's invert and use their own m_strictFollower . SetControl ( controls :: StrictFollower { m_leader . GetDeviceID ()}); // main robot code, command 100% output for m_leader m_motor . SetControl ( m_request . WithOutput ( 1.0 )); // - m_follower and m_strictFollower will also run at 100% output // - m_follower will follow m_leader's invert, while m_strictFollower // ignores it and uses its own Changing Update Frequency (Control Frame Period) v5 Java // slow down the Control 3 frame (general control) to 50 Hz (20ms) m_talonFX . setControlFramePeriod ( ControlFrame . Control_3_General , 20 ); C++ // slow down the Control 3 frame (general control) to 50 Hz (20ms) m_talonFX . SetControlFramePeriod ( ControlFrame :: Control_3_General , 20 ); v6 Java // class member variables final DutyCycleOut m_request = new DutyCycleOut ( 0 ); // slow down the control request to 50 Hz m_request . UpdateFreqHz = 50 ; C++ // class member variables controls :: DutyCycleOut m_request { 0 }; // slow down the control request to 50 Hz m_request . UpdateFreqHz = 50 _Hz ; Tip UpdateFreqHz can be set to 0 Hz to synchronously one-shot the control request. In this case, users must ensure the control request is sent periodically in their robot code. Therefore, we recommend users call setControl no slower than 20 Hz (50 ms) when the control is one-shot. Control Types In Phoenix 6, voltage compensation has been replaced with the ability to directly specify the control output type . All control output types are supported in open-loop and closed-loop control requests. Open-loop Control Requests Phoenix 5 Phoenix 6 PercentOutput DutyCycleOut PercentOutput + Voltage Compensation VoltageOut Phoenix 5 does not support torque control TorqueCurrentFOC (requires Pro) Current closed-loop This has been deprecated in Phoenix 6. Users looking to control torque should use TorqueCurrentFOC (requires Pro) Users looking to limit current should use supply and stator current limits Closed-loop Control Requests Phoenix 5 Phoenix 6 Position PositionDutyCycle Velocity VelocityDutyCycle MotionMagic MotionMagicDutyCycle Closed-loop + Voltage Compensation {ClosedLoop}Voltage Closed-loop + Torque Control (not supported in Phoenix 5) {ClosedLoop}TorqueCurrentFOC (requires Pro)",
      "content_preview": "Control Requests Phoenix 6 provides an extensive list of flexible control modes through the use of strongly-typed control requests. Note For more information about control requests in Phoenix 6, see Control Requests ."
    },
    {
      "url": "https://v6.docs.ctr-electronics.com/en/stable/docs/tuner/configs.html",
      "title": "Tuner Configs",
      "section": "Phoenix Tuner X",
      "language": "All",
      "content": "Tuner Configs Tip Devices can also be configured in code . Configs can be viewed, modified, backed-up, restored, and factory-defaulted via the Configs tab in Phoenix Tuner X. To apply a modified config, press the apply button (download icon) on the top button bar. Additional options are available by clicking on the 3-dots icon on the top button bar.",
      "content_preview": "Tuner Configs Tip Devices can also be configured in code . Configs can be viewed, modified, backed-up, restored, and factory-defaulted via the Configs tab in Phoenix Tuner X. To apply a modified config, press the apply button (download icon) on the top button bar."
    },
    {
      "url": "https://v6.docs.ctr-electronics.com/en/stable/docs/tuner/tuner-swerve/configuring-your-modules.html",
      "title": "Configuring Modules",
      "section": "Phoenix Tuner X",
      "language": "All",
      "content": "Configuring Modules Module configuration is comprised of 4 steps. Selecting encoder Selecting steer/turning motor Selecting drive motor Performing encoder calibration Selecting Module Devices The first step is to select the encoder and motor controllers for the selected swerve module. In the screenshot below, Talon FX (Device ID 0) and Talon FX (Device ID 1) are selected as the steer and drive motor controllers. Tip If a warning icon shows where the Blink icon is, this typically means this device has already been assigned to a module. Encoder Calibration Once a module’s devices have been selected, an Encoder Calibration button will appear on the right-side of the screen. This will open a popup that guides the user through aligning their module and calibrating their CANcoder offsets. Important It’s extremely important for the modules to be aligned such that the bevel gear faces the vertical center of the robot. Failure to perform this step may lead the drive verification tests to fail. Once calibration has been completed, the module will be removed from the Incomplete Modules list on the left. Switching between Modules Modules can be swapped by selecting the module in the dropdown located on the left-hand side of the wizard. Alternatively, a module can be selected by clicking on one of the yellow squares on the swerve bot in the top-left corner. Warning If an encoder has been reassigned to a new module, users should perform encoder calibration. Failure to perform encoder calibration will lead to unexpected module behavior. Once all modules have been configured, click on the Configuration Completed! button that appears. Warning To ensure the drive and steer tests are accurate, the devices are factory defaulted. It’s recommended that the user makes a backup of their configs if they are not applied in their robot program.",
      "content_preview": "Configuring Modules Module configuration is comprised of 4 steps. Selecting encoder Selecting steer/turning motor Selecting drive motor Performing encoder calibration Selecting Module Devices The first step is to select the encoder and motor controllers for the selected swerve module."
    },
    {
      "url": "https://v6.docs.ctr-electronics.com/en/stable/docs/installation/requirements.html",
      "title": "Requirements",
      "section": "General",
      "language": "All",
      "content": "Requirements This document explains the requirements to use Phoenix 6. Supported Devices Phoenix 6 supports the following devices: CANcoder CANdi™ CANdle® CANrange Pigeon 2.0 Talon FX ( Falcon 500 , Kraken X60 , Kraken X44 ) Talon FXS CAN Bus Requirements Phoenix 6 devices are supported on the below CAN bus adapters. FRC roboRIO CANivore non-FRC On Linux systems, any SocketCAN capable adapter will work, but the CANivore is highly recommended. CANivore offers additional functionality over other SocketCAN adapters. On Windows systems, you will need a CANivore to communicate with hardware. System Requirements Phoenix 6 supports a plethora of languages and operating systems. The table found below details which languages are supported on what platforms. FRC Targets Supported Languages Supports CANivore Supports High-Fidelity Simulation NI roboRIO Java, C++, Python Yes n/a Windows 10/11 x86-64 Java, C++, Python Yes Yes Linux x86-64 (desktop) [ 1 ] and ARM64 [ 2 ] Java, C++, Python Yes Yes macOS Java, C++, Python No Yes non-FRC Targets Supported Languages Supports CANivore Supports High-Fidelity Simulation Windows 10/11 x86-64 C#, Python Yes Yes (Python only) Linux x86-64 (desktop) [ 1 ] and ARM64 [ 2 ] C++, Python Yes Yes (Python only) Linux ARM32 [ 2 ] C++, Python Yes No macOS (Simulation Only) Python No Yes [ 1 ] ( 1 , 2 ) Supported Linux x86-64 (desktop) targets: Ubuntu 22.04 or newer Debian Bullseye or newer [ 2 ] ( 1 , 2 , 3 ) Supported Linux ARM32 and ARM64 targets: Raspberry Pi NVIDIA Jetson Ubuntu 20.04 or newer Debian Bullseye or newer",
      "content_preview": "Requirements This document explains the requirements to use Phoenix 6. Supported Devices Phoenix 6 supports the following devices: CANcoder CANdi™ CANdle® CANrange Pigeon 2.0 Talon FX ( Falcon 500 , Kraken X60 , Kraken X44 ) Talon FXS CAN Bus Requirements Phoenix 6 devices are supported on the..."
    },
    {
      "url": "https://v6.docs.ctr-electronics.com/en/stable/docs/api-reference/device-specific/talonfx/open-loop-requests.html",
      "title": "Open",
      "section": "TalonFX",
      "language": "All",
      "content": "Open-Loop Control Open-Loop control typically refers to directly controlling device output. There are open-loop control requests for all TalonFX control output types. With the exception of FOC-only control requests, all open-loop control requests follow the naming pattern {ControlOutputType}Out . For example, the open-loop Voltage control request is called VoltageOut . FOC-only control requests follow the naming pattern {ControlOutputType} . In the below example, note that devices are initialized with two arguments. These arguments correspond to the device ID and CAN bus name. For CANivore, this is the name of the CANivore as configured in Phoenix Tuner X . For more information, see the CANivore API documentation. Java // initialize devices on the rio can bus final TalonFX m_leftLeader = new TalonFX ( 0 , \"rio\" ); final TalonFX m_rightLeader = new TalonFX ( 1 , \"rio\" ); // users should reuse control requests when possible final DutyCycleOut m_leftRequest = new DutyCycleOut ( 0.0 ); final DutyCycleOut m_rightRequest = new DutyCycleOut ( 0.0 ); // retrieve joystick inputs var forward = - m_driverJoy . getLeftY (); var turn = m_driverJoy . getRightX (); // calculate motor outputs, utilizes a \"arcade\" style of driving; // where left Y controls forward and right X controls rotation/turn var leftOut = forward + turn ; var rightOut = forward - turn ; // set request to motor controller m_leftLeader . setControl ( m_leftRequest . withOutput ( leftOut )); m_rightLeader . setControl ( m_rightRequest . withOutput ( rightOut )); C++ // initialize devices on the rio can bus hardware :: TalonFX m_leftLeader { 0 , \"rio\" }; hardware :: TalonFX m_rightLeader { 1 , \"rio\" }; // users should reuse control requests when possible controls :: DutyCycleOut m_leftRequest { 0.0 }; controls :: DutyCycleOut m_rightRequest { 0.0 }; // retrieve joystick inputs auto forward = - m_driverJoy . GetLeftY (); auto turn = m_driverJoy . GetRightX (); // calculate motor outputs, utilizes a \"arcade\" style of driving; // where left Y controls forward and right X controls rotation/turn auto leftOut = forward + turn ; auto rightOut = forward - turn ; // set request to motor controller m_leftLeader . SetControl ( m_leftRequest . WithOutput ( leftOut )); m_rightLeader . SetControl ( m_rightRequest . WithOutput ( rightOut )); Python # initialize devices on the rio can bus self . left_leader = hardware . TalonFX ( 0 , \"rio\" ) self . right_leader = hardware . TalonFX ( 1 , \"rio\" ) # users should reuse control requests when possible self . left_request = controls . DutyCycleOut ( 0.0 ) self . right_request = controls . DutyCycleOut ( 0.0 ) # retrieve joystick inputs forward = - self . driver_joy . getLeftY () turn = self . driver_joy . getRightX () # calculate motor outputs, utilizes a \"arcade\" style of driving # where left Y controls forward and right X controls rotation/turn left_out = forward + turn right_out = forward - turn # set request to motor controllers self . left_leader . set_control ( self . left_request . with_output ( left_out )) self . right_leader . set_control ( self . right_request . with_output ( right_out ))",
      "content_preview": "Open-Loop Control Open-Loop control typically refers to directly controlling device output. There are open-loop control requests for all TalonFX control output types. With the exception of FOC-only control requests, all open-loop control requests follow the naming pattern {ControlOutputType}Out ."
    },
    {
      "url": "https://v6.docs.ctr-electronics.com/en/stable/docs/hardware-reference/pigeon2/index.html",
      "title": "Pigeon 2.0",
      "section": "Pigeon 2",
      "language": "All",
      "content": "Pigeon 2.0 Pigeon 2.0 is the next evolution in the family of Pigeon IMUs. With no on-boot calibration or temperature calibration required and dramatic improvement to drift, the Pigeon is the easiest IMU to use yet. Pigeon 2 Troubleshooting Store Page CAD and purchase instructions. https://store.ctr-electronics.com/pigeon-2/ Hardware User Manual Wiring and mount instructions in PDF format. https://store.ctr-electronics.com/content/user-manual/Pigeon2%20User’s%20Guide.pdf Status Light Reference Blink Codes Animation (Click to play) LED State Cause Possible Fix LEDs Off No Power Provide 12V to Red/Black leads. Blinking Alternating Red Pigeon 2 does not have valid CAN. Ensure good connections between CANH and CANL (Yellow and Green) & robot controller is on. Blinking Alternating Orange Pigeon 2 detects CAN but does not see Phoenix running on the robot controller. If Phoenix is running on the robot controller, ensure good connection between the controller and this device. Otherwise, deploy a robot program that uses Phoenix. Blinking Simultaneous Orange Pigeon 2 detects CAN and sees the robot is disabled. Phoenix is running in robot controller and Pigeon 2 has good CAN connection to robot controller. Blinking Alternating Green Pigeon 2 detects CAN and sees the robot is enabled. Alternate Red/Orange Damaged Hardware. Use Tuner X Self Test to confirm the LEDs and that the hardware fault is set, then contact CTRE Single LED alternates Green/Orange Pigeon 2 in bootloader. Field-upgrade device in Tuner X. Mount Calibration It’s recommended to perform a mount calibration when placement of the Pigeon 2.0 has been finalized. This can be done via the Calibration page in Tuner X.",
      "content_preview": "Pigeon 2.0 Pigeon 2.0 is the next evolution in the family of Pigeon IMUs. With no on-boot calibration or temperature calibration required and dramatic improvement to drift, the Pigeon is the easiest IMU to use yet. Pigeon 2 Troubleshooting Store Page CAD and purchase instructions."
    },
    {
      "url": "https://v6.docs.ctr-electronics.com/en/stable/docs/api-reference/device-specific/talonfx/remote-sensors.html",
      "title": "TalonFX Remote Sensors",
      "section": "TalonFX",
      "language": "All",
      "content": "TalonFX Remote Sensors The TalonFX supports various remote sensors. Remote sensors allow onboard closed-loop functionality at rates faster than a traditional robot processor (~1Khz) by reading the remote sensor directly from the CAN bus. This allows supported motor controllers to execute closed-loop modes with sensor values sourced by supported sensors. A list of supported remote sensors can be found in the API docs ( Java , C++ , Python ). Remote sensors can be configured using Tuner X or via code. This document highlights how to configure a remote sensor in a robot program. RemoteCANcoder A supported motor controller will update its position and velocity whenever the CANcoder publishes its information on the CAN bus. Java var fx_cfg = new TalonFXConfiguration (); fx_cfg . Feedback . FeedbackRemoteSensorID = m_cancoder . getDeviceID (); fx_cfg . Feedback . FeedbackSensorSource = FeedbackSensorSourceValue . RemoteCANcoder ; m_talonFX . getConfigurator (). apply ( fx_cfg ); C++ configs :: TalonFXConfiguration fx_cfg {}; fx_cfg . Feedback . FeedbackRemoteSensorID = m_cancoder . GetDeviceID (); fx_cfg . Feedback . FeedbackSensorSource = signals :: FeedbackSensorSourceValue :: RemoteCANcoder ; m_talonFX . GetConfigurator (). Apply ( fx_cfg ); Python fx_cfg = configs . TalonFXConfiguration () fx_cfg . feedback . feedback_remote_sensor_id = self . cancoder . device_id fx_cfg . feedback . feedback_sensor_source = signals . FeedbackSensorSourceValue . REMOTE_CANCODER self . talonfx . configurator . apply ( fx_cfg ) FusedCANcoder Important This feature requires the device to be Pro licensed . When unlicensed, the TalonFX will fall back to RemoteCANcoder and trip the UsingFusedCANcoderWhileUnlicensed fault. New in Phoenix 6 is a feedback sensor type called FusedCANcoder . FusedCANcoder will fuse another CANcoder’s information with the motor’s internal rotor, which provides the best possible position and velocity for accuracy and bandwidth. This is useful in applications such as swerve azimuth. FusedCANcoder requires the configuration of several Feedback config group items, shown below. Full example: Java , C++ Java 60 /* Configure CANcoder to zero the magnet appropriately */ 61 CANcoderConfiguration cc_cfg = new CANcoderConfiguration (); 62 cc_cfg . MagnetSensor . AbsoluteSensorRange = AbsoluteSensorRangeValue . Signed_PlusMinusHalf ; 63 cc_cfg . MagnetSensor . SensorDirection = SensorDirectionValue . CounterClockwise_Positive ; 64 cc_cfg . MagnetSensor . withMagnetOffset ( Rotations . of ( 0.4 )); 65 m_cc . getConfigurator (). apply ( cc_cfg ); 66 67 TalonFXConfiguration fx_cfg = new TalonFXConfiguration (); 68 fx_cfg . Feedback . FeedbackRemoteSensorID = m_cc . getDeviceID (); 69 fx_cfg . Feedback . FeedbackSensorSource = FeedbackSensorSourceValue . FusedCANcoder ; 70 fx_cfg . Feedback . SensorToMechanismRatio = 1.0 ; 71 fx_cfg . Feedback . RotorToSensorRatio = 12.8 ; 72 73 m_fx . getConfigurator (). apply ( fx_cfg ); C++ 11 /* Configure CANcoder to zero the magnet appropriately */ 12 configs :: CANcoderConfiguration cc_cfg {}; 13 cc_cfg . MagnetSensor . AbsoluteSensorRange = signals :: AbsoluteSensorRangeValue :: Signed_PlusMinusHalf ; 14 cc_cfg . MagnetSensor . SensorDirection = signals :: SensorDirectionValue :: CounterClockwise_Positive ; 15 cc_cfg . MagnetSensor . MagnetOffset = 0.4 _tr ; 16 m_cc . GetConfigurator (). Apply ( cc_cfg ); 17 18 configs :: TalonFXConfiguration fx_cfg {}; 19 fx_cfg . Feedback . FeedbackRemoteSensorID = m_cc . GetDeviceID (); 20 fx_cfg . Feedback . FeedbackSensorSource = signals :: FeedbackSensorSourceValue :: FusedCANcoder ; 21 fx_cfg . Feedback . SensorToMechanismRatio = 1.0 ; 22 fx_cfg . Feedback . RotorToSensorRatio = 12.8 ; 23 24 m_fx . GetConfigurator (). Apply ( fx_cfg ); Python cc_cfg = configs . CANcoderConfiguration () cc_cfg . magnet_sensor . absolute_sensor_range = signals . AbsoluteSensorRangeValue . SIGNED_PLUS_MINUS_HALF cc_cfg . magnet_sensor . sensor_direction = signals . SensorDirectionValue . COUNTER_CLOCKWISE_POSITIVE cc_cfg . magnet_sensor . magnet_offset = 0.4 self . cc . configurator . apply ( cc_cfg ) fx_cfg = configs . TalonFXConfiguration () fx_cfg . feedback . feedback_remote_sensor_id = self . cc . device_id fx_cfg . feedback . feedback_sensor_source = signals . FeedbackSensorSourceValue . FUSED_CANCODER fx_cfg . feedback . sensor_to_mechanism_ratio = 1.0 fx_cfg . feedback . rotor_to_sensor_ratio = 12.8 self . fx . configurator . apply ( fx_cfg ) Usage is the same as any status signal : Java fx_pos . refresh (); cc_pos . refresh (); System . out . println ( \"FX Position: \" + fx_pos . toString ()); System . out . println ( \"CANcoder Position: \" + cc_pos . toString ()); C++ fx_pos . Refresh (); cc_pos . Refresh (); std :: cout << \"FX Position: \" << fx_pos << std :: endl ; std :: cout << \"CANcoder Position: \" << cc_pos << std :: endl ; Python fx_pos . refresh () cc_pos . refresh () print ( \"FX Position: \" + fx_pos . value ) print ( \"CANcoder Position: \" + cc_pos . value ) SyncCANcoder Important This feature requires the device to be Pro licensed . When unlicensed, the TalonFX will fall back to RemoteCANcoder and trip the UsingFusedCANcoderWhileUnlicensed fault. SyncCANcoder allows users to synchronize the TalonFX’s internal rotor sensor against the remote CANcoder, but continue to use the rotor sensor for all closed loop control. TalonFX will continue to monitor the remote CANcoder and report if its internal position differs significantly from the reported position or if the remote CANcoder disappears from the bus. Users may want SyncCANcoder instead of FusedCANcoder if there is risk that the sensor can fail in a way that the sensor is still reporting “good” data, but the data does not match the mechanism, such as if the entire sensor mount assembly breaks off. Using SyncCANcoder over FusedCANcoder will not benefit from backlash compensation, as the CANcoder position is not continually fused in. SyncCANcoder requires the configuration of several Feedback config group items, shown below. Java /* Configure CANcoder to zero the magnet appropriately */ CANcoderConfiguration cc_cfg = new CANcoderConfiguration (); cc_cfg . MagnetSensor . AbsoluteSensorRange = AbsoluteSensorRangeValue . Signed_PlusMinusHalf ; cc_cfg . MagnetSensor . SensorDirection = SensorDirectionValue . CounterClockwise_Positive ; cc_cfg . MagnetSensor . MagnetOffset = 0.4 ; m_cc . getConfigurator (). apply ( cc_cfg ); TalonFXConfiguration fx_cfg = new TalonFXConfiguration (); fx_cfg . Feedback . FeedbackRemoteSensorID = m_cc . getDeviceID (); fx_cfg . Feedback . FeedbackSensorSource = FeedbackSensorSourceValue . SyncCANcoder ; fx_cfg . Feedback . SensorToMechanismRatio = 1.0 ; fx_cfg . Feedback . RotorToSensorRatio = 12.8 ; m_fx . getConfigurator (). apply ( fx_cfg ); C++ /* Configure CANcoder to zero the magnet appropriately */ configs :: CANcoderConfiguration cc_cfg {}; cc_cfg . MagnetSensor . AbsoluteSensorRange = signals :: AbsoluteSensorRangeValue :: Signed_PlusMinusHalf ; cc_cfg . MagnetSensor . SensorDirection = signals :: SensorDirectionValue :: CounterClockwise_Positive ; cc_cfg . MagnetSensor . MagnetOffset = 0.4 ; m_cc . GetConfigurator (). Apply ( cc_cfg ); configs :: TalonFXConfiguration fx_cfg {}; fx_cfg . Feedback . FeedbackRemoteSensorID = m_cc . GetDeviceID (); fx_cfg . Feedback . FeedbackSensorSource = signals :: FeedbackSensorSourceValue :: SyncCANcoder ; fx_cfg . Feedback . SensorToMechanismRatio = 1.0 ; fx_cfg . Feedback . RotorToSensorRatio = 12.8 ; m_fx . GetConfigurator (). Apply ( fx_cfg ); Python cc_cfg = configs . CANcoderConfiguration () cc_cfg . magnet_sensor . absolute_sensor_range = signals . AbsoluteSensorRangeValue . SIGNED_PLUS_MINUS_HALF cc_cfg . magnet_sensor . sensor_direction = signals . SensorDirectionValue . COUNTER_CLOCKWISE_POSITIVE cc_cfg . magnet_sensor . magnet_offset = 0.4 self . cc . configurator . apply ( cc_cfg ) fx_cfg = configs . TalonFXConfiguration () fx_cfg . feedback . feedback_remote_sensor_id = self . cc . device_id fx_cfg . feedback . feedback_sensor_source = signals . FeedbackSensorSourceValue . SYNC_CANCODER fx_cfg . feedback . sensor_to_mechanism_ratio = 1.0 fx_cfg . feedback . rotor_to_sensor_ratio = 12.8 self . fx . configurator . apply ( fx_cfg )",
      "content_preview": "TalonFX Remote Sensors The TalonFX supports various remote sensors. Remote sensors allow onboard closed-loop functionality at rates faster than a traditional robot processor (~1Khz) by reading the remote sensor directly from the CAN bus."
    },
    {
      "url": "https://v6.docs.ctr-electronics.com/en/stable/docs/api-reference/api-usage/api-overview.html",
      "title": "API Overview",
      "section": "API Reference",
      "language": "All",
      "content": "API Overview The Phoenix 6 API resides in the com.ctre.phoenix6 package in Java, the ctre::phoenix6 namespace in C++, and the phoenix6 module in Python. The API is then further organized into smaller packages and namespaces that group together similar types of classes and functions: configs - classes related to device configuration controls - classes related to device control hardware - the device hardware classes, such as TalonFX signals - enumeration types for device signals sim - classes related to device simulation C++ IntelliSense In C++, this namespace structure has the advantage of cleaning up IntelliSense when searching for classes: // first use the ctre::phoenix6 namespace using namespace ctre :: phoenix6 ; // now types are organized cleanly by namespace hardware :: TalonFX m_talonFX { 0 }; sim :: TalonFXSimState & m_talonFXSim { m_talonFX . GetSimState ()}; controls :: DutyCycleOut m_talonFXOut { 0 }; configs :: TalonFXConfiguration m_talonFXConfig {}; signals :: InvertedValue m_talonFXInverted { signals :: InvertedValue :: CounterClockwise_Positive }; All C++ code examples in this documentation will assume the presence of using namespace ctre::phoenix6; . Python Imports Python also takes advantage of the module structure to improve IntelliSense: # first import the relevant modules and types from phoenix6 import controls , configs , hardware , signals # now types are organized cleanly by module self . talonfx = hardware . TalonFX ( 0 ) self . talonfx_out = controls . DutyCycleOut ( 0 ) talonfx_configs = configs . TalonFXConfiguration () talonfx_inverted = signals . InvertedValue . COUNTER_CLOCKWISE_POSITIVE All Python code examples in this documentation will assume the presence of from phoenix6 import * . Thread Safety The vast majority of Phoenix 6 is thread-safe with a few exceptions. Objects that are not thread-safe include: StatusSignal objects Calling the same device StatusSignal getter (e.g. TalonFX.getVelocity() ) from multiple threads is unsafe. This is because device signal getters refresh the StatusSignal implicitly. Users should clone or copy a StatusSignal object to get a unique instance for a given thread. Config objects Includes TalonFX.setInverted() and TalonFX.setNeutralMode() However, device Configurator objects and other setters (e.g. TalonFX.setPosition() ) are thread-safe. Control objects However, sending a control request to a device is thread-safe.",
      "content_preview": "API Overview The Phoenix 6 API resides in the com.ctre.phoenix6 package in Java, the ctre::phoenix6 namespace in C++, and the phoenix6 module in Python."
    },
    {
      "url": "https://v6.docs.ctr-electronics.com/en/stable/docs/api-reference/api-usage/faults.html",
      "title": "Device Faults",
      "section": "API Reference",
      "language": "All",
      "content": "Device Faults “Faults” are status indicators on CTR Electronics CAN devices that indicate a certain behavior or event has occurred. Faults do not directly affect the behavior of a device; instead, they indicate the device’s current status and highlight potential issues. Faults are stored in two fashions. There are “live” faults, which are reported in real-time, and “sticky” faults, which assert persistently and stay asserted until they are manually cleared (like trouble codes in a vehicle). Sticky Faults can be cleared by clicking the Clear Faults button in Phoenix Tuner X, or by calling clearStickyFaults() on the device in the robot program. A regular fault can only be cleared when the offending problem has been resolved. Using API to Retrieve Faults Faults can also be retrieved in API using the getFault_*() (regular) or getStickyFault_*() (sticky) methods on the device object. This can be useful for diagnostics or error handling. Java var faulted = m_cancoder . getFault_BadMagnet (). getValue (); if ( faulted ) { // do action when bad magnet fault is set } C++ auto faulted = m_cancoder . GetFault_BadMagnet (). GetValue (); if ( faulted ) { // do action when bad magnet fault is set } Python faulted = self . cancoder . get_fault_bad_magnet () . value if faulted : # do action when bad magnet fault is set A list of possible faults can be found in the API documentation for each device. Using API to Clear Sticky Faults Sticky faults can be cleared in API using the clearStickyFaults() method on the device objects. Additionally, individual sticky faults may be cleared using the clearStickyFault_*() APIs. Note Clearing sticky faults is a blocking operation and should not be run in a periodic loop. Java // clear the undervoltage sticky fault m_cancoder . clearStickyFault_Undervoltage (); C++ // clear the undervoltage sticky fault m_cancoder . ClearStickyFault_Undervoltage (); Python # clear the undervoltage sticky fault self . cancoder . clear_sticky_fault_undervoltage ()",
      "content_preview": "Device Faults “Faults” are status indicators on CTR Electronics CAN devices that indicate a certain behavior or event has occurred. Faults do not directly affect the behavior of a device; instead, they indicate the device’s current status and highlight potential issues."
    },
    {
      "url": "https://v6.docs.ctr-electronics.com/en/stable/docs/api-reference/index.html",
      "title": "API Reference",
      "section": "API Reference",
      "language": "All",
      "content": "API Reference This section highlights the functionality that is exposed as part of the Phoenix 6 API. API Usage Documentation on using the Phoenix 6 API. General API Usage Device Specific Device specific API information for devices. Device API Simulation Details on utilizing the extensive Phoenix 6 simulation support. Simulation WPILib Integration Documentation on the WPILib features supported by Phoenix 6. WPILib Integration Examples Detailed examples and projects that utilize Phoenix 6. Examples General API Usage Device API Mechanisms Simulation WPILib Integration Examples",
      "content_preview": "API Reference This section highlights the functionality that is exposed as part of the Phoenix 6 API. API Usage Documentation on using the Phoenix 6 API. General API Usage Device Specific Device specific API information for devices."
    }
  ]
}
